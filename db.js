const db = [
  {
    front: "<h1></h1>",
    back: ``,
    group: "Test",
  },
  {
    front: "<h1>Каковы принципы семантической верстки?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Принципы семантической верстки включают следующее:</p><ol><li>Использование подходящих HTML-тегов: Используйте теги, которые лучше всего описывают содержимое (например, <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;footer&gt;</code> и т.д.).</li><li>Ясное обозначение структуры: Разделяйте страницу на смысловые блоки, используя подходящие теги, чтобы облегчить понимание структуры контента.</li><li>Корректное использование заголовков: Используйте заголовки <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code> в правильной иерархии, чтобы отразить важность и связь различных разделов страницы.</li><li>Описание ссылок и элементов управления: Используйте атрибуты <code>title</code> и <code>alt</code> для описания ссылок и изображений, а также добавляйте подсказки к элементам управления.</li><li>Правильное применение списков: Используйте <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code> и <code>&lt;dl&gt;</code> для создания списков с пунктами, нумерацией или определениями соответственно.</li><li>Отсутствие таблиц для макета: Используйте таблицы только для представления табличных данных, а не для создания макета страницы.</li></ol><p>Семантическая верстка способствует лучшей доступности, SEO-оптимизации и облегчает сопровождение и понимание кода разработчиками.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие есть методы http запросов?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Существует несколько методов HTTP-запросов, которые определяют тип запроса, выполняемого клиентом. Некоторые из наиболее распространенных методов HTTP-запросов включают:</p><ol><li><p>GET: Получение ресурса по указанному URI. Этот метод используется для получения данных, которые могут быть кэшированы и могут быть переданы в строке запроса.</p></li><li><p>POST: Отправка данных на сервер для обработки. Этот метод используется для отправки данных на сервер, например, для создания новых ресурсов на сервере или для обновления существующих.</p></li><li><p>PUT: Замена ресурса или создание нового ресурса на сервере. Этот метод используется для создания или обновления ресурса на сервере.</p></li><li><p>DELETE: Удаление ресурса на сервере. Этот метод используется для удаления ресурса на сервере.</p></li><li><p>HEAD: Получение метаданных ресурса по указанному URI. Этот метод используется для получения метаданных, например, заголовков, без получения фактического содержимого ресурса.</p></li><li><p>OPTIONS: Получение информации о возможностях сервера по обработке запроса. Этот метод используется для получения информации о методах HTTP, поддерживаемых сервером, и других возможностях сервера.</p></li><li><p>TRACE: Получение отладочной информации о запросе. Этот метод используется для получения информации о том, как запрос проходит через промежуточные серверы.</p></li><li><p>CONNECT: Установка сетевого соединения с сервером через прокси-сервер. Этот метод используется для установки сетевого соединения с сервером через прокси-сервер.</p></li><li><p>PATCH: Частичное обновление ресурса на сервере. Этот метод используется для частичного обновления ресурса на сервере.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Зачем может понадобиться получение метаданных, например, заголовков, без получения фактического содержимого ресурса?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Получение метаданных ресурса, например, заголовков, без получения фактического содержимого ресурса, может быть полезно в нескольких случаях:</p><ol><li><p>Проверка доступности ресурса: Запрос типа HEAD может быть использован для проверки доступности ресурса без загрузки фактического содержимого. Это позволяет быстро проверить, существует ли ресурс на сервере и доступен ли он без необходимости загружать полное содержимое ресурса.</p></li><li><p>Получение метаданных ресурса: Заголовки HTTP-запроса содержат много полезной информации, например, о типе содержимого, размере файла, дате создания и дате последней модификации. Запрос типа HEAD может быть использован для получения этой информации, не загружая фактическое содержимое ресурса.</p></li><li><p>Экономия трафика: Запрос типа HEAD может быть использован для экономии трафика, особенно в случаях, когда содержимое ресурса крупное или когда пользовательская скорость интернета низкая. Получение только метаданных ресурса позволяет уменьшить объем передаваемых данных и сократить время загрузки страницы.</p></li><li><p>Защита конфиденциальности: Запрос типа HEAD может быть использован для защиты конфиденциальности, например, если ресурс содержит конфиденциальные данные, такие как пароли, которые не должны быть загружены на клиентскую машину. Получение только метаданных ресурса позволяет получить необходимую информацию без загрузки конфиденциального содержимого ресурса.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие есть версии http протокола?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Существует несколько версий протокола HTTP (Hypertext Transfer Protocol), которые были разработаны со временем для улучшения и расширения функциональности протокола. Наиболее распространенные версии HTTP:</p><ol><li><p>HTTP/0.9: Это первая версия HTTP, которая была разработана в 1991 году. Она была предназначена только для передачи HTML-документов и не поддерживала заголовки или другие типы содержимого.</p></li><li><p>HTTP/1.0: Это следующая версия HTTP, которая была выпущена в 1996 году. Она включила поддержку различных типов содержимого, заголовков запросов и ответов, а также возможность передачи бинарных данных.</p></li><li><p>HTTP/1.1: Эта версия HTTP была выпущена в 1999 году и включает множество улучшений, таких как поддержка кэширования, поддержка сжатия данных, возможность ограничения скорости передачи и другие функции.</p></li><li><p>HTTP/2: Это новая версия HTTP, выпущенная в 2015 году. Она предлагает ряд значительных улучшений по сравнению с HTTP/1.1, включая мультиплексирование, сжатие заголовков и данных, приоритеты потоков и другие функции, которые позволяют значительно улучшить производительность и безопасность веб-приложений.</p></li><li><p>HTTP/3: Это последняя версия HTTP, выпущенная в 2020 году. Она основана на протоколе QUIC (Quick UDP Internet Connections) и предлагает дополнительные улучшения производительности, такие как снижение задержек, сокращение числа обменов данными и улучшение безопасности.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие существуют коды ответа (состояния) в http?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>HTTP (Hypertext Transfer Protocol) использует коды ответа (состояния), чтобы указать результат выполнения запроса. Коды ответа HTTP делятся на пять классов, каждый из которых имеет свои числовые коды:</p><ol><li><p>Информационные коды (Informational): Коды ответа, начинающиеся с 1xx, указывают на то, что запрос принят, но обработка еще продолжается.</p></li><li><p>Коды успеха (Success): Коды ответа, начинающиеся с 2xx, указывают на то, что запрос был успешно обработан и возвращен запрошенный ресурс.</p></li><li><p>Коды перенаправления (Redirection): Коды ответа, начинающиеся с 3xx, указывают на то, что для получения запрошенного ресурса клиенту необходимо выполнить дополнительные действия, например, перейти на другой URL.</p></li><li><p>Коды ошибок клиента (Client errors): Коды ответа, начинающиеся с 4xx, указывают на ошибки, связанные с запросом, отправленным клиентом. Например, такие ошибки, как 404 Not Found (страница не найдена), 403 Forbidden (доступ запрещен) и другие.</p></li><li><p>Коды ошибок сервера (Server errors): Коды ответа, начинающиеся с 5xx, указывают на ошибки, связанные с обработкой запроса на сервере. Например, такие ошибки, как 500 Internal Server Error (внутренняя ошибка сервера), 503 Service Unavailable (сервис временно недоступен) и другие.</p></li></ol><p>Некоторые из наиболее распространенных кодов ответа HTTP:</p><ul><li>200 OK: запрос выполнен успешно, и результатом является запрошенный ресурс.</li><li>201 Created: ресурс был создан успешно.</li><li>204 No Content: запрос выполнен успешно, но ответ не содержит содержимого (например, в ответ на запрос метода DELETE).</li><li>301 Moved Permanently: запрошенный ресурс перемещен на другой URL, постоянно.</li><li>302 Found: запрошенный ресурс временно перемещен на другой URL.</li><li>400 Bad Request: запрос был неверным, сервер не может понять, что требуется от него.</li><li>401 Unauthorized: для доступа к запрошенному ресурсу требуется авторизация.</li><li>403 Forbidden: сервер понимает запрос, но отказывается выполнять его из-за ограничений на доступ к ресурсу.</li><li>404 Not Found: запрошенный ресурс не найден.</li><li>500 Internal Server Error: внутренняя ошибка сервера.</li></ul></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое cross origin resource sharing? Как устранить проблемы с CORS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Cross-Origin Resource Sharing (CORS) - это механизм, позволяющий веб-страницам запрашивать ресурсы из другого источника, отличного от текущего домена. Этот механизм применяется для обеспечения безопасности веб-приложений и предотвращения атак, таких как Cross-Site Request Forgery (CSRF).</p><p>Когда веб-страница запрашивает ресурсы из другого домена, браузер отправляет HTTP-запрос на этот домен. Если сервер на другом домене не настроен для обработки таких запросов, браузер не разрешит получение ответа из-за политик Same-Origin. CORS позволяет серверу на другом домене явно разрешать запросы с определенных источников, устанавливая заголовок Access-Control-Allow-Origin.</p><p>Чтобы устранить проблемы с CORS, можно предпринять следующие шаги:</p><ol><li><p>Настроить сервер на другом домене, чтобы он отправлял заголовок Access-Control-Allow-Origin, разрешающий запросы с домена, на котором запущен клиентский код.</p></li><li><p>Использовать JSONP (JSON with Padding) вместо обычных AJAX-запросов, если сервер не может быть настроен для CORS. JSONP позволяет получать данные с другого домена, обертывая ответ в функцию JavaScript.</p></li><li><p>Использовать прокси-сервер, который будет работать на том же домене, что и клиентский код, и перенаправлять запросы на сервер на другом домене. Такой прокси-сервер может обрабатывать запросы от клиента и отправлять их на другой домен, а затем отправлять ответ от сервера обратно клиенту.</p></li><li><p>Использовать CORS-библиотеки, которые могут обеспечивать безопасный доступ к API, например, CORS Anywhere или cors-lite.</p></li></ol><p>В целом, решение проблем с CORS зависит от специфики вашего приложения и серверной архитектуры, но настройка сервера для поддержки CORS-запросов является наиболее распространенным подходом.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Расскажи подробнее о jsonp</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JSONP (JSON with Padding) - это метод, который позволяет получать данные с другого домена при использовании JavaScript веб-приложений, обходя ограничения Same-Origin Policy. Он работает путем добавления тега скрипта на страницу и передачи параметров в качестве запроса.</p><p>Когда вы делаете AJAX-запрос на другой домен, браузер блокирует ответ из-за политики Same-Origin Policy. Вместо этого, вы можете сделать запрос на другой домен, передавая название функции в качестве параметра запроса, и сервер будет обернуть ответ в эту функцию.</p><p>Вот пример запроса с JSONP:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) {
          <span class="hljs-comment">// обрабатываем полученные данные</span>
        }
        
        <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
        script.<span class="hljs-property">src</span> = <span class="hljs-string">'http://example.com/data?callback=handleResponse'</span>;
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script);
        </code></div></div></pre><p>В этом примере мы создаем элемент <code>script</code>, который будет загружать данные с URL-адреса <code>http://example.com/data</code>. Мы также передаем параметр <code>callback=handleResponse</code>, чтобы сервер знал, какую функцию вызывать для обработки ответа.</p><p>Сервер должен вернуть ответ в виде вызова функции <code>handleResponse</code>, обернутой в круглые скобки:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-title function_">handleResponse</span>({<span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>});
        </code></div></div></pre><p>Таким образом, когда сервер вернет ответ, браузер выполнит этот код и вызовет функцию <code>handleResponse</code>, которую мы определили ранее. Функция <code>handleResponse</code> будет иметь доступ к данным, которые были переданы в ответе сервера.</p><p>JSONP может быть полезным, когда вам нужно получить данные с другого домена, который не поддерживает CORS или когда вы работаете со сторонними API, которые используют JSONP в качестве механизма передачи данных. Однако, есть некоторые ограничения, такие как отсутствие поддержки POST-запросов и ограничения на количество данных, которые могут быть переданы. Кроме того, необходимо учитывать потенциальные уязвимости в безопасности, связанные с выполнением удаленного JavaScript-кода на вашей странице, поэтому не рекомендуется использовать JSONP для передачи конфиденциальных данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое cookie?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Cookie (куки) - это небольшие текстовые файлы, которые хранятся на компьютере пользователя веб-браузера. Они используются для сохранения информации о пользователе и его предпочтениях на веб-сайте.</p><p>Куки создаются и хранятся на стороне сервера, но они могут быть прочитаны и использованы браузером при каждом запросе к серверу. Куки могут содержать различную информацию, такую как идентификатор сеанса, языковые настройки, предпочтения пользователя, содержимое корзины покупок и т.д.</p><p>Когда пользователь посещает веб-сайт, сервер отправляет куки в браузер пользователя, который сохраняет их на локальном компьютере. В следующий раз, когда пользователь посещает тот же веб-сайт, браузер отправляет куки на сервер, что позволяет серверу распознать пользователя и предоставить персонализированный контент.</p><p>Некоторые типы куков:</p><ul><li>Session cookies (куки сеанса) - это временные куки, которые хранятся только во время сеанса браузера и удаляются, когда браузер закрывается.</li><li>Persistent cookies (куки постоянные) - это куки, которые сохраняются на компьютере пользователя и используются для сохранения информации о пользователе между сеансами браузера. Они могут оставаться на компьютере пользователя в течение определенного времени, указанного в куки, или до тех пор, пока они не будут удалены пользователем.</li></ul><p>Куки могут быть полезными для улучшения пользовательского опыта, так как они позволяют веб-сайтам запомнить предпочтения пользователя и предоставлять персонализированный контент. Однако, некоторые люди могут не быть комфортными с тем, что их данные используются для этих целей, поэтому веб-сайты должны уведомлять пользователей о том, как они используют куки и предоставлять возможность отказаться от использования куков. Кроме того, некоторые типы куков могут быть использованы в целях отслеживания пользовательской активности, поэтому пользователи должны быть ознакомлены с тем, как их данные используются, и какие данные хранятся в куки.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какой максимальный размер cookie?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Максимальный размер cookie зависит от браузера и настроек сервера. Согласно стандарту RFC 6265, каждый cookie может содержать до 4096 байт (4 килобайта) данных, включая имя, значение и другие параметры, такие как дата истечения срока действия и область действия. Однако, на практике многие браузеры устанавливают ограничение на размер cookie, обычно в диапазоне от 4093 до 8192 байт (4-8 килобайт).</p><p>Также следует учитывать, что браузеры имеют ограничения на общее количество cookie, которые могут быть хранены для одного домена. Общее количество cookie для каждого домена может быть ограничено от 20 до 50, в зависимости от браузера и настроек безопасности.</p><p>Если размер cookie превышает максимальный размер, то сервер может разбить данные на несколько cookie или использовать другой метод хранения информации, такой как localStorage или sessionStorage, в зависимости от требований и возможностей приложения.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Расскажи подробнее о sessionStorage</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>sessionStorage - это механизм хранения данных в браузере, который позволяет сохранять данные в рамках текущей сессии (открытой вкладки браузера), которые могут использоваться веб-приложением в течение этой сессии. Данные сохраняются в формате пар "ключ-значение", подобно тому, как это происходит в localStorage. Однако, sessionStorage имеет несколько отличий от localStorage:</p><ol><li><p>Данные, сохраненные в sessionStorage, доступны только в рамках текущей сессии браузера. Это означает, что если пользователь закроет вкладку или браузер, то данные будут удалены.</p></li><li><p>Данные, сохраненные в sessionStorage, не будут переданы на сервер, когда пользователь отправляет запросы на сервер. Они доступны только на клиентской стороне.</p></li><li><p>Каждая вкладка в браузере имеет свой собственный экземпляр sessionStorage. Это означает, что данные, сохраненные в одной вкладке, не будут доступны в других вкладках.</p></li></ol><p>Пример использования sessionStorage:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Сохранение данных в sessionStorage</span>
    sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'username'</span>, <span class="hljs-string">'John'</span>);
    
    <span class="hljs-comment">// Получение данных из sessionStorage</span>
    <span class="hljs-keyword">const</span> username = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'username'</span>);
    
    <span class="hljs-comment">// Удаление данных из sessionStorage</span>
    sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'username'</span>);
    </code></div></div></pre><p>sessionStorage можно использовать для хранения небольших объемов данных, таких как настройки пользователя, состояние формы, временные данные и т.д. Однако, если требуется хранить большие объемы данных или данные должны быть доступны после перезапуска браузера, то рекомендуется использовать другие механизмы хранения, такие как localStorage или базы данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что означает директива use strict?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Директива "use strict" (строгий режим) - это специальный синтаксис в JavaScript, который позволяет разработчикам писать более безопасный и строгий код, и позволяет браузеру выполнять код более эффективно.</p><p>Когда директива "use strict" добавляется в начало скрипта или функции, то JavaScript движок переключается в режим строгого выполнения. В этом режиме происходит следующее:</p><ol><li><p>Запрещается использовать необъявленные переменные. В режиме "use strict" переменные не могут быть созданы, если они не были предварительно объявлены с помощью ключевых слов var, let или const.</p></li><li><p>Запрещается удаление переменных, функций или аргументов функции.</p></li><li><p>Запрещается использование зарезервированных слов как идентификаторов, например, let, const, class, function, arguments и т.д.</p></li><li><p>Запрещается использовать функции или переменные с одинаковыми именами в одной области видимости.</p></li><li><p>Запрещается использование eval() функции, которая выполняет произвольный код.</p></li><li><p>Запрещается использование with оператора, который создает новую область видимости.</p></li><li><p>Запрещается изменять значения свойств только для чтения (writable: false) и констант.</p></li><li><p>В строгом режиме this имеет значение undefined в функциях, которые вызываются без контекста.</p></li></ol><p>Использование директивы "use strict" помогает избежать ошибок, связанных с неявным созданием глобальных переменных, использованием зарезервированных слов как идентификаторов и других проблем с безопасностью. Она также позволяет браузеру выполнять код более эффективно, что может улучшить производительность приложения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Чем js отличается во время работы на front-end и back-end?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JavaScript является языком программирования, который может использоваться как на стороне клиента (front-end), так и на стороне сервера (back-end).</p><p>Когда JavaScript используется на стороне клиента (front-end), то он выполняется в браузере пользователя и работает с HTML и CSS для создания интерактивных веб-страниц. Он может обращаться к DOM (Document Object Model), чтобы изменять содержимое страницы, обрабатывать пользовательские события, отправлять запросы на сервер и обрабатывать ответы.</p><p>Когда JavaScript используется на стороне сервера (back-end), то он выполняется на сервере и используется для обработки запросов от клиентов и генерации динамических веб-страниц. Например, он может работать с базой данных, обрабатывать данные формы, реализовывать алгоритмы для вычислений, отправлять электронные письма и т.д.</p><p>Важными отличиями между front-end и back-end JavaScript являются:</p><ol><li><p>API: На стороне клиента JavaScript может использовать API браузера, такие как DOM API, AJAX API, Web Storage API и т.д. На стороне сервера JavaScript использует API Node.js, которые позволяют работать с сетью, файловой системой, базами данных и т.д.</p></li><li><p>Библиотеки и фреймворки: На стороне клиента JavaScript часто используется библиотека jQuery, фреймворк Angular, React или Vue.js для разработки веб-приложений. На стороне сервера JavaScript используется фреймворк Express.js для создания веб-приложений, фреймворк Meteor.js для создания реального времени веб-приложений и многие другие.</p></li><li><p>Специфика работы: На стороне клиента JavaScript выполняется в браузере пользователя и может взаимодействовать с пользователем, а на стороне сервера он выполняется на сервере и работает вне контекста браузера.</p></li><li><p>Система файлов: На стороне клиента JavaScript работает с файлами HTML, CSS и JavaScript, которые загружаются в браузер, а на стороне сервера JavaScript работает с файлами и базами данных, хранящихся на сервере.</p></li></ol><p>Несмотря на эти различия, JavaScript остается одним и тем же языком программирования, используемым как на стороне клиента, так и на стороне сервера.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>что такое статическая и динамическая типизация?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Статическая типизация и динамическая типизация - это два разных подхода к управлению типами данных в языках программирования.</p><p>Статическая типизация предполагает, что тип переменной определяется на этапе компиляции программы и не может быть изменен во время выполнения программы. При статической типизации программист должен объявлять типы переменных заранее и следить за их соответствием при работе с ними. В языках программирования со статической типизацией, таких как Java, C++, TypeScript, Swift, Haskell и другие, компилятор может проверять правильность использования типов во время компиляции, что может помочь предотвратить многие ошибки во время выполнения программы.</p><p>Динамическая типизация, наоборот, позволяет переменным изменять свой тип во время выполнения программы. При динамической типизации программист может создавать переменные без указания их типов, и тип переменной будет определяться автоматически во время выполнения программы в зависимости от значения, которое она хранит. В языках программирования с динамической типизацией, таких как JavaScript, Python, Ruby, PHP и другие, компилятор не может проверять правильность использования типов во время компиляции, что может приводить к ошибкам во время выполнения программы.</p><p>Каждый подход имеет свои преимущества и недостатки, и выбор между статической и динамической типизацией зависит от конкретных потребностей проекта и личных предпочтений программиста. Например, статическая типизация может быть полезной при работе с большими проектами с большим количеством разработчиков, где необходимо обеспечить строгую проверку типов во время компиляции. Динамическая типизация может быть полезна при работе с небольшими проектами, где необходима большая гибкость и быстрота разработки.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как клиент взаимодействует  с сервером</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Клиент и сервер - это две стороны взаимодействия в модели клиент-сервер. Клиент - это устройство или приложение, которое запрашивает ресурсы или услуги у сервера, а сервер - это устройство или приложение, которое предоставляет эти ресурсы или услуги.</p><p>Для взаимодействия клиента и сервера используется протокол передачи данных, такой как HTTP, TCP или UDP. Протокол определяет формат сообщений, которые обмениваются клиент и сервер, и правила, по которым они обмениваются этими сообщениями.</p><p>Когда клиент хочет получить ресурс или услугу от сервера, он отправляет запрос серверу. Запрос состоит из метода, URI и заголовков. Метод указывает, что именно клиент хочет сделать с ресурсом на сервере (например, получить его, изменить или удалить), URI указывает, какой ресурс на сервере требуется клиенту, а заголовки могут содержать дополнительную информацию о запросе, например, тип содержимого или информацию об аутентификации.</p><p>Когда сервер получает запрос от клиента, он анализирует его и генерирует ответ. Ответ также состоит из заголовков и содержимого. Заголовки содержат информацию о том, как был обработан запрос (например, успешно или с ошибкой), тип содержимого и другую метаинформацию. Содержимое ответа - это сам запрошенный ресурс или результат выполнения запроса.</p><p>После получения ответа клиент обрабатывает его и отображает пользователю. Если ответ содержит запрошенный ресурс, клиент может отобразить его в браузере или использовать его в своей программе. Если ответ содержит результат выполнения запроса, клиент может обработать его и использовать его в своей программе.</p><p>Взаимодействие клиента и сервера может быть синхронным или асинхронным. В синхронном взаимодействии клиент ожидает ответа от сервера перед тем, как продолжить свою работу. В асинхронном взаимодействии клиент может отправлять запросы на сервер и продолжать свою работу, не ожидая ответа от сервера. Когда ответ будет получен, клиент будет уведомлен об этом и сможет обработать его.</p><p>В целом, взаимодействие клиента и сервера - это процесс обмена сообщениями, где клиент запрашивает ресурсы или услуги у сервера, а сервер предоставляет эти ресурсы или услуги в ответ на запросы клиента. Протокол передачи данных</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое REST?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>REST (Representational State Transfer) - это архитектурный стиль, который определяет правила для создания веб-служб, использующих протокол HTTP для передачи и обмена данными. Он был создан Роем Филдингом в 2000 году.</p><p>Основной принцип REST заключается в использовании ресурсов (например, объектов или коллекций), которые представляют данные, и методов HTTP, которые определяют операции, которые можно выполнить с этими ресурсами. Следуя этому принципу, RESTful-веб-службы предоставляют стандартизированные интерфейсы для доступа к данным, что делает их более гибкими и легкими для использования.</p><p>Основные принципы REST включают в себя:</p><ol><li><p>Клиент-серверная архитектура. Клиент и сервер - это две отдельные части системы, которые взаимодействуют друг с другом через интерфейс, определенный в RESTful-веб-службах.</p></li><li><p>Отсутствие состояния. Сервер не хранит информацию о предыдущих запросах клиента. Каждый запрос рассматривается как новый запрос, и сервер отвечает на него соответствующим образом.</p></li><li><p>Кэширование. Сервер может указывать клиенту, что ответ на запрос может быть кэширован для повторного использования.</p></li><li><p>Единообразный интерфейс. Интерфейс RESTful-веб-служб должен быть единообразным для всех ресурсов и методов, что обеспечивает удобство использования.</p></li><li><p>Слои. Клиент не должен знать о слоях, которые находятся между ним и сервером. Это позволяет изменять или добавлять слои без влияния на клиента.</p></li></ol><p>RESTful-веб-службы позволяют клиентам получать доступ к данным и управлять ими с помощью стандартных методов HTTP, таких как GET, POST, PUT и DELETE. Например, клиент может использовать GET-запрос, чтобы получить информацию о ресурсе, POST-запрос, чтобы создать новый ресурс, PUT-запрос, чтобы обновить существующий ресурс, и DELETE-запрос, чтобы удалить ресурс.</p><p>В целом, RESTful-веб-службы - это стандартизированные интерфейсы для доступа к данным с использованием протокола HTTP. Они позволяют клиентам получать доступ к данным и управлять ими, используя стандартные методы HTTP, что делает их более гибк</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Объясните понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Мутабельность и иммутабельность - это свойства объектов, определяющие возможность изменения их состояния после создания. Мутабельный объект может быть изменен после создания, а иммутабельный - не может быть изменен, после того как его создали.</p><p>В JavaScript простые типы (например, number, string, boolean) являются иммутабельными, то есть нельзя изменить значение простого типа напрямую. Если переменной, содержащей простой тип, присвоить новое значение, то будет создан новый объект, а не изменено старое.</p><p>С другой стороны, составные типы (например, массивы и объекты) являются мутабельными, то есть могут быть изменены после создания. Например, можно добавить или удалить элементы из массива, а также изменить свойства объекта.</p><p>Иммутабельность имеет ряд преимуществ, например, она облегчает отладку и тестирование кода, делает его более безопасным и предсказуемым. Кроме того, иммутабельные структуры данных могут быть использованы для создания функциональных программ и реализации функционального программирования.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как искать ошибки в коде при разработке на JS? </h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При разработке на JavaScript возможны различные ошибки, такие как синтаксические ошибки, ошибки времени выполнения и ошибки логики.</p><p>Одним из способов поиска ошибок является использование отладчика в браузере или интегрированной среды разработки (IDE), такой как Visual Studio Code. Отладчик позволяет пошагово выполнять код и проверять значения переменных на каждом шаге, что может помочь выявить ошибки. Также можно использовать консоль разработчика в браузере для вывода сообщений об ошибках и просмотра значений переменных.</p><p>Другой метод - это написание тестов для кода с использованием фреймворков, таких как Jest или Mocha. Тесты позволяют автоматически проверять код на предмет ошибок и несоответствий ожидаемому поведению.</p><p>Хорошей практикой является также использование линтеров, таких как ESLint или JSLint. Они проверяют код на соответствие стандартам и правилам написания кода, помогают выявлять ошибки и делают код более читабельным.</p><p>Еще один метод - это code review, то есть ревью кода коллегами разработчиками. Они могут заметить ошибки, которые вы можете пропустить, и предложить улучшения в коде.</p><p>В целом, для поиска ошибок в коде на JavaScript необходимо использовать несколько методов и инструментов, чтобы сделать код более надежным и стабильным.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как использовать дебагер?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Дебагер - это инструмент, который помогает разработчикам находить и исправлять ошибки в коде. Для использования дебагера необходимо выполнить следующие шаги:</p><ol><li><p>Открыть в браузере страницу с отладочным кодом и нажать F12, чтобы открыть инструменты разработчика.</p></li><li><p>В разделе "Sources" выбрать файл с отладочным кодом и добавить точки останова в нужных местах кода, нажимая на соответствующие номера строк.</p></li><li><p>Выполнить нужные действия на странице, которые приводят к ошибке. Когда выполнение кода доходит до точки останова, выполнение приостанавливается и появляется возможность просмотреть значения переменных и текущее состояние кода.</p></li><li><p>Использовать панель инструментов дебагера для шага по коду, просмотра значений переменных и выявления ошибок.</p></li><li><p>Если ошибка была обнаружена, исправить ее и перезапустить код, начиная с пункта 2.</p></li></ol><p>Для более эффективного использования дебагера, необходимо обладать знаниями JavaScript и уметь понимать, как код работает. Также рекомендуется изучать документацию по инструментам разработчика, чтобы понимать все возможности и функции дебагера и других инструментов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Каких известных людей из мира JS знаете?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В мире JavaScript есть много известных и влиятельных людей. Некоторые из них:</p><ol><li><p>Brendan Eich - создатель JavaScript, сооснователь Mozilla, Brave Software.</p></li><li><p>Douglas Crockford - разработчик, который создал JSON, автор книги "JavaScript: The Good Parts".</p></li><li><p>Addy Osmani - инженер Google, который работает над инструментами разработки веб-приложений, автор книги "Learning JavaScript Design Patterns".</p></li><li><p>Kyle Simpson - автор книг "You Don't Know JS", разработчик, участник сообщества JavaScript.</p></li><li><p>Dan Abramov - разработчик Facebook, создатель Redux и React Hot Loader.</p></li><li><p>John Resig - создатель библиотеки jQuery.</p></li><li><p>Wes Bos - автор курсов по JavaScript и разработке веб-приложений.</p></li></ol><p>Это далеко не полный список известных людей из мира JavaScript, но они внесли значительный вклад в развитие этого языка программирования.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие существуют типы данных в JS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько типов данных. Они могут быть примитивными и объектными.</p><ol><li><p>Примитивные типы данных:</p><ul><li>Числа (number) - целые числа и числа с плавающей точкой.</li><li>Строки (string) - последовательность символов в кавычках.</li><li>Булевы значения (boolean) - true и false.</li><li>undefined - используется для неинициализированных переменных.</li><li>null - используется для представления отсутствия значения.</li><li>Symbol - уникальный и неизменяемый тип данных, добавленный в ECMAScript 6.</li></ul></li><li><p>Объектные типы данных:</p><ul><li>Объекты (object) - набор свойств и методов, представленных в фигурных скобках {}.</li><li>Функции (function) - объекты, которые могут быть вызваны.</li><li>Массивы (array) - упорядоченные списки элементов.</li><li>Дата (date) - объекты, которые представляют дату и время.</li><li>Регулярные выражения (regexp) - объекты, используемые для сопоставления текста с шаблоном.</li></ul></li></ol><p>Также в JavaScript есть понятие "динамической типизации". Это означает, что тип переменной определяется во время выполнения программы, а не во время компиляции. Это позволяет гибко работать с типами данных и упрощает разработку программ. Однако, это также может приводить к ошибкам в программе, связанным с неправильным использованием типов данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Сколько типов данных в JavaScript ?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><b>7</b><ol><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Symbol</li><li>Object</li></ol><p>В JavaScript существует несколько типов данных. Они могут быть примитивными и объектными.</p><ol><li><p>Примитивные типы данных:</p><ul><li>Числа (number) - целые числа и числа с плавающей точкой.</li><li>Строки (string) - последовательность символов в кавычках.</li><li>Булевы значения (boolean) - true и false.</li><li>undefined - используется для неинициализированных переменных.</li><li>null - используется для представления отсутствия значения.</li><li>Symbol - уникальный и неизменяемый тип данных, добавленный в ECMAScript 6.</li></ul></li><li><p>Объектные типы данных:</p><ul><li>Объекты (object) - набор свойств и методов, представленных в фигурных скобках {}.</li><li>Функции (function) - объекты, которые могут быть вызваны.</li><li>Массивы (array) - упорядоченные списки элементов.</li><li>Дата (date) - объекты, которые представляют дату и время.</li><li>Регулярные выражения (regexp) - объекты, используемые для сопоставления текста с шаблоном.</li></ul></li></ol><p>Также в JavaScript есть понятие "динамической типизации". Это означает, что тип переменной определяется во время выполнения программы, а не в</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, является ли объект массивом?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько способов проверки, является ли объект массивом:</p><ol><li><p>Метод Array.isArray():
    Этот метод возвращает true, если переданный аргумент является массивом, и false в противном случае.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li><li><p>Свойство instanceof:
    Это свойство проверяет, является ли объект экземпляром указанного конструктора (в данном случае, Array).</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li><li><p>Проверка свойства constructor:
    Все объекты в JavaScript имеют свойство constructor, которое ссылается на конструктор, используемый для создания объекта. Массивы в JavaScript создаются с использованием конструктора Array. Поэтому можно проверить, совпадает ли свойство constructor объекта с конструктором Array.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, является ли число конечным?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript для проверки, является ли число конечным, можно использовать метод <code>isFinite()</code>.</p><p>Синтаксис метода <code>isFinite()</code>:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>scss</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-scss"><span class="hljs-built_in">isFinite</span>(number)
    </code></div></div></pre><p>где <code>number</code> - это число, которое необходимо проверить.</p><p>Метод <code>isFinite()</code> возвращает <code>true</code>, если переданное значение является конечным числом, и <code>false</code>, если это значение является бесконечностью (<code>Infinity</code> или <code>-Infinity</code>) или не является числом.</p><p>Примеры:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">1.23e1000</span>)); <span class="hljs-comment">// false (число слишком большое для JavaScript)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>)); <span class="hljs-comment">// false</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-string">"42"</span>)); <span class="hljs-comment">// true (строка будет автоматически преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-string">"Hello"</span>)); <span class="hljs-comment">// false (строка не может быть преобразована в число)</span>
    </code></div></div></pre><p>Также стоит учитывать, что метод <code>isFinite()</code> преобразует переданное значение в число, если это возможно, поэтому при передаче значения, которое не может быть преобразовано в число, метод вернет <code>false</code>.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, что переменная равна NaN?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript для проверки, что переменная равна NaN (Not a Number), необходимо использовать функцию <code>isNaN()</code>.</p><p>Функция <code>isNaN()</code> принимает один аргумент и возвращает <code>true</code>, если переданный аргумент не является числом (NaN), и <code>false</code>, если аргумент является числом.</p><p>Примеры использования:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// false</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"42"</span>)); <span class="hljs-comment">// false (строка будет преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"Hello"</span>)); <span class="hljs-comment">// true (строка не может быть преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// true</span>
    </code></div></div></pre><p>Также стоит учитывать, что функция <code>isNaN()</code> может приводить к неожиданным результатам при использовании с определенными типами данных, такими как объекты, массивы и булевы значения, поэтому рекомендуется использовать эту функцию только для проверки, является ли значение NaN или нет. Если необходимо проверить, является ли значение числом, рекомендуется использовать функцию <code>Number.isNaN()</code> вместо <code>isNaN()</code>.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Сравните ключевые слова var, let, const</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ключевое слово var используется для объявления переменных в старой версии JavaScript, которая поддерживается всеми браузерами. Однако, оно имеет некоторые проблемы, связанные с областью видимости переменных.</p><p>Ключевые слова let и const были добавлены в новых версиях JavaScript для решения проблем, связанных с областью видимости переменных. Переменные, объявленные с помощью let и const, имеют блочную область видимости и не могут быть переобъявлены в том же блоке.</p><p>Ключевое слово let используется для объявления переменных со значением, которое может изменяться. Ключевое слово const используется для объявления переменных со значением, которое не может быть изменено. При попытке изменить значение const переменной будет выброшено исключение.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое область видимости?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Область видимости - это область, где определенный идентификатор (например, переменная, функция) может быть использован. В JavaScript область видимости может быть глобальной или локальной.</p><p>Глобальная область видимости - это область видимости, доступная в любом месте в программе. Переменные, определенные в глобальной области видимости, могут быть использованы в любом месте программы.</p><p>Локальная область видимости - это область видимости, которая определена внутри функции. Переменные, определенные в локальной области видимости, не могут быть использованы вне функции.</p><p>JavaScript также имеет блочную область видимости с помощью ключевых слов let и const, которые позволяют определять переменные в области видимости блока. Переменные, определенные с помощью let и const, не могут быть использованы вне блока, в котором они были определены.</p><p>Область видимости имеет значение при работе с переменными и функциями, поскольку это позволяет контролировать доступность их использования в разных частях программы.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое деструктуризация?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Деструктуризация — это способ извлечения значений из массивов или объектов и присвоения их локальным переменным. Она позволяет удобно и компактно извлекать только нужные значения из структуры данных и использовать их далее в коде.</p><p>Для деструктуризации массива можно использовать квадратные скобки, а для объекта — фигурные скобки. В квадратных скобках указываются переменные, которые будут присвоены значениям из массива, а в фигурных — имена переменных, которые будут присвоены значениям из объекта. Если нужно присвоить значение по умолчанию, то оно указывается после знака равенства.</p><p>Пример деструктуризации массива:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>arduino</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-arduino"><span class="hljs-type">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-type">const</span> [a, b, c] = arr;
    console.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 1</span>
    console.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 2</span>
    console.<span class="hljs-built_in">log</span>(c); <span class="hljs-comment">// 3</span>
    </code></div></div></pre><p>Пример деструктуризации объекта:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>arduino</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-arduino"><span class="hljs-type">const</span> obj = {name: <span class="hljs-string">'John'</span>, age: <span class="hljs-number">30</span>};
    <span class="hljs-type">const</span> {name, age} = obj;
    console.<span class="hljs-built_in">log</span>(name); <span class="hljs-comment">// 'John'</span>
    console.<span class="hljs-built_in">log</span>(age); <span class="hljs-comment">// 30</span>
    </code></div></div></pre><p>Также можно использовать деструктуризацию с параметрами функций, чтобы извлечь значения из объектов, переданных в качестве аргументов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Для чего предназначены методы setTimeout и setInterval?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Методы <code>setTimeout</code> и <code>setInterval</code> в JavaScript используются для отложенного выполнения функций.</p><p>Метод <code>setTimeout</code> позволяет задержать выполнение функции на определенный промежуток времени, который указывается в миллисекундах в качестве второго параметра. Первым параметром передается функция, которая должна быть выполнена после задержки.</p><p>Синтаксис:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>, delay)
    </code></div></div></pre><p>Метод <code>setInterval</code> также позволяет задержать выполнение функции, но в отличие от <code>setTimeout</code>, функция будет вызываться периодически через определенные промежутки времени, указанные вторым параметром.</p><p>Синтаксис:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>, delay)
    </code></div></div></pre><p>Оба метода возвращают идентификатор таймера, который может быть использован для остановки таймера путем вызова метода <code>clearTimeout</code> или <code>clearInterval</code>, соответственно.</p><p>Таким образом, <code>setTimeout</code> и <code>setInterval</code> позволяют отложить или периодически вызвать функцию после определенного промежутка времени, что может быть полезно при реализации анимации, обновлении данных и других подобных задач.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs async/await.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько подходов для работы с асинхронным кодом: callbacks, promises и async/await.</p><p>Callbacks - это функции, которые передаются как аргументы в другие функции и вызываются после выполнения определенного действия, например, завершения выполнения запроса к серверу. Однако использование большого количества вложенных callbacks может привести к так называемому "аду колбэков" (callback hell), что делает код сложным и трудночитаемым.</p><p>Promises представляют собой более удобный способ работы с асинхронным кодом, который позволяет избежать "ада колбэков". Promise - это объект, который может находиться в одном из трех состояний: ожидание (pending), выполнено (fulfilled) или отклонено (rejected). При создании Promise-объекта передается функция-исполнитель (executor), которая может вызвать методы resolve и reject для изменения состояния Promise. Затем можно привязать колбэки с помощью методов then, catch и finally, которые будут вызываться в зависимости от результата выполнения Promise.</p><p>Async/await - это более новый подход к работе с асинхронным кодом, который основан на Promise. Он позволяет использовать синтаксис синхронного кода для написания асинхронного кода. Функция, помеченная ключевым словом async, возвращает Promise, и может содержать несколько ключевых слов await, которые приостанавливают выполнение функции, пока Promise не выполнится или не отклонится. Однако, не все браузеры и окружения поддерживают async/await, поэтому в некоторых случаях может потребоваться использование библиотеки, которая предоставляет полифилл для async/await.</p><p>Каждый из этих подходов имеет свои преимущества и недостатки, и выбор зависит от конкретной задачи и предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Можно ли записывать новые свойства/функции в прототипы стандартных классов (Array, Object и т.п.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, можно записывать новые свойства/функции в прототипы стандартных классов, но это не рекомендуется делать, так как это может привести к непредсказуемому поведению кода и конфликтам при работе с библиотеками или другими разработчиками.</p><p>Расширять прототип можно в случаях, когда требуется добавить новые методы, которые будут использоваться только внутри конкретного приложения и не будут конфликтовать с уже существующими методами.</p><p>Чтобы обезопасить себя, если нужно расширять прототип, можно использовать следующий подход:</p><ol><li><p>Создать новый класс, который будет наследовать стандартный класс (например, создать свой класс Array, который будет наследовать стандартный Array).</p></li><li><p>Расширить прототип своего нового класса, добавив в него новые методы.</p></li><li><p>Использовать свой новый класс вместо стандартного класса.</p></li></ol><p>Такой подход позволит расширять функциональность стандартных классов без риска конфликтов и непредсказуемого поведения кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Назовите методы массивов, которые помните, и скажите, для чего они нужны.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>map - возвращает новый массив с результатами вызова функции для каждого элемента массива.
    filter - возвращает новый массив, содержащий все элементы, для которых вызов функции возвращает true.
    reduce - применяет функцию к каждому элементу массива и накапливает результаты в одно значение.
    forEach - вызывает функцию для каждого элемента массива.
    sort - сортирует элементы массива.
    indexOf - возвращает индекс первого найденного элемента в массиве.
    slice - возвращает новый массив, содержащий копию части исходного массива.
    push - добавляет один или несколько элементов в конец массива.
    pop - удаляет последний элемент массива.</p>
    <ul>
    <li>find() - возвращает первый элемент массива, удовлетворяющий заданному условию в функции-аргументе.</li>
    <li>includes() - проверяет, содержит ли массив заданный элемент, и возвращает true или false.</li>
    <li>fill() - заполняет все элементы массива одним значением, начиная с указанного индекса и заканчивая другим индексом (опционально).</li>
    <li>flat() - создает новый массив, в котором все подмассивы внутри исходного массива "выравниваются" до указанной глубины.</li>
    <li>some() - проверяет, удовлетворяет ли хотя бы один элемент массива заданному условию в функции-аргументе, и возвращает true или false.</li>
    <li>every() - проверяет, удовлетворяют ли все элементы массива заданному условию в функции-аргументе, и возвращает true или false.</li></ul>
    <li>splice(): изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые элементы.</li>
    <li>map(): создает новый массив с результатами вызова указанной функции для каждого элемента массива.</li>
    </ul></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Как работают операторы присвоения/ сравнения/ строковые/ арифметические/ битовые и т.п.?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Операторы в JavaScript предназначены для выполнения различных операций над значениями и переменными.</p><p>Оператор присвоения (=) используется для присваивания значения правой части выражения левой переменной.</p><p>Операторы сравнения (==, ===, !=, !==, &gt;, &gt;=, &lt;, &lt;=) используются для сравнения значений и типов данных. Оператор == выполняет нестрогое равенство, приводя типы данных при необходимости, а оператор === выполняет строгое равенство без приведения типов. Операторы сравнения возвращают логическое значение true или false.</p><p>Операторы арифметических действий (+, -, *, /, %) используются для выполнения математических операций над числами. Оператор % возвращает остаток от деления.</p><p>Операторы строковых операций (+) используются для конкатенации строк.</p><p>Операторы битовых операций (&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;) используются для выполнения операций над двоичными числами.</p><p>При использовании операторов необходимо учитывать приоритет операций и правила выполнения выражений, например, выражения в скобках выполняются в первую очередь. Также стоит учитывать особенности работы операторов со значениями различных типов, например, при сложении числа и строки происходит конкатенация строк.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>в какую сторону работают операторы если оепраторов несколько?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Если в выражении используется несколько операторов с одинаковым приоритетом, то они выполняются слева направо, за исключением операторов присваивания, которые выполняются справа налево. Если в выражении используются операторы с разным приоритетом, то операторы с более высоким приоритетом выполняются раньше. Если порядок вычислений необходимо изменить, можно использовать скобки.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Опишите назначение и принципы работы с коллекциями Map и Set</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Map и Set являются коллекциями в JavaScript, которые позволяют хранить уникальные значения. Map представляет собой коллекцию пар ключ-значение, в то время как Set хранит только уникальные значения.</p><p>Принцип работы с Map заключается в том, что каждый элемент коллекции имеет уникальный ключ, который используется для получения значения элемента. Принцип работы с Set заключается в том, что каждый элемент коллекции уникален, и вы можете проверять наличие элемента в Set с помощью метода has(). Обе коллекции также предоставляют методы для добавления, удаления и получения элементов.</p><p>Основное назначение Map и Set заключается в том, чтобы предоставить эффективный способ хранения данных и выполнения операций с ними. Они часто используются в приложениях, которые требуют быстрого доступа к данным, таких как поисковые системы и базы данных.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Глубокая (deep) копия объекта создает копию объекта и всех его вложенных объектов, тогда как поверхностная (shallow) копия копирует только ссылки на вложенные объекты. При изменении вложенных объектов в глубокой копии оригинал остается неизменным, в то время как в поверхностной копии изменения будут отражены и в оригинальном объекте.</p><p>Для создания поверхностной копии объекта можно использовать метод <code>Object.assign()</code>, который создает новый объект, содержащий все свойства исходного объекта. Для создания глубокой копии объекта нужно рекурсивно скопировать все его свойства и свойства вложенных объектов.</p><p>Например, чтобы создать глубокую копию объекта <code>obj</code>, можно использовать следующую функцию:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">"object"</span>) {
          <span class="hljs-keyword">return</span> obj;
        }
        <span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
          copy[key] = <span class="hljs-title function_">deepCopy</span>(obj[key]);
        }
        <span class="hljs-keyword">return</span> copy;
      }
      </code></div></div></pre><p>Для создания поверхностной копии объекта <code>obj</code> можно использовать следующий код:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> shallowCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);
      </code></div></div></pre></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между декларацией функции и функциональным выражением заключается в способе определения функции и времени доступности.</p><p>Декларация функции (function declaration) определяет функцию внутри блока кода и делает ее доступной во всей области видимости блока. Функцию можно вызывать до ее определения в коде, так как она поднимается (hoisted) в начало блока.</p><p>Функциональное выражение (function expression) определяет функцию как часть выражения и присваивает ее переменной. Функция становится доступной только после выполнения строки кода, в которой она была определена.</p><p>Например, декларация функции выглядит так:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      }
      </code></div></div></pre><p>А функциональное выражение так:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      };
      </code></div></div></pre><p>Выбор между декларацией функции и функциональным выражением зависит от контекста использования и предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое анонимная функция?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Анонимная функция в JavaScript - это функция, которая не имеет имени и может быть определена как выражение или передана как аргумент в другую функцию. Она не обязательно должна быть присвоена переменной или объявлена как отдельная функция.</p><p>Пример анонимной функции в виде выражения:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> greeting = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      };
      </code></div></div></pre><p>Анонимные функции часто используются в качестве обратных вызовов (callbacks) при передаче функции в качестве аргумента другой функции, например:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Delayed message"</span>);
      }, <span class="hljs-number">1000</span>);
      </code></div></div></pre><p>Также анонимные функции могут быть определены непосредственно при выполнении кода:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"IIFE - Immediately Invoked Function Expression"</span>);
      })();
      </code></div></div></pre><p>Анонимные функции полезны, когда требуется определить функцию в конкретном контексте, избегая создания отдельного идентификатора для функции, которая используется только один раз.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Расскажите о стрелковых функциях (arrow function). В чем заключаются отличия стрелковых функций от обычных?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Стрелковые функции (arrow functions) в JavaScript представляют сокращенный синтаксис для определения функций. Они имеют некоторые отличия от обычных (анонимных) функций:</p><ol><li><p>Стрелковые функции не имеют своего собственного контекста выполнения (<code>this</code>). Они используют лексическое окружение для определения значения <code>this</code>, которое наследуется от родительского контекста. В обычных функциях <code>this</code> определяется во время выполнения функции и может меняться.</p></li><li><p>Стрелковые функции не имеют своего собственного ключевого слова <code>arguments</code> для доступа к аргументам функции. Вместо этого можно использовать спред-оператор <code>...args</code> для получения всех аргументов.</p></li><li><p>Стрелковые функции всегда анонимны, то есть они не имеют имени и не могут быть использованы в качестве конструкторов для создания объектов.</p></li><li><p>Стрелковые функции могут быть более компактными, особенно при отсутствии необходимости в большом теле функции или при использовании одного выражения.</p></li></ol><p>Пример стрелковой функции:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;
    </code></div></div></pre><p>В общем, стрелковые функции предоставляют более краткий и удобный синтаксис для определения функций, особенно при работе с простыми выражениями и избегании проблем, связанных с контекстом <code>this</code>.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>IIFE (Immediately Invoked Function Expression) - это выражение функции, которое вызывается немедленно после своего определения. Оно используется для создания локальной области видимости и изоляции переменных от глобальной области видимости.</p><p>Преимущества использования IIFE:</p><ol><li><p>Изоляция переменных: IIFE создает свою собственную область видимости, что позволяет объявлять переменные, не засоряя глобальную область видимости. Это помогает предотвратить конфликты и неожиданное переопределение переменных.</p></li><li><p>Защита данных: Поскольку переменные, объявленные внутри IIFE, недоступны извне, это позволяет сохранять данные в приватной области видимости и предотвращает их нежелательное изменение.</p></li><li><p>Модульность: IIFE используется для создания модульного кода. Он может содержать логику, функции и переменные, связанные с конкретным модулем, и предоставлять только необходимые интерфейсы для взаимодействия с внешним кодом.</p></li></ol><p>Пример IIFE:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// Код внутри IIFE</span>
      })();
      </code></div></div></pre><p>IIFE можно использовать для выполнения определенной инициализации, настройки или выполнения кода в момент загрузки скрипта, а также для создания самовызывающихся функций, которые выполняются только один раз при загрузке страницы.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое hoisting, как он работает для переменных и функций?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Hoisting (поднятие) в JavaScript означает, что объявления переменных и функций перемещаются в начало их области видимости во время компиляции, независимо от их фактического расположения в коде. Это позволяет использовать переменные и функции до их объявления.</p><p>Для переменных:
    При hoisting переменные объявлены с помощью ключевых слов <code>var</code> или <code>let</code> перемещаются в начало своей области видимости. Однако, само присваивание значения переменной остается на момент, где оно было выполнено.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// undefined</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
    </code></div></div></pre><p>Для функций:
    При hoisting функции, объявленные с помощью ключевого слова <code>function</code>, перемещаются в начало своей области видимости, поэтому их можно вызывать до их фактического объявления.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// "Hello"</span>
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
    </code></div></div></pre><p>Однако, стрелковые функции (arrow functions) не подвержены hoisting, так как они являются выражениями и не имеют своего собственного объявления.</p><p>Важно отметить, что hoisting применяется только к объявлениям переменных и функций, а не к их инициализации или присваиванию значений. Поэтому рекомендуется всегда объявлять переменные и функции перед их использованием, чтобы избежать путаницы и неожиданного поведения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое замыкание (closure) и какие сценарии его использования?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Замыкание (closure) в JavaScript - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Оно позволяет функции запоминать и иметь доступ к переменным из своего лексического окружения, даже после того, как это окружение было завершено.</p><p>Замыкания особенно полезны в следующих сценариях:</p><ol><li><p>Использование приватных переменных: Замыкания позволяют создавать переменные, недоступные извне функции, и сохранять их состояние между вызовами функции.</p></li><li><p>Работа с функциями обратного вызова (callbacks): Замыкания позволяют передавать функции обратного вызова с доступом к локальным переменным функции-родителя, что делает код более гибким и модульным.</p></li><li><p>Создание модульного кода: Замыкания позволяют создавать модули, скрывая детали реализации и предоставляя только необходимые интерфейсы.</p></li><li><p>Создание задержек и асинхронных операций: Замыкания могут использоваться для создания задержек с доступом к локальным переменным их окружения.</p></li></ol><p>Пример использования замыкания:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
      
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
          count++;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);
        };
      }
      
      <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
      <span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span>
      <span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span>
      </code></div></div></pre><p>Здесь функция <code>createCounter</code> создает и возвращает замыкание, которое имеет доступ к переменной <code>count</code> даже после завершения выполнения <code>createCounter</code>. Это позволяет создать счетчик с сохранением состояния между вызовами.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое рекурсия?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Рекурсия - это процесс, когда функция вызывает саму себя в своем теле. Когда функция вызывается рекурсивно, новые экземпляры функции создаются и выполняются с новыми наборами аргументов. Рекурсия обычно используется для решения задач, которые могут быть разбиты на более простые подзадачи.</p><p>Пример простой рекурсивной функции - вычисление факториала:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) {
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);
        }
      }
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>
      </code></div></div></pre><p>В этом примере функция <code>factorial</code> вызывает саму себя с аргументом <code>n - 1</code> до тех пор, пока не достигнет базового случая, когда <code>n</code> равно 0. Затем функция начинает возвращать результаты, возвращая умножение <code>n</code> на результат рекурсивного вызова. Рекурсия позволяет нам выразить сложные задачи в терминах более простых подзадач, упрощая их решение. Однако необходимо быть осторожным, чтобы избежать бесконечной рекурсии и убедиться в наличии условия выхода из рекурсии.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что означает ключевое слово this?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ключевое слово <code>this</code> в JavaScript используется для обращения к текущему объекту, в контексте которого выполняется код. Значение <code>this</code> определяется во время выполнения и зависит от того, как вызывается функция.</p><ol><li><p>В методах объекта: <code>this</code> ссылается на сам объект, в котором определен метод. Используется для доступа к свойствам и методам объекта.</p></li><li><p>В глобальной области видимости или в функциях: <code>this</code> ссылается на глобальный объект (например, <code>window</code> в браузере или <code>global</code> в Node.js). Если в строгом режиме (<code>"use strict"</code>) - <code>this</code> будет <code>undefined</code>.</p></li><li><p>В конструкторах: <code>this</code> ссылается на создаваемый экземпляр объекта. Когда функция вызывается с использованием оператора <code>new</code>, <code>this</code> будет указывать на новый объект.</p></li><li><p>При использовании <code>call</code>, <code>apply</code> или <code>bind</code>: <code>this</code> можно явно привязать к определенному объекту.</p></li><li><p>В обработчиках событий: <code>this</code> ссылается на элемент DOM, на котором произошло событие.</p></li></ol><p>Значение <code>this</code> может быть изменено с помощью различных методов, поэтому его значение следует тщательно учитывать при написании кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое потеря контекста, когда происходит и как ее предотвратить?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Потеря контекста в JavaScript происходит, когда функция теряет доступ к своему ожидаемому значению <code>this</code>. Это может произойти при передаче функции по отдельности без контекста, использовании колбэков, применении функций высшего порядка или при вызове функции внутри другой функции.</p><p>Чтобы предотвратить потерю контекста, можно использовать следующие подходы:</p><ol><li><p>Использование стрелочных функций: Стрелочные функции не создают собственного контекста <code>this</code> и наследуют его от родительской области видимости.</p></li><li><p>Привязка контекста с помощью методов <code>bind</code>, <code>call</code> или <code>apply</code>: Эти методы позволяют явно привязать значение <code>this</code> к функции.</p></li><li><p>Использование замыканий: Создание замыкания, в котором сохраняется доступ к нужному контексту, позволяет избежать потери контекста.</p></li><li><p>Использование строго режима (<code>"use strict"</code>): Строгий режим изменяет поведение <code>this</code>, делая его <code>undefined</code> вместо глобального объекта, что помогает выявить потенциальные ошибки.</p></li><li><p>Использование синтаксиса ES6 классов: Классы в JavaScript автоматически привязывают методы к контексту экземпляра класса.</p></li></ol><p>Выбор определенного подхода зависит от конкретной ситуации и требований вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Методы функций bind / call / apply — зачем и в чем разница?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Методы <code>bind</code>, <code>call</code> и <code>apply</code> в JavaScript используются для управления контекстом выполнения функции и передачи аргументов.</p><ul><li><p><code>bind</code>: Создает новую функцию с привязанным контекстом (значением <code>this</code>), которая может быть вызвана позже. Возвращает функцию.</p></li><li><p><code>call</code>: Вызывает функцию, указывая конкретный контекст (значение <code>this</code>) и передавая аргументы в виде списка через запятую. Выполняет функцию немедленно.</p></li><li><p><code>apply</code>: Вызывает функцию, указывая конкретный контекст (значение <code>this</code>) и передавая аргументы в виде массива. Выполняет функцию немедленно.</p></li></ul><p>Основная разница между <code>call</code> и <code>apply</code> заключается в том, как аргументы передаются функции. <code>call</code> принимает аргументы в виде списка, в то время как <code>apply</code> принимает аргументы в виде массива.</p><p>Эти методы полезны, когда нужно вызвать функцию с определенным контекстом или передать аргументы, которые не известны заранее. Например, они часто используются для вызова методов других объектов с определенным контекстом или для использования методов с неизвестным количеством аргументов.</p><p>Применение конкретного метода зависит от контекста и требований вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое DOM?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>DOM (Document Object Model) - это представление HTML- или XML-документа в виде дерева объектов, которое браузер использует для представления веб-страницы. DOM предоставляет программный интерфейс для доступа и изменения элементов, атрибутов и содержимого документа.</p><p>DOM представляет каждый элемент HTML или XML-документа в виде объекта, который имеет свои свойства и методы. Эти объекты объединены в иерархическую структуру, где каждый элемент является дочерним или родительским относительно других элементов. Таким образом, DOM позволяет программистам манипулировать структурой, стилями и содержимым веб-страницы с помощью JavaScript.</p><p>С использованием DOM можно создавать, удалять и изменять элементы, атрибуты, текст и стили на веб-странице. Также можно прослушивать события, выполнять валидацию данных и многое другое.</p><p>DOM является основой для работы с динамическим содержимым и взаимодействием с веб-страницей при разработке на фронтенде с использованием JavaScript.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Сравните атрибуты подключения скрипта async и defer в HTML-документ</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Атрибуты <code>async</code> и <code>defer</code> используются для управления асинхронной загрузкой скриптов в HTML-документе.</p><ul><li><p><code>async</code>: Скрипт будет выполняться асинхронно во время загрузки страницы. Это означает, что он не блокирует парсинг HTML-документа и не останавливает загрузку других элементов страницы. Скрипт выполнится как только загрузится, и порядок выполнения скриптов может быть непредсказуемым. Рекомендуется использовать <code>async</code> для скриптов, которые не зависят от других скриптов и не требуют доступа к DOM-элементам при загрузке.</p></li><li><p><code>defer</code>: Скрипт будет выполняться после того, как HTML-документ будет полностью загружен, но перед событием <code>DOMContentLoaded</code>. Скрипты с атрибутом <code>defer</code> сохраняют порядок выполнения относительно друг друга. Их выполнение происходит после парсинга HTML, но до завершения построения DOM-дерева. Рекомендуется использовать <code>defer</code> для скриптов, которые зависят от DOM-структуры и требуют доступа к DOM-элементам.</p></li></ul><p>Оба атрибута полезны для ускорения загрузки страницы и улучшения производительности. Выбор между <code>async</code> и <code>defer</code> зависит от того, какой момент выполнения скрипта является критическим для вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какая разница между свойствами HTML-элементов innerHTML и innerText?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между свойствами <code>innerHTML</code> и <code>innerText</code> заключается в том, как они обрабатывают содержимое HTML-элементов.</p><ul><li><p><code>innerHTML</code>: Свойство <code>innerHTML</code> возвращает или устанавливает HTML-код внутри элемента, включая все его потомки. Это позволяет добавлять, изменять или удалять HTML-структуры и элементы внутри выбранного элемента. Оно также позволяет внедрять JavaScript-код и стили внутри элемента.</p></li><li><p><code>innerText</code>: Свойство <code>innerText</code> возвращает или устанавливает текстовое содержимое элемента без учета HTML-тегов. Оно игнорирует все HTML-структуры и элементы внутри элемента и возвращает только видимый текст. При установке значения <code>innerText</code> все HTML-теги будут отброшены, а вместо них будет установлен чистый текст.</p></li></ul><p>Если вам нужно работать с HTML-структурами, добавлять или изменять элементы, используйте <code>innerHTML</code>. Если вам нужно получить только текстовое содержимое элемента без учета HTML-тегов, используйте <code>innerText</code>. Оба свойства полезны в различных сценариях, и выбор зависит от требований вашего приложения или задачи.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Опишите процесс всплытия (bubbling) событий в DOM</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Всплытие событий (bubbling) в DOM — это процесс, при котором событие, вызванное на определенном элементе, распространяется вверх по иерархии его родительских элементов.</p><p>Когда событие происходит на вложенном элементе, оно сначала обрабатывается на самом вложенном элементе, затем переходит к его родителю, затем к родителю родителя и так далее, пока не достигнет корневого элемента (обычно это <code>document</code>).</p><p>Этот механизм позволяет обрабатывать события на разных уровнях иерархии элементов. Например, если у вас есть кнопка внутри блока, и оба элемента имеют обработчики события клика, сначала будет вызван обработчик события на кнопке, а затем обработчик на блоке.</p><p>Всплытие событий можно прервать с помощью метода <code>event.stopPropagation()</code>. Это предотвращает дальнейшее распространение события вверх по иерархии элементов.</p><p>Всплытие событий полезно, когда требуется обрабатывать события на разных уровнях вложенности элементов и использовать делегирование событий для эффективной обработки множества элементов с одним и тем же типом события.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как остановить дефолтную обработку события?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для остановки дефолтной обработки события в JavaScript можно использовать метод <code>event.preventDefault()</code>. Этот метод вызывается в обработчике события и предотвращает выполнение стандартного действия, связанного с событием.</p><p>Например, если у вас есть ссылка (<code>&lt;a&gt;</code> элемент) и вы хотите отменить переход по этой ссылке при клике на нее, вы можете добавить обработчик события и вызвать <code>event.preventDefault()</code>. Это предотвратит переход по ссылке и позволит вам выполнить свою кастомную логику в обработчике события.</p><p>Метод <code>event.preventDefault()</code> работает для различных типов событий, таких как клик, отправка формы, нажатие клавиши и другие. Он является мощным инструментом для контроля над поведением событий и позволяет предотвратить стандартные действия браузера, пока вы выполняете свою специфическую обработку события.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое LocalStorage и SessionStorage? Каков максимальный размер LocalStorage?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>LocalStorage и SessionStorage - это механизмы хранения данных в веб-браузере.</p><p>LocalStorage - это персистентное хранилище данных, которое сохраняет данные после закрытия браузера и доступно для использования в любой вкладке или окне браузера. Данные в LocalStorage сохраняются на неопределенное время, пока не будут явно удалены или очищены.</p><p>SessionStorage - это хранилище данных, связанное с текущей сессией пользователя. Данные в SessionStorage доступны только в пределах текущей сессии, и они удаляются, когда пользователь закрывает вкладку или окно браузера.</p><p>Максимальный размер LocalStorage зависит от браузера, но обычно составляет около 5 МБ. Это значительно больше, чем размер куки, и позволяет хранить большое количество данных на стороне клиента без отправки их на сервер. Однако, стоит помнить, что доступ к LocalStorage и SessionStorage ограничен областью видимости домена, в котором они созданы.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Как получить высоту блока? Его положения о границах документа?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Чтобы получить высоту блока в JavaScript, вы можете использовать свойство <code>offsetHeight</code> или метод <code>getBoundingClientRect().height</code>. <code>offsetHeight</code> возвращает высоту блока, включая вертикальные границы, поля и прокрутку, если она есть. <code>getBoundingClientRect().height</code> возвращает высоту блока без учета вертикальных границ и прокрутки.</p><p>Чтобы получить положение блока относительно границ документа, вы можете использовать свойство <code>offsetTop</code>. Оно возвращает расстояние от верхней границы блока до верхней границы родительского элемента или верхней границы документа, если родительского элемента нет.</p><p>Примеры:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">var</span> block = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myBlock'</span>);
    <span class="hljs-keyword">var</span> height = block.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// Получить высоту блока</span>
    <span class="hljs-keyword">var</span> position = block.<span class="hljs-property">offsetTop</span>; <span class="hljs-comment">// Получить положение блока относительно границ документа</span>
    </code></div></div></pre><p>Обратите внимание, что данные значения могут быть в пикселях или других единицах измерения в зависимости от настроек CSS.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое webpack?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Webpack - это инструмент сборки (бандлера) для JavaScript-приложений. Он позволяет объединять и упаковывать различные модули и ресурсы вашего проекта в единый файл или набор файлов, которые могут быть развернуты на сервере.</p><p>Webpack предоставляет мощные возможности, такие как управление зависимостями, минификация и оптимизация кода, использование препроцессоров CSS и многое другое. Он также поддерживает использование различных загрузчиков и плагинов, которые расширяют его функциональность и позволяют настраивать процесс сборки под конкретные потребности проекта.</p><p>Webpack особенно полезен для разработки современных веб-приложений, использующих модульную архитектуру и множество зависимостей. Он упрощает управление и развертывание кода, улучшает производительность и обеспечивает лучшую поддержку различных функциональностей, таких как загрузка кода по требованию (code splitting), использование новых возможностей ECMAScript и другие.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Чем отличается dev-сборка от prod?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Dev-сборка (development-сборка) и Prod-сборка (production-сборка) представляют два различных варианта сборки проекта с использованием инструментов сборки, таких как Webpack.</p><p>Dev-сборка предназначена для разработки и обладает рядом особенностей. Она обычно включает в себя дополнительную отладочную информацию, не минифицирует код, сохраняет исходные исходники, не выполняет некоторые оптимизации и может быть медленнее в работе. Dev-сборка также может включать функции разработчика, такие как Hot Module Replacement (HMR), которые обеспечивают мгновенное обновление кода без перезагрузки страницы.</p><p>Prod-сборка предназначена для продакшн-окружения. Она оптимизирует код, удаляет ненужные файлы, минифицирует и объединяет ресурсы, чтобы улучшить производительность и снизить размер файлов. Prod-сборка обычно исключает отладочную информацию и другие необходимые для разработки артефакты, чтобы уменьшить размер и повысить быстродействие приложения.</p><p>Отличие между dev-сборкой и prod-сборкой заключается в том, что dev-сборка предоставляет комфортную среду разработки с расширенными возможностями, в то время как prod-сборка оптимизирована для максимальной производительности и минимального размера для развертывания в продакшн-среде.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое блочная модель CSS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Блочная модель CSS — это основной принцип организации и расположения элементов на веб-странице с использованием CSS. Она определяет, как элементы HTML отображаются и взаимодействуют друг с другом внутри блоков.</p><p>Блочная модель состоит из нескольких компонентов: контент (содержимое элемента), отступы (пространство вокруг контента), границы (линии вокруг элемента), и заполнение (пространство между контентом и границами). Все эти компоненты вместе определяют полный размер и расположение элемента на странице.</p><p>Блочная модель позволяет управлять размерами и пространствами вокруг элементов с помощью CSS свойств, таких как width, height, margin, padding, border и других. Правильное использование блочной модели помогает создавать гибкий и удобочитаемый макет веб-страницы, а также контролировать внешний вид и расположение элементов.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какие способы центрирования блочного контента по горизонтали и вертикали знаете?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для центрирования блочного контента по горизонтали и вертикали можно использовать следующие способы:</p><ol><li><p>Центрирование по горизонтали:</p><ul><li>Установка свойства "margin" со значением "auto" для левого и правого отступов элемента.</li><li>Использование свойства "text-align" со значением "center" для родительского элемента.</li></ul></li><li><p>Центрирование по вертикали:</p><ul><li>Использование флексбоксов (flexbox) с помощью свойства "display: flex" для родительского элемента и свойства "align-items: center" для выравнивания по центру по вертикали.</li><li>Использование позиционирования и трансформации: задание свойств "position: absolute" и "transform: translateY(-50%)" для дочернего элемента, а также свойств "top: 50%" и "left: 50%" для родительского элемента.</li></ul></li></ol><p>Конкретный выбор метода центрирования зависит от контекста и требований проекта.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие подходы вам известны (float, flex, grid, etc)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые из подходов для создания макетов и расположения элементов в CSS:</p><ol><li><p>Float: Используется для обтекания элементами текста. Элементы плавают влево или вправо, создавая многоколоночный макет. Не рекомендуется для сложных макетов.</p></li><li><p>Flexbox: Гибкий контейнер, позволяющий управлять расположением элементов внутри него по горизонтали или вертикали. Удобен для создания одномерных макетов.</p></li><li><p>CSS Grid: Мощный инструмент для создания двумерных макетов. Позволяет определить сетку из ячеек и управлять их размещением. Обладает более сложным синтаксисом, но предоставляет больше гибкости.</p></li><li><p>Positioning: Использование свойств position, top, left, right, bottom для точного позиционирования элементов на странице. Может быть полезным для создания сложных макетов, но требует аккуратного управления.</p></li><li><p>CSS Columns: Позволяет разбить текстовое содержимое на колонки, упрощая создание многоколоночных макетов.</p></li></ol><p>Каждый подход имеет свои особенности и применяется в зависимости от требований проекта. Часто комбинируются несколько подходов для достижения нужного результата.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как сделать приложение responsive?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для создания responsive приложения следует использовать следующие подходы:</p><ol><li>Адаптивная вёрстка: Используйте медиа-запросы, чтобы изменять стили и макет в зависимости от размера экрана.</li><li>Гибкая сетка: Используйте систему сетки (например, Flexbox или CSS Grid) для создания гибкого и адаптивного макета.</li><li>Fluid Images: Установите максимальную ширину для изображений, чтобы они масштабировались пропорционально размеру контейнера.</li><li>Mobile-First: Разрабатывайте сначала для мобильных устройств, затем наращивайте функциональность и стили для больших экранов.</li><li>Responsive Typography: Используйте относительные единицы измерения (например, em или rem) для текста, чтобы он масштабировался вместе с контейнером.</li><li>Тестирование на разных устройствах: Проверьте своё приложение на разных устройствах и в браузерах с помощью инструментов разработчика.</li></ol><p>Обратите внимание, что responsive дизайн - это итеративный процесс, требующий тестирования и оптимизации для разных устройств и экранов.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т.д.)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Префиксы для CSS-свойств (-webkit-, -moz-, и т.д.) используются для поддержки экспериментальных или вендорных свойств, которые ещё не полностью стандартизированы или не поддерживаются всеми браузерами. Они позволяют разработчикам использовать новые возможности CSS, не дожидаясь окончательной спецификации.</p><p>Когда браузер видит свойство с префиксом, он понимает, что это экспериментальная или вендорная возможность, и обрабатывает его соответствующим образом. Если браузер поддерживает эту возможность, то свойство с префиксом будет применено. Если браузер не поддерживает свойство с префиксом, он просто проигнорирует его.</p><p>По мере развития стандартов CSS и установления браузерных реализаций, префиксы становятся менее необходимыми. В идеале, разработчики должны использовать безпрефиксные версии свойств, когда они становятся доступными, и удалять устаревшие префиксы для поддержки современных браузеров.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как упростить написание кроссбраузерных стилей?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для упрощения написания кроссбраузерных стилей веб-разработчики могут использовать следующие подходы:</p><ol><li><p>Использование CSS-фреймворков, таких как Bootstrap или Foundation, которые предоставляют готовые стили и компоненты, с учетом кроссбраузерности.</p></li><li><p>Использование CSS-препроцессоров, таких как Sass или Less, которые позволяют использовать переменные, миксины и другие возможности для более эффективной и организованной разработки стилей.</p></li><li><p>Использование CSS-полифиллов, которые предоставляют эмуляцию новых возможностей CSS для старых браузеров. Например, можно использовать полифиллы для CSS Grid или Flexbox.</p></li><li><p>Использование автоматических инструментов, таких как Autoprefixer, который добавляет вендорные префиксы автоматически на основе данных о поддержке браузерами.</p></li><li><p>Тестирование в различных браузерах и устройствах, чтобы убедиться, что стили отображаются корректно и согласно ожиданиям.</p></li></ol><p>Комбинация этих подходов поможет упростить написание кроссбраузерных стилей и обеспечить более однородное отображение вашего веб-сайта на разных платформах и браузерах.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое CSS-препроцессоры? С какими работали? Что нового они приносят в стандартный CSS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>CSS-препроцессоры - это инструменты, которые расширяют возможности стандартного CSS, добавляя переменные, функции, миксины и другие функциональности. Они позволяют разработчикам писать более организованный и модульный CSS-код.</p><p>Некоторые из известных CSS-препроцессоров:</p><ol><li><p>Sass (Syntactically Awesome Style Sheets): Я работал с Sass. Он предлагает множество возможностей, включая переменные, миксины, вложенность правил, операции и импорт файлов.</p></li><li><p>Less (Leaner CSS): Less предлагает подобные функциональности как Sass, также имеет синтаксис похожий на CSS.</p></li><li><p>Stylus: Stylus имеет более гибкий синтаксис, позволяющий писать CSS с использованием минимального количества скобок и точек с запятой.</p></li></ol><p>CSS-препроцессоры помогают в разработке более эффективного и переиспользуемого CSS-кода, упрощают поддержку и обновление стилей, а также обеспечивают лучшую организацию проекта. Они также предлагают возможности, которых нет в стандартном CSS, такие как миксины, которые позволяют повторно использовать блоки стилей, и переменные, которые упрощают изменение значений в нескольких местах одновременно.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Работали ли с классовыми компонентами? В чем их особенность?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, я работал с классовыми компонентами в React. Основная особенность классовых компонентов заключается в том, что они используют классы ES6 для определения компонента и наследования от базового класса React.Component. Они имеют встроенное состояние (state) и могут обрабатывать жизненный цикл компонента, такие как componentDidMount, componentDidUpdate и т.д.</p><p>Классовые компоненты обладают большей функциональностью и гибкостью по сравнению с функциональными компонентами. Они позволяют использовать локальное состояние, создавать методы и обрабатывать события. Они также предоставляют возможность использовать компоненты высшего порядка (HOC) и расширять функциональность компонентов с помощью наследования.</p><p>Однако с появлением React Hooks классовые компоненты стали менее рекомендуемым подходом, так как функциональные компоненты с хуками предлагают более простой и декларативный способ написания компонентов. Hooks позволяют использовать состояние и другие функциональности ранее доступные только в классовых компонентах без необходимости использовать классы и наследование.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
  {
    front: "<h1></h1>",
    back: ``,
    group: "Junior",
  },
];
