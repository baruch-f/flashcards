const dbJunior = [
  {
    front: "<h1>Каковы принципы семантической верстки?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Принципы семантической верстки включают следующее:</p><ol><li>Использование подходящих HTML-тегов: Используйте теги, которые лучше всего описывают содержимое (например, <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;footer&gt;</code> и т.д.).</li><li>Ясное обозначение структуры: Разделяйте страницу на смысловые блоки, используя подходящие теги, чтобы облегчить понимание структуры контента.</li><li>Корректное использование заголовков: Используйте заголовки <code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code> в правильной иерархии, чтобы отразить важность и связь различных разделов страницы.</li><li>Описание ссылок и элементов управления: Используйте атрибуты <code>title</code> и <code>alt</code> для описания ссылок и изображений, а также добавляйте подсказки к элементам управления.</li><li>Правильное применение списков: Используйте <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code> и <code>&lt;dl&gt;</code> для создания списков с пунктами, нумерацией или определениями соответственно.</li><li>Отсутствие таблиц для макета: Используйте таблицы только для представления табличных данных, а не для создания макета страницы.</li></ol><p>Семантическая верстка способствует лучшей доступности, SEO-оптимизации и облегчает сопровождение и понимание кода разработчиками.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие есть методы http запросов?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Существует несколько методов HTTP-запросов, которые определяют тип запроса, выполняемого клиентом. Некоторые из наиболее распространенных методов HTTP-запросов включают:</p><ol><li><p>GET: Получение ресурса по указанному URI. Этот метод используется для получения данных, которые могут быть кэшированы и могут быть переданы в строке запроса.</p></li><li><p>POST: Отправка данных на сервер для обработки. Этот метод используется для отправки данных на сервер, например, для создания новых ресурсов на сервере или для обновления существующих.</p></li><li><p>PUT: Замена ресурса или создание нового ресурса на сервере. Этот метод используется для создания или обновления ресурса на сервере.</p></li><li><p>DELETE: Удаление ресурса на сервере. Этот метод используется для удаления ресурса на сервере.</p></li><li><p>HEAD: Получение метаданных ресурса по указанному URI. Этот метод используется для получения метаданных, например, заголовков, без получения фактического содержимого ресурса.</p></li><li><p>OPTIONS: Получение информации о возможностях сервера по обработке запроса. Этот метод используется для получения информации о методах HTTP, поддерживаемых сервером, и других возможностях сервера.</p></li><li><p>TRACE: Получение отладочной информации о запросе. Этот метод используется для получения информации о том, как запрос проходит через промежуточные серверы.</p></li><li><p>CONNECT: Установка сетевого соединения с сервером через прокси-сервер. Этот метод используется для установки сетевого соединения с сервером через прокси-сервер.</p></li><li><p>PATCH: Частичное обновление ресурса на сервере. Этот метод используется для частичного обновления ресурса на сервере.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Зачем может понадобиться получение метаданных, например, заголовков, без получения фактического содержимого ресурса?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Получение метаданных ресурса, например, заголовков, без получения фактического содержимого ресурса, может быть полезно в нескольких случаях:</p><ol><li><p>Проверка доступности ресурса: Запрос типа HEAD может быть использован для проверки доступности ресурса без загрузки фактического содержимого. Это позволяет быстро проверить, существует ли ресурс на сервере и доступен ли он без необходимости загружать полное содержимое ресурса.</p></li><li><p>Получение метаданных ресурса: Заголовки HTTP-запроса содержат много полезной информации, например, о типе содержимого, размере файла, дате создания и дате последней модификации. Запрос типа HEAD может быть использован для получения этой информации, не загружая фактическое содержимое ресурса.</p></li><li><p>Экономия трафика: Запрос типа HEAD может быть использован для экономии трафика, особенно в случаях, когда содержимое ресурса крупное или когда пользовательская скорость интернета низкая. Получение только метаданных ресурса позволяет уменьшить объем передаваемых данных и сократить время загрузки страницы.</p></li><li><p>Защита конфиденциальности: Запрос типа HEAD может быть использован для защиты конфиденциальности, например, если ресурс содержит конфиденциальные данные, такие как пароли, которые не должны быть загружены на клиентскую машину. Получение только метаданных ресурса позволяет получить необходимую информацию без загрузки конфиденциального содержимого ресурса.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие есть версии http протокола?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Существует несколько версий протокола HTTP (Hypertext Transfer Protocol), которые были разработаны со временем для улучшения и расширения функциональности протокола. Наиболее распространенные версии HTTP:</p><ol><li><p>HTTP/0.9: Это первая версия HTTP, которая была разработана в 1991 году. Она была предназначена только для передачи HTML-документов и не поддерживала заголовки или другие типы содержимого.</p></li><li><p>HTTP/1.0: Это следующая версия HTTP, которая была выпущена в 1996 году. Она включила поддержку различных типов содержимого, заголовков запросов и ответов, а также возможность передачи бинарных данных.</p></li><li><p>HTTP/1.1: Эта версия HTTP была выпущена в 1999 году и включает множество улучшений, таких как поддержка кэширования, поддержка сжатия данных, возможность ограничения скорости передачи и другие функции.</p></li><li><p>HTTP/2: Это новая версия HTTP, выпущенная в 2015 году. Она предлагает ряд значительных улучшений по сравнению с HTTP/1.1, включая мультиплексирование, сжатие заголовков и данных, приоритеты потоков и другие функции, которые позволяют значительно улучшить производительность и безопасность веб-приложений.</p><p class="indent">Основными преимуществами нового протокола HTTP/2, по сравнению с предшествующими версиями, можно выделить:</p><ul>
    <li>Ускорение скорости загрузки данных</li>
    <li>Обязательное использование шифрования SSL/TLS</li>
    <li>Уменьшение объёма передаваемых по сети данных</li>
  </ul></li><li><p>HTTP/3: Это последняя версия HTTP, выпущенная в 2020 году. Она основана на протоколе QUIC (Quick UDP Internet Connections) и предлагает дополнительные улучшения производительности, такие как снижение задержек, сокращение числа обменов данными и улучшение безопасности.</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие существуют коды ответа (состояния) в http?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>HTTP (Hypertext Transfer Protocol) использует коды ответа (состояния), чтобы указать результат выполнения запроса. Коды ответа HTTP делятся на пять классов, каждый из которых имеет свои числовые коды:</p><ol><li><p>Информационные коды (Informational): Коды ответа, начинающиеся с 1xx, указывают на то, что запрос принят, но обработка еще продолжается.</p></li><li><p>Коды успеха (Success): Коды ответа, начинающиеся с 2xx, указывают на то, что запрос был успешно обработан и возвращен запрошенный ресурс.</p></li><li><p>Коды перенаправления (Redirection): Коды ответа, начинающиеся с 3xx, указывают на то, что для получения запрошенного ресурса клиенту необходимо выполнить дополнительные действия, например, перейти на другой URL.</p></li><li><p>Коды ошибок клиента (Client errors): Коды ответа, начинающиеся с 4xx, указывают на ошибки, связанные с запросом, отправленным клиентом. Например, такие ошибки, как 404 Not Found (страница не найдена), 403 Forbidden (доступ запрещен) и другие.</p></li><li><p>Коды ошибок сервера (Server errors): Коды ответа, начинающиеся с 5xx, указывают на ошибки, связанные с обработкой запроса на сервере. Например, такие ошибки, как 500 Internal Server Error (внутренняя ошибка сервера), 503 Service Unavailable (сервис временно недоступен) и другие.</p></li></ol><p>Некоторые из наиболее распространенных кодов ответа HTTP:</p><ul><li>200 OK: запрос выполнен успешно, и результатом является запрошенный ресурс.</li><li>201 Created: ресурс был создан успешно.</li><li>204 No Content: запрос выполнен успешно, но ответ не содержит содержимого (например, в ответ на запрос метода DELETE).</li><li>301 Moved Permanently: запрошенный ресурс перемещен на другой URL, постоянно.</li><li>302 Found: запрошенный ресурс временно перемещен на другой URL.</li><li>400 Bad Request: запрос был неверным, сервер не может понять, что требуется от него.</li><li>401 Unauthorized: для доступа к запрошенному ресурсу требуется авторизация.</li><li>403 Forbidden: сервер понимает запрос, но отказывается выполнять его из-за ограничений на доступ к ресурсу.</li><li>404 Not Found: запрошенный ресурс не найден.</li><li>500 Internal Server Error: внутренняя ошибка сервера.</li></ul></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое cross origin resource sharing? Как устранить проблемы с CORS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Cross-Origin Resource Sharing (CORS) - это механизм, позволяющий веб-страницам запрашивать ресурсы из другого источника, отличного от текущего домена. Этот механизм применяется для обеспечения безопасности веб-приложений и предотвращения атак, таких как Cross-Site Request Forgery (CSRF).</p><p>Когда веб-страница запрашивает ресурсы из другого домена, браузер отправляет HTTP-запрос на этот домен. Если сервер на другом домене не настроен для обработки таких запросов, браузер не разрешит получение ответа из-за политик Same-Origin. CORS позволяет серверу на другом домене явно разрешать запросы с определенных источников, устанавливая заголовок Access-Control-Allow-Origin.</p><p>Чтобы устранить проблемы с CORS, можно предпринять следующие шаги:</p><ol><li><p>Настроить сервер на другом домене, чтобы он отправлял заголовок Access-Control-Allow-Origin, разрешающий запросы с домена, на котором запущен клиентский код.</p></li><li><p>Использовать JSONP (JSON with Padding) вместо обычных AJAX-запросов, если сервер не может быть настроен для CORS. JSONP позволяет получать данные с другого домена, обертывая ответ в функцию JavaScript.</p></li><li><p>Использовать прокси-сервер, который будет работать на том же домене, что и клиентский код, и перенаправлять запросы на сервер на другом домене. Такой прокси-сервер может обрабатывать запросы от клиента и отправлять их на другой домен, а затем отправлять ответ от сервера обратно клиенту.</p></li><li><p>Использовать CORS-библиотеки, которые могут обеспечивать безопасный доступ к API, например, CORS Anywhere или cors-lite.</p></li></ol><p>В целом, решение проблем с CORS зависит от специфики вашего приложения и серверной архитектуры, но настройка сервера для поддержки CORS-запросов является наиболее распространенным подходом.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Расскажи подробнее о jsonp</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JSONP (JSON with Padding) - это метод, который позволяет получать данные с другого домена при использовании JavaScript веб-приложений, обходя ограничения Same-Origin Policy. Он работает путем добавления тега скрипта на страницу и передачи параметров в качестве запроса.</p><p>Когда вы делаете AJAX-запрос на другой домен, браузер блокирует ответ из-за политики Same-Origin Policy. Вместо этого, вы можете сделать запрос на другой домен, передавая название функции в качестве параметра запроса, и сервер будет обернуть ответ в эту функцию.</p><p>Вот пример запроса с JSONP:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) {
          <span class="hljs-comment">// обрабатываем полученные данные</span>
        }
        
        <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'script'</span>);
        script.<span class="hljs-property">src</span> = <span class="hljs-string">'http://example.com/data?callback=handleResponse'</span>;
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'head'</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script);
        </code></div></div></pre><p>В этом примере мы создаем элемент <code>script</code>, который будет загружать данные с URL-адреса <code>http://example.com/data</code>. Мы также передаем параметр <code>callback=handleResponse</code>, чтобы сервер знал, какую функцию вызывать для обработки ответа.</p><p>Сервер должен вернуть ответ в виде вызова функции <code>handleResponse</code>, обернутой в круглые скобки:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-title function_">handleResponse</span>({<span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>});
        </code></div></div></pre><p>Таким образом, когда сервер вернет ответ, браузер выполнит этот код и вызовет функцию <code>handleResponse</code>, которую мы определили ранее. Функция <code>handleResponse</code> будет иметь доступ к данным, которые были переданы в ответе сервера.</p><p>JSONP может быть полезным, когда вам нужно получить данные с другого домена, который не поддерживает CORS или когда вы работаете со сторонними API, которые используют JSONP в качестве механизма передачи данных. Однако, есть некоторые ограничения, такие как отсутствие поддержки POST-запросов и ограничения на количество данных, которые могут быть переданы. Кроме того, необходимо учитывать потенциальные уязвимости в безопасности, связанные с выполнением удаленного JavaScript-кода на вашей странице, поэтому не рекомендуется использовать JSONP для передачи конфиденциальных данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое cookie?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Cookie (куки) - это небольшие текстовые файлы, которые хранятся на компьютере пользователя веб-браузера. Они используются для сохранения информации о пользователе и его предпочтениях на веб-сайте.</p><p>Куки создаются и хранятся на стороне сервера, но они могут быть прочитаны и использованы браузером при каждом запросе к серверу. Куки могут содержать различную информацию, такую как идентификатор сеанса, языковые настройки, предпочтения пользователя, содержимое корзины покупок и т.д.</p><p>Когда пользователь посещает веб-сайт, сервер отправляет куки в браузер пользователя, который сохраняет их на локальном компьютере. В следующий раз, когда пользователь посещает тот же веб-сайт, браузер отправляет куки на сервер, что позволяет серверу распознать пользователя и предоставить персонализированный контент.</p><p>Некоторые типы куков:</p><ul><li>Session cookies (куки сеанса) - это временные куки, которые хранятся только во время сеанса браузера и удаляются, когда браузер закрывается.</li><li>Persistent cookies (куки постоянные) - это куки, которые сохраняются на компьютере пользователя и используются для сохранения информации о пользователе между сеансами браузера. Они могут оставаться на компьютере пользователя в течение определенного времени, указанного в куки, или до тех пор, пока они не будут удалены пользователем.</li></ul><p>Куки могут быть полезными для улучшения пользовательского опыта, так как они позволяют веб-сайтам запомнить предпочтения пользователя и предоставлять персонализированный контент. Однако, некоторые люди могут не быть комфортными с тем, что их данные используются для этих целей, поэтому веб-сайты должны уведомлять пользователей о том, как они используют куки и предоставлять возможность отказаться от использования куков. Кроме того, некоторые типы куков могут быть использованы в целях отслеживания пользовательской активности, поэтому пользователи должны быть ознакомлены с тем, как их данные используются, и какие данные хранятся в куки.</p><a target="_blank" href="https://ru.wikipedia.org/wiki/Cookie">https://ru.wikipedia.org/wiki/Cookie</a></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какой максимальный размер cookie?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Максимальный размер cookie зависит от браузера и настроек сервера. Согласно стандарту RFC 6265, каждый cookie может содержать до 4096 байт (4 килобайта) данных, включая имя, значение и другие параметры, такие как дата истечения срока действия и область действия. Однако, на практике многие браузеры устанавливают ограничение на размер cookie, обычно в диапазоне от 4093 до 8192 байт (4-8 килобайт).</p><p>Также следует учитывать, что браузеры имеют ограничения на общее количество cookie, которые могут быть хранены для одного домена. Общее количество cookie для каждого домена может быть ограничено от 20 до 50, в зависимости от браузера и настроек безопасности.</p><p>Если размер cookie превышает максимальный размер, то сервер может разбить данные на несколько cookie или использовать другой метод хранения информации, такой как localStorage или sessionStorage, в зависимости от требований и возможностей приложения.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Расскажи подробнее о sessionStorage</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>sessionStorage - это механизм хранения данных в браузере, который позволяет сохранять данные в рамках текущей сессии (открытой вкладки браузера), которые могут использоваться веб-приложением в течение этой сессии. Данные сохраняются в формате пар "ключ-значение", подобно тому, как это происходит в localStorage. Однако, sessionStorage имеет несколько отличий от localStorage:</p><ol><li><p>Данные, сохраненные в sessionStorage, доступны только в рамках текущей сессии браузера. Это означает, что если пользователь закроет вкладку или браузер, то данные будут удалены.</p></li><li><p>Данные, сохраненные в sessionStorage, не будут переданы на сервер, когда пользователь отправляет запросы на сервер. Они доступны только на клиентской стороне.</p></li><li><p>Каждая вкладка в браузере имеет свой собственный экземпляр sessionStorage. Это означает, что данные, сохраненные в одной вкладке, не будут доступны в других вкладках.</p></li></ol><p>Пример использования sessionStorage:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-comment">// Сохранение данных в sessionStorage</span>
    sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'username'</span>, <span class="hljs-string">'John'</span>);
    
    <span class="hljs-comment">// Получение данных из sessionStorage</span>
    <span class="hljs-keyword">const</span> username = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">'username'</span>);
    
    <span class="hljs-comment">// Удаление данных из sessionStorage</span>
    sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">'username'</span>);
    </code></div></div></pre><p>sessionStorage можно использовать для хранения небольших объемов данных, таких как настройки пользователя, состояние формы, временные данные и т.д. Однако, если требуется хранить большие объемы данных или данные должны быть доступны после перезапуска браузера, то рекомендуется использовать другие механизмы хранения, такие как localStorage или базы данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что означает директива use strict?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Директива "use strict" (строгий режим) - это специальный синтаксис в JavaScript, который позволяет разработчикам писать более безопасный и строгий код, и позволяет браузеру выполнять код более эффективно.</p><p>Когда директива "use strict" добавляется в начало скрипта или функции, то JavaScript движок переключается в режим строгого выполнения. В этом режиме происходит следующее:</p><ol><li><p>Запрещается использовать необъявленные переменные. В режиме "use strict" переменные не могут быть созданы, если они не были предварительно объявлены с помощью ключевых слов var, let или const.</p></li><li><p>Запрещается удаление переменных, функций или аргументов функции.</p></li><li><p>Запрещается использование зарезервированных слов как идентификаторов, например, let, const, class, function, arguments и т.д.</p></li><li><p>Запрещается использовать функции или переменные с одинаковыми именами в одной области видимости.</p></li><li><p>Запрещается использование eval() функции, которая выполняет произвольный код.</p></li><li><p>Запрещается использование with оператора, который создает новую область видимости.</p></li><li><p>Запрещается изменять значения свойств только для чтения (writable: false) и констант.</p></li><li><p>В строгом режиме this имеет значение undefined в функциях, которые вызываются без контекста.</p></li></ol><p>Использование директивы "use strict" помогает избежать ошибок, связанных с неявным созданием глобальных переменных, использованием зарезервированных слов как идентификаторов и других проблем с безопасностью. Она также позволяет браузеру выполнять код более эффективно, что может улучшить производительность приложения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Чем js отличается во время работы на front-end и back-end?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JavaScript является языком программирования, который может использоваться как на стороне клиента (front-end), так и на стороне сервера (back-end).</p><p>Когда JavaScript используется на стороне клиента (front-end), то он выполняется в браузере пользователя и работает с HTML и CSS для создания интерактивных веб-страниц. Он может обращаться к DOM (Document Object Model), чтобы изменять содержимое страницы, обрабатывать пользовательские события, отправлять запросы на сервер и обрабатывать ответы.</p><p>Когда JavaScript используется на стороне сервера (back-end), то он выполняется на сервере и используется для обработки запросов от клиентов и генерации динамических веб-страниц. Например, он может работать с базой данных, обрабатывать данные формы, реализовывать алгоритмы для вычислений, отправлять электронные письма и т.д.</p><p>Важными отличиями между front-end и back-end JavaScript являются:</p><ol><li><p>API: На стороне клиента JavaScript может использовать API браузера, такие как DOM API, AJAX API, Web Storage API и т.д. На стороне сервера JavaScript использует API Node.js, которые позволяют работать с сетью, файловой системой, базами данных и т.д.</p></li><li><p>Библиотеки и фреймворки: На стороне клиента JavaScript часто используется библиотека jQuery, фреймворк Angular, React или Vue.js для разработки веб-приложений. На стороне сервера JavaScript используется фреймворк Express.js для создания веб-приложений, фреймворк Meteor.js для создания реального времени веб-приложений и многие другие.</p></li><li><p>Специфика работы: На стороне клиента JavaScript выполняется в браузере пользователя и может взаимодействовать с пользователем, а на стороне сервера он выполняется на сервере и работает вне контекста браузера.</p></li><li><p>Система файлов: На стороне клиента JavaScript работает с файлами HTML, CSS и JavaScript, которые загружаются в браузер, а на стороне сервера JavaScript работает с файлами и базами данных, хранящихся на сервере.</p></li></ol><p>Несмотря на эти различия, JavaScript остается одним и тем же языком программирования, используемым как на стороне клиента, так и на стороне сервера.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>что такое статическая и динамическая типизация?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Статическая типизация и динамическая типизация - это два разных подхода к управлению типами данных в языках программирования.</p><p>Статическая типизация предполагает, что тип переменной определяется на этапе компиляции программы и не может быть изменен во время выполнения программы. При статической типизации программист должен объявлять типы переменных заранее и следить за их соответствием при работе с ними. В языках программирования со статической типизацией, таких как Java, C++, TypeScript, Swift, Haskell и другие, компилятор может проверять правильность использования типов во время компиляции, что может помочь предотвратить многие ошибки во время выполнения программы.</p><p>Динамическая типизация, наоборот, позволяет переменным изменять свой тип во время выполнения программы. При динамической типизации программист может создавать переменные без указания их типов, и тип переменной будет определяться автоматически во время выполнения программы в зависимости от значения, которое она хранит. В языках программирования с динамической типизацией, таких как JavaScript, Python, Ruby, PHP и другие, компилятор не может проверять правильность использования типов во время компиляции, что может приводить к ошибкам во время выполнения программы.</p><p>Каждый подход имеет свои преимущества и недостатки, и выбор между статической и динамической типизацией зависит от конкретных потребностей проекта и личных предпочтений программиста. Например, статическая типизация может быть полезной при работе с большими проектами с большим количеством разработчиков, где необходимо обеспечить строгую проверку типов во время компиляции. Динамическая типизация может быть полезна при работе с небольшими проектами, где необходима большая гибкость и быстрота разработки.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как клиент взаимодействует  с сервером</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Клиент и сервер - это две стороны взаимодействия в модели клиент-сервер. Клиент - это устройство или приложение, которое запрашивает ресурсы или услуги у сервера, а сервер - это устройство или приложение, которое предоставляет эти ресурсы или услуги.</p><p>Для взаимодействия клиента и сервера используется протокол передачи данных, такой как HTTP, TCP или UDP. Протокол определяет формат сообщений, которые обмениваются клиент и сервер, и правила, по которым они обмениваются этими сообщениями.</p><p>Когда клиент хочет получить ресурс или услугу от сервера, он отправляет запрос серверу. Запрос состоит из метода, URI и заголовков. Метод указывает, что именно клиент хочет сделать с ресурсом на сервере (например, получить его, изменить или удалить), URI указывает, какой ресурс на сервере требуется клиенту, а заголовки могут содержать дополнительную информацию о запросе, например, тип содержимого или информацию об аутентификации.</p><p>Когда сервер получает запрос от клиента, он анализирует его и генерирует ответ. Ответ также состоит из заголовков и содержимого. Заголовки содержат информацию о том, как был обработан запрос (например, успешно или с ошибкой), тип содержимого и другую метаинформацию. Содержимое ответа - это сам запрошенный ресурс или результат выполнения запроса.</p><p>После получения ответа клиент обрабатывает его и отображает пользователю. Если ответ содержит запрошенный ресурс, клиент может отобразить его в браузере или использовать его в своей программе. Если ответ содержит результат выполнения запроса, клиент может обработать его и использовать его в своей программе.</p><p>Взаимодействие клиента и сервера может быть синхронным или асинхронным. В синхронном взаимодействии клиент ожидает ответа от сервера перед тем, как продолжить свою работу. В асинхронном взаимодействии клиент может отправлять запросы на сервер и продолжать свою работу, не ожидая ответа от сервера. Когда ответ будет получен, клиент будет уведомлен об этом и сможет обработать его.</p><p>В целом, взаимодействие клиента и сервера - это процесс обмена сообщениями, где клиент запрашивает ресурсы или услуги у сервера, а сервер предоставляет эти ресурсы или услуги в ответ на запросы клиента. Протокол передачи данных</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое REST?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>REST (Representational State Transfer) - это архитектурный стиль, который определяет правила для создания веб-служб, использующих протокол HTTP для передачи и обмена данными. Он был создан Роем Филдингом в 2000 году.</p><p>Основной принцип REST заключается в использовании ресурсов (например, объектов или коллекций), которые представляют данные, и методов HTTP, которые определяют операции, которые можно выполнить с этими ресурсами. Следуя этому принципу, RESTful-веб-службы предоставляют стандартизированные интерфейсы для доступа к данным, что делает их более гибкими и легкими для использования.</p><p>Основные принципы REST включают в себя:</p><ol><li><p>Клиент-серверная архитектура. Клиент и сервер - это две отдельные части системы, которые взаимодействуют друг с другом через интерфейс, определенный в RESTful-веб-службах.</p></li><li><p>Отсутствие состояния. Сервер не хранит информацию о предыдущих запросах клиента. Каждый запрос рассматривается как новый запрос, и сервер отвечает на него соответствующим образом.</p></li><li><p>Кэширование. Сервер может указывать клиенту, что ответ на запрос может быть кэширован для повторного использования.</p></li><li><p>Единообразный интерфейс. Интерфейс RESTful-веб-служб должен быть единообразным для всех ресурсов и методов, что обеспечивает удобство использования.</p></li><li><p>Слои. Клиент не должен знать о слоях, которые находятся между ним и сервером. Это позволяет изменять или добавлять слои без влияния на клиента.</p></li></ol><p>RESTful-веб-службы позволяют клиентам получать доступ к данным и управлять ими с помощью стандартных методов HTTP, таких как GET, POST, PUT и DELETE. Например, клиент может использовать GET-запрос, чтобы получить информацию о ресурсе, POST-запрос, чтобы создать новый ресурс, PUT-запрос, чтобы обновить существующий ресурс, и DELETE-запрос, чтобы удалить ресурс.</p><p>В целом, RESTful-веб-службы - это стандартизированные интерфейсы для доступа к данным с использованием протокола HTTP. Они позволяют клиентам получать доступ к данным и управлять ими, используя стандартные методы HTTP, что делает их более гибк</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Объясните понятие мутабельность/иммутабельность? Какие типы являются мутабельными и наоборот?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Мутабельность и иммутабельность - это свойства объектов, определяющие возможность изменения их состояния после создания. Мутабельный объект может быть изменен после создания, а иммутабельный - не может быть изменен, после того как его создали.</p><p>В JavaScript простые типы (например, number, string, boolean) являются иммутабельными, то есть нельзя изменить значение простого типа напрямую. Если переменной, содержащей простой тип, присвоить новое значение, то будет создан новый объект, а не изменено старое.</p><p>С другой стороны, составные типы (например, массивы и объекты) являются мутабельными, то есть могут быть изменены после создания. Например, можно добавить или удалить элементы из массива, а также изменить свойства объекта.</p><p>Иммутабельность имеет ряд преимуществ, например, она облегчает отладку и тестирование кода, делает его более безопасным и предсказуемым. Кроме того, иммутабельные структуры данных могут быть использованы для создания функциональных программ и реализации функционального программирования.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как искать ошибки в коде при разработке на JS? </h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При разработке на JavaScript возможны различные ошибки, такие как синтаксические ошибки, ошибки времени выполнения и ошибки логики.</p><p>Одним из способов поиска ошибок является использование отладчика в браузере или интегрированной среды разработки (IDE), такой как Visual Studio Code. Отладчик позволяет пошагово выполнять код и проверять значения переменных на каждом шаге, что может помочь выявить ошибки. Также можно использовать консоль разработчика в браузере для вывода сообщений об ошибках и просмотра значений переменных.</p><p>Другой метод - это написание тестов для кода с использованием фреймворков, таких как Jest или Mocha. Тесты позволяют автоматически проверять код на предмет ошибок и несоответствий ожидаемому поведению.</p><p>Хорошей практикой является также использование линтеров, таких как ESLint или JSLint. Они проверяют код на соответствие стандартам и правилам написания кода, помогают выявлять ошибки и делают код более читабельным.</p><p>Еще один метод - это code review, то есть ревью кода коллегами разработчиками. Они могут заметить ошибки, которые вы можете пропустить, и предложить улучшения в коде.</p><p>В целом, для поиска ошибок в коде на JavaScript необходимо использовать несколько методов и инструментов, чтобы сделать код более надежным и стабильным.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как использовать дебагер?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Дебагер - это инструмент, который помогает разработчикам находить и исправлять ошибки в коде. Для использования дебагера необходимо выполнить следующие шаги:</p><ol><li><p>Открыть в браузере страницу с отладочным кодом и нажать F12, чтобы открыть инструменты разработчика.</p></li><li><p>В разделе "Sources" выбрать файл с отладочным кодом и добавить точки останова в нужных местах кода, нажимая на соответствующие номера строк.</p></li><li><p>Выполнить нужные действия на странице, которые приводят к ошибке. Когда выполнение кода доходит до точки останова, выполнение приостанавливается и появляется возможность просмотреть значения переменных и текущее состояние кода.</p></li><li><p>Использовать панель инструментов дебагера для шага по коду, просмотра значений переменных и выявления ошибок.</p></li><li><p>Если ошибка была обнаружена, исправить ее и перезапустить код, начиная с пункта 2.</p></li></ol><p>Для более эффективного использования дебагера, необходимо обладать знаниями JavaScript и уметь понимать, как код работает. Также рекомендуется изучать документацию по инструментам разработчика, чтобы понимать все возможности и функции дебагера и других инструментов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Каких известных людей из мира JS знаете?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В мире JavaScript есть много известных и влиятельных людей. Некоторые из них:</p><ol><li><p>Brendan Eich - создатель JavaScript, сооснователь Mozilla, Brave Software.</p></li><li><p>Douglas Crockford - разработчик, который создал JSON, автор книги "JavaScript: The Good Parts".</p></li><li><p>Addy Osmani - инженер Google, который работает над инструментами разработки веб-приложений, автор книги "Learning JavaScript Design Patterns".</p></li><li><p>Kyle Simpson - автор книг "You Don't Know JS", разработчик, участник сообщества JavaScript.</p></li><li><p>Dan Abramov - разработчик Facebook, создатель Redux и React Hot Loader.</p></li><li><p>John Resig - создатель библиотеки jQuery.</p></li><li><p>Wes Bos - автор курсов по JavaScript и разработке веб-приложений.</p></li></ol><p>Это далеко не полный список известных людей из мира JavaScript, но они внесли значительный вклад в развитие этого языка программирования.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие существуют типы данных в JS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько типов данных. Они могут быть примитивными и объектными.</p><ol><li><p>Примитивные типы данных:</p><ul><li>Числа (number) - целые числа и числа с плавающей точкой.</li><li>Строки (string) - последовательность символов в кавычках.</li><li>Булевы значения (boolean) - true и false.</li><li>undefined - используется для неинициализированных переменных.</li><li>null - используется для представления отсутствия значения.</li><li>Symbol - уникальный и неизменяемый тип данных, добавленный в ECMAScript 6.</li></ul></li><li><p>Объектные типы данных:</p><ul><li>Объекты (object) - набор свойств и методов, представленных в фигурных скобках {}.</li><li>Функции (function) - объекты, которые могут быть вызваны.</li><li>Массивы (array) - упорядоченные списки элементов.</li><li>Дата (date) - объекты, которые представляют дату и время.</li><li>Регулярные выражения (regexp) - объекты, используемые для сопоставления текста с шаблоном.</li></ul></li></ol><p>Также в JavaScript есть понятие "динамической типизации". Это означает, что тип переменной определяется во время выполнения программы, а не во время компиляции. Это позволяет гибко работать с типами данных и упрощает разработку программ. Однако, это также может приводить к ошибкам в программе, связанным с неправильным использованием типов данных.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Сколько типов данных в JavaScript ?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><b>7</b><ol><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>Null</li><li>Symbol</li><li>Object</li></ol><p>В JavaScript существует несколько типов данных. Они могут быть примитивными и объектными.</p><ol><li><p>Примитивные типы данных:</p><ul><li>Числа (number) - целые числа и числа с плавающей точкой.</li><li>Строки (string) - последовательность символов в кавычках.</li><li>Булевы значения (boolean) - true и false.</li><li>undefined - используется для неинициализированных переменных.</li><li>null - используется для представления отсутствия значения.</li><li>Symbol - уникальный и неизменяемый тип данных, добавленный в ECMAScript 6.</li></ul></li><li><p>Объектные типы данных:</p><ul><li>Объекты (object) - набор свойств и методов, представленных в фигурных скобках {}.</li><li>Функции (function) - объекты, которые могут быть вызваны.</li><li>Массивы (array) - упорядоченные списки элементов.</li><li>Дата (date) - объекты, которые представляют дату и время.</li><li>Регулярные выражения (regexp) - объекты, используемые для сопоставления текста с шаблоном.</li></ul></li></ol><p>Также в JavaScript есть понятие "динамической типизации". Это означает, что тип переменной определяется во время выполнения программы, а не в</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, является ли объект массивом?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько способов проверки, является ли объект массивом:</p><ol><li><p>Метод Array.isArray():
    Этот метод возвращает true, если переданный аргумент является массивом, и false в противном случае.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj)); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li><li><p>Свойство instanceof:
    Это свойство проверяет, является ли объект экземпляром указанного конструктора (в данном случае, Array).</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li><li><p>Проверка свойства constructor:
    Все объекты в JavaScript имеют свойство constructor, которое ссылается на конструктор, используемый для создания объекта. Массивы в JavaScript создаются с использованием конструктора Array. Поэтому можно проверить, совпадает ли свойство constructor объекта с конструктором Array.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">key</span>: <span class="hljs-string">"value"</span> };
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span>); <span class="hljs-comment">// false</span>
    </code></div></div></pre></li></ol></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, является ли число конечным?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript для проверки, является ли число конечным, можно использовать метод <code>isFinite()</code>.</p><p>Синтаксис метода <code>isFinite()</code>:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>scss</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-scss"><span class="hljs-built_in">isFinite</span>(number)
    </code></div></div></pre><p>где <code>number</code> - это число, которое необходимо проверить.</p><p>Метод <code>isFinite()</code> возвращает <code>true</code>, если переданное значение является конечным числом, и <code>false</code>, если это значение является бесконечностью (<code>Infinity</code> или <code>-Infinity</code>) или не является числом.</p><p>Примеры:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">1.23e1000</span>)); <span class="hljs-comment">// false (число слишком большое для JavaScript)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(-<span class="hljs-title class_">Infinity</span>)); <span class="hljs-comment">// false</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-string">"42"</span>)); <span class="hljs-comment">// true (строка будет автоматически преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isFinite</span>(<span class="hljs-string">"Hello"</span>)); <span class="hljs-comment">// false (строка не может быть преобразована в число)</span>
    </code></div></div></pre><p>Также стоит учитывать, что метод <code>isFinite()</code> преобразует переданное значение в число, если это возможно, поэтому при передаче значения, которое не может быть преобразовано в число, метод вернет <code>false</code>.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как проверить, что переменная равна NaN?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript для проверки, что переменная равна NaN (Not a Number), необходимо использовать функцию <code>isNaN()</code>.</p><p>Функция <code>isNaN()</code> принимает один аргумент и возвращает <code>true</code>, если переданный аргумент не является числом (NaN), и <code>false</code>, если аргумент является числом.</p><p>Примеры использования:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">42</span>)); <span class="hljs-comment">// false</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"42"</span>)); <span class="hljs-comment">// false (строка будет преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">"Hello"</span>)); <span class="hljs-comment">// true (строка не может быть преобразована в число)</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>)); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// true</span>
    </code></div></div></pre><p>Также стоит учитывать, что функция <code>isNaN()</code> может приводить к неожиданным результатам при использовании с определенными типами данных, такими как объекты, массивы и булевы значения, поэтому рекомендуется использовать эту функцию только для проверки, является ли значение NaN или нет. Если необходимо проверить, является ли значение числом, рекомендуется использовать функцию <code>Number.isNaN()</code> вместо <code>isNaN()</code>.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Сравните ключевые слова var, let, const</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ключевое слово var используется для объявления переменных в старой версии JavaScript, которая поддерживается всеми браузерами. Однако, оно имеет некоторые проблемы, связанные с областью видимости переменных.</p><p>Ключевые слова let и const были добавлены в новых версиях JavaScript для решения проблем, связанных с областью видимости переменных. Переменные, объявленные с помощью let и const, имеют блочную область видимости и не могут быть переобъявлены в том же блоке.</p><p>Ключевое слово let используется для объявления переменных со значением, которое может изменяться. Ключевое слово const используется для объявления переменных со значением, которое не может быть изменено. При попытке изменить значение const переменной будет выброшено исключение.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое область видимости?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Область видимости - это область, где определенный идентификатор (например, переменная, функция) может быть использован. В JavaScript область видимости может быть глобальной или локальной.</p><p>Глобальная область видимости - это область видимости, доступная в любом месте в программе. Переменные, определенные в глобальной области видимости, могут быть использованы в любом месте программы.</p><p>Локальная область видимости - это область видимости, которая определена внутри функции. Переменные, определенные в локальной области видимости, не могут быть использованы вне функции.</p><p>JavaScript также имеет блочную область видимости с помощью ключевых слов let и const, которые позволяют определять переменные в области видимости блока. Переменные, определенные с помощью let и const, не могут быть использованы вне блока, в котором они были определены.</p><p>Область видимости имеет значение при работе с переменными и функциями, поскольку это позволяет контролировать доступность их использования в разных частях программы.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое деструктуризация?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Деструктуризация — это способ извлечения значений из массивов или объектов и присвоения их локальным переменным. Она позволяет удобно и компактно извлекать только нужные значения из структуры данных и использовать их далее в коде.</p><p>Для деструктуризации массива можно использовать квадратные скобки, а для объекта — фигурные скобки. В квадратных скобках указываются переменные, которые будут присвоены значениям из массива, а в фигурных — имена переменных, которые будут присвоены значениям из объекта. Если нужно присвоить значение по умолчанию, то оно указывается после знака равенства.</p><p>Пример деструктуризации массива:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>arduino</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-arduino"><span class="hljs-type">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
    <span class="hljs-type">const</span> [a, b, c] = arr;
    console.<span class="hljs-built_in">log</span>(a); <span class="hljs-comment">// 1</span>
    console.<span class="hljs-built_in">log</span>(b); <span class="hljs-comment">// 2</span>
    console.<span class="hljs-built_in">log</span>(c); <span class="hljs-comment">// 3</span>
    </code></div></div></pre><p>Пример деструктуризации объекта:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>arduino</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-arduino"><span class="hljs-type">const</span> obj = {name: <span class="hljs-string">'John'</span>, age: <span class="hljs-number">30</span>};
    <span class="hljs-type">const</span> {name, age} = obj;
    console.<span class="hljs-built_in">log</span>(name); <span class="hljs-comment">// 'John'</span>
    console.<span class="hljs-built_in">log</span>(age); <span class="hljs-comment">// 30</span>
    </code></div></div></pre><p>Также можно использовать деструктуризацию с параметрами функций, чтобы извлечь значения из объектов, переданных в качестве аргументов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Для чего предназначены методы setTimeout и setInterval?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Методы <code>setTimeout</code> и <code>setInterval</code> в JavaScript используются для отложенного выполнения функций.</p><p>Метод <code>setTimeout</code> позволяет задержать выполнение функции на определенный промежуток времени, который указывается в миллисекундах в качестве второго параметра. Первым параметром передается функция, которая должна быть выполнена после задержки.</p><p>Синтаксис:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>, delay)
    </code></div></div></pre><p>Метод <code>setInterval</code> также позволяет задержать выполнение функции, но в отличие от <code>setTimeout</code>, функция будет вызываться периодически через определенные промежутки времени, указанные вторым параметром.</p><p>Синтаксис:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>, delay)
    </code></div></div></pre><p>Оба метода возвращают идентификатор таймера, который может быть использован для остановки таймера путем вызова метода <code>clearTimeout</code> или <code>clearInterval</code>, соответственно.</p><p>Таким образом, <code>setTimeout</code> и <code>setInterval</code> позволяют отложить или периодически вызвать функцию после определенного промежутка времени, что может быть полезно при реализации анимации, обновлении данных и других подобных задач.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Сравните подходы работы с асинхронным кодом: сallbacks vs promises vs async/await.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript существует несколько подходов для работы с асинхронным кодом: callbacks, promises и async/await.</p><p>Callbacks - это функции, которые передаются как аргументы в другие функции и вызываются после выполнения определенного действия, например, завершения выполнения запроса к серверу. Однако использование большого количества вложенных callbacks может привести к так называемому "аду колбэков" (callback hell), что делает код сложным и трудночитаемым.</p><p>Promises представляют собой более удобный способ работы с асинхронным кодом, который позволяет избежать "ада колбэков". Promise - это объект, который может находиться в одном из трех состояний: ожидание (pending), выполнено (fulfilled) или отклонено (rejected). При создании Promise-объекта передается функция-исполнитель (executor), которая может вызвать методы resolve и reject для изменения состояния Promise. Затем можно привязать колбэки с помощью методов then, catch и finally, которые будут вызываться в зависимости от результата выполнения Promise.</p><p>Async/await - это более новый подход к работе с асинхронным кодом, который основан на Promise. Он позволяет использовать синтаксис синхронного кода для написания асинхронного кода. Функция, помеченная ключевым словом async, возвращает Promise, и может содержать несколько ключевых слов await, которые приостанавливают выполнение функции, пока Promise не выполнится или не отклонится. Однако, не все браузеры и окружения поддерживают async/await, поэтому в некоторых случаях может потребоваться использование библиотеки, которая предоставляет полифилл для async/await.</p><p>Каждый из этих подходов имеет свои преимущества и недостатки, и выбор зависит от конкретной задачи и предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Можно ли записывать новые свойства/функции в прототипы стандартных классов (Array, Object и т.п.)? Почему нет? В каких случаях это делать можно? Как обезопасить себя, если нужно расширить прототип?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, можно записывать новые свойства/функции в прототипы стандартных классов, но это не рекомендуется делать, так как это может привести к непредсказуемому поведению кода и конфликтам при работе с библиотеками или другими разработчиками.</p><p>Расширять прототип можно в случаях, когда требуется добавить новые методы, которые будут использоваться только внутри конкретного приложения и не будут конфликтовать с уже существующими методами.</p><p>Чтобы обезопасить себя, если нужно расширять прототип, можно использовать следующий подход:</p><ol><li><p>Создать новый класс, который будет наследовать стандартный класс (например, создать свой класс Array, который будет наследовать стандартный Array).</p></li><li><p>Расширить прототип своего нового класса, добавив в него новые методы.</p></li><li><p>Использовать свой новый класс вместо стандартного класса.</p></li></ol><p>Такой подход позволит расширять функциональность стандартных классов без риска конфликтов и непредсказуемого поведения кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Назовите методы массивов, которые помните, и скажите, для чего они нужны.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>map - возвращает новый массив с результатами вызова функции для каждого элемента массива.
    filter - возвращает новый массив, содержащий все элементы, для которых вызов функции возвращает true.
    reduce - применяет функцию к каждому элементу массива и накапливает результаты в одно значение.
    forEach - вызывает функцию для каждого элемента массива.
    sort - сортирует элементы массива.
    indexOf - возвращает индекс первого найденного элемента в массиве.
    slice - возвращает новый массив, содержащий копию части исходного массива.
    push - добавляет один или несколько элементов в конец массива.
    pop - удаляет последний элемент массива.</p>
    <ul>
    <li>find() - возвращает первый элемент массива, удовлетворяющий заданному условию в функции-аргументе.</li>
    <li>includes() - проверяет, содержит ли массив заданный элемент, и возвращает true или false.</li>
    <li>fill() - заполняет все элементы массива одним значением, начиная с указанного индекса и заканчивая другим индексом (опционально).</li>
    <li>flat() - создает новый массив, в котором все подмассивы внутри исходного массива "выравниваются" до указанной глубины.</li>
    <li>some() - проверяет, удовлетворяет ли хотя бы один элемент массива заданному условию в функции-аргументе, и возвращает true или false.</li>
    <li>every() - проверяет, удовлетворяют ли все элементы массива заданному условию в функции-аргументе, и возвращает true или false.</li></ul>
    <li>splice(): изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые элементы.</li>
    <li>map(): создает новый массив с результатами вызова указанной функции для каждого элемента массива.</li>
    </ul></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Как работают операторы присвоения/ сравнения/ строковые/ арифметические/ битовые и т.п.?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Операторы в JavaScript предназначены для выполнения различных операций над значениями и переменными.</p><p>Оператор присвоения (=) используется для присваивания значения правой части выражения левой переменной.</p><p>Операторы сравнения (==, ===, !=, !==, &gt;, &gt;=, &lt;, &lt;=) используются для сравнения значений и типов данных. Оператор == выполняет нестрогое равенство, приводя типы данных при необходимости, а оператор === выполняет строгое равенство без приведения типов. Операторы сравнения возвращают логическое значение true или false.</p><p>Операторы арифметических действий (+, -, *, /, %) используются для выполнения математических операций над числами. Оператор % возвращает остаток от деления.</p><p>Операторы строковых операций (+) используются для конкатенации строк.</p><p>Операторы битовых операций (&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;) используются для выполнения операций над двоичными числами.</p><p>При использовании операторов необходимо учитывать приоритет операций и правила выполнения выражений, например, выражения в скобках выполняются в первую очередь. Также стоит учитывать особенности работы операторов со значениями различных типов, например, при сложении числа и строки происходит конкатенация строк.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>в какую сторону работают операторы если оепраторов несколько?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Если в выражении используется несколько операторов с одинаковым приоритетом, то они выполняются слева направо, за исключением операторов присваивания, которые выполняются справа налево. Если в выражении используются операторы с разным приоритетом, то операторы с более высоким приоритетом выполняются раньше. Если порядок вычислений необходимо изменить, можно использовать скобки.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Опишите назначение и принципы работы с коллекциями Map и Set</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Map и Set являются коллекциями в JavaScript, которые позволяют хранить уникальные значения. Map представляет собой коллекцию пар ключ-значение, в то время как Set хранит только уникальные значения.</p><p>Принцип работы с Map заключается в том, что каждый элемент коллекции имеет уникальный ключ, который используется для получения значения элемента. Принцип работы с Set заключается в том, что каждый элемент коллекции уникален, и вы можете проверять наличие элемента в Set с помощью метода has(). Обе коллекции также предоставляют методы для добавления, удаления и получения элементов.</p><p>Основное назначение Map и Set заключается в том, чтобы предоставить эффективный способ хранения данных и выполнения операций с ними. Они часто используются в приложениях, которые требуют быстрого доступа к данным, таких как поисковые системы и базы данных.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Глубокая (deep) копия объекта создает копию объекта и всех его вложенных объектов, тогда как поверхностная (shallow) копия копирует только ссылки на вложенные объекты. При изменении вложенных объектов в глубокой копии оригинал остается неизменным, в то время как в поверхностной копии изменения будут отражены и в оригинальном объекте.</p><p>Для создания поверхностной копии объекта можно использовать метод <code>Object.assign()</code>, который создает новый объект, содержащий все свойства исходного объекта. Для создания глубокой копии объекта нужно рекурсивно скопировать все его свойства и свойства вложенных объектов.</p><p>Например, чтобы создать глубокую копию объекта <code>obj</code>, можно использовать следующую функцию:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-keyword">if</span> (obj === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">"object"</span>) {
          <span class="hljs-keyword">return</span> obj;
        }
        <span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? [] : {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) {
          copy[key] = <span class="hljs-title function_">deepCopy</span>(obj[key]);
        }
        <span class="hljs-keyword">return</span> copy;
      }
      </code></div></div></pre><p>Для создания поверхностной копии объекта <code>obj</code> можно использовать следующий код:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> shallowCopy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj);
      </code></div></div></pre></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какая разница между декларацией функции (function declaration) и функциональным выражением (function expression)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между декларацией функции и функциональным выражением заключается в способе определения функции и времени доступности.</p><p>Декларация функции (function declaration) определяет функцию внутри блока кода и делает ее доступной во всей области видимости блока. Функцию можно вызывать до ее определения в коде, так как она поднимается (hoisted) в начало блока.</p><p>Функциональное выражение (function expression) определяет функцию как часть выражения и присваивает ее переменной. Функция становится доступной только после выполнения строки кода, в которой она была определена.</p><p>Например, декларация функции выглядит так:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      }
      </code></div></div></pre><p>А функциональное выражение так:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      };
      </code></div></div></pre><p>Выбор между декларацией функции и функциональным выражением зависит от контекста использования и предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое анонимная функция?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Анонимная функция в JavaScript - это функция, которая не имеет имени и может быть определена как выражение или передана как аргумент в другую функцию. Она не обязательно должна быть присвоена переменной или объявлена как отдельная функция.</p><p>Пример анонимной функции в виде выражения:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> greeting = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello!"</span>);
      };
      </code></div></div></pre><p>Анонимные функции часто используются в качестве обратных вызовов (callbacks) при передаче функции в качестве аргумента другой функции, например:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Delayed message"</span>);
      }, <span class="hljs-number">1000</span>);
      </code></div></div></pre><p>Также анонимные функции могут быть определены непосредственно при выполнении кода:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"IIFE - Immediately Invoked Function Expression"</span>);
      })();
      </code></div></div></pre><p>Анонимные функции полезны, когда требуется определить функцию в конкретном контексте, избегая создания отдельного идентификатора для функции, которая используется только один раз.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Расскажите о стрелковых функциях (arrow function). В чем заключаются отличия стрелковых функций от обычных?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Стрелковые функции (arrow functions) в JavaScript представляют сокращенный синтаксис для определения функций. Они имеют некоторые отличия от обычных (анонимных) функций:</p><ol><li><p>Стрелковые функции не имеют своего собственного контекста выполнения (<code>this</code>). Они используют лексическое окружение для определения значения <code>this</code>, которое наследуется от родительского контекста. В обычных функциях <code>this</code> определяется во время выполнения функции и может меняться.</p></li><li><p>Стрелковые функции не имеют своего собственного ключевого слова <code>arguments</code> для доступа к аргументам функции. Вместо этого можно использовать спред-оператор <code>...args</code> для получения всех аргументов.</p></li><li><p>Стрелковые функции всегда анонимны, то есть они не имеют имени и не могут быть использованы в качестве конструкторов для создания объектов.</p></li><li><p>Стрелковые функции могут быть более компактными, особенно при отсутствии необходимости в большом теле функции или при использовании одного выражения.</p></li></ol><p>Пример стрелковой функции:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;
    </code></div></div></pre><p>В общем, стрелковые функции предоставляют более краткий и удобный синтаксис для определения функций, особенно при работе с простыми выражениями и избегании проблем, связанных с контекстом <code>this</code>.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>IIFE (Immediately Invoked Function Expression) - это выражение функции, которое вызывается немедленно после своего определения. Оно используется для создания локальной области видимости и изоляции переменных от глобальной области видимости.</p><p>Преимущества использования IIFE:</p><ol><li><p>Изоляция переменных: IIFE создает свою собственную область видимости, что позволяет объявлять переменные, не засоряя глобальную область видимости. Это помогает предотвратить конфликты и неожиданное переопределение переменных.</p></li><li><p>Защита данных: Поскольку переменные, объявленные внутри IIFE, недоступны извне, это позволяет сохранять данные в приватной области видимости и предотвращает их нежелательное изменение.</p></li><li><p>Модульность: IIFE используется для создания модульного кода. Он может содержать логику, функции и переменные, связанные с конкретным модулем, и предоставлять только необходимые интерфейсы для взаимодействия с внешним кодом.</p></li></ol><p>Пример IIFE:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// Код внутри IIFE</span>
      })();
      </code></div></div></pre><p>IIFE можно использовать для выполнения определенной инициализации, настройки или выполнения кода в момент загрузки скрипта, а также для создания самовызывающихся функций, которые выполняются только один раз при загрузке страницы.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое hoisting, как он работает для переменных и функций?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Hoisting (поднятие) в JavaScript означает, что объявления переменных и функций перемещаются в начало их области видимости во время компиляции, независимо от их фактического расположения в коде. Это позволяет использовать переменные и функции до их объявления.</p><p>Для переменных:
    При hoisting переменные объявлены с помощью ключевых слов <code>var</code> или <code>let</code> перемещаются в начало своей области видимости. Однако, само присваивание значения переменной остается на момент, где оно было выполнено.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// undefined</span>
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
    </code></div></div></pre><p>Для функций:
    При hoisting функции, объявленные с помощью ключевого слова <code>function</code>, перемещаются в начало своей области видимости, поэтому их можно вызывать до их фактического объявления.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// "Hello"</span>
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Hello"</span>);
    }
    </code></div></div></pre><p>Однако, стрелковые функции (arrow functions) не подвержены hoisting, так как они являются выражениями и не имеют своего собственного объявления.</p><p>Важно отметить, что hoisting применяется только к объявлениям переменных и функций, а не к их инициализации или присваиванию значений. Поэтому рекомендуется всегда объявлять переменные и функции перед их использованием, чтобы избежать путаницы и неожиданного поведения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое замыкание (closure) и какие сценарии его использования?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Замыкание (closure) в JavaScript - это комбинация функции и лексического окружения, в котором эта функция была объявлена. Оно позволяет функции запоминать и иметь доступ к переменным из своего лексического окружения, даже после того, как это окружение было завершено.</p><p>Замыкания особенно полезны в следующих сценариях:</p><ol><li><p>Использование приватных переменных: Замыкания позволяют создавать переменные, недоступные извне функции, и сохранять их состояние между вызовами функции.</p></li><li><p>Работа с функциями обратного вызова (callbacks): Замыкания позволяют передавать функции обратного вызова с доступом к локальным переменным функции-родителя, что делает код более гибким и модульным.</p></li><li><p>Создание модульного кода: Замыкания позволяют создавать модули, скрывая детали реализации и предоставляя только необходимые интерфейсы.</p></li><li><p>Создание задержек и асинхронных операций: Замыкания могут использоваться для создания задержек с доступом к локальным переменным их окружения.</p></li></ol><p>Пример использования замыкания:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
      
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
          count++;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);
        };
      }
      
      <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
      <span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span>
      <span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span>
      </code></div></div></pre><p>Здесь функция <code>createCounter</code> создает и возвращает замыкание, которое имеет доступ к переменной <code>count</code> даже после завершения выполнения <code>createCounter</code>. Это позволяет создать счетчик с сохранением состояния между вызовами.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое рекурсия?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Рекурсия - это процесс, когда функция вызывает саму себя в своем теле. Когда функция вызывается рекурсивно, новые экземпляры функции создаются и выполняются с новыми наборами аргументов. Рекурсия обычно используется для решения задач, которые могут быть разбиты на более простые подзадачи.</p><p>Пример простой рекурсивной функции - вычисление факториала:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) {
        <span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);
        }
      }
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>
      </code></div></div></pre><p>В этом примере функция <code>factorial</code> вызывает саму себя с аргументом <code>n - 1</code> до тех пор, пока не достигнет базового случая, когда <code>n</code> равно 0. Затем функция начинает возвращать результаты, возвращая умножение <code>n</code> на результат рекурсивного вызова. Рекурсия позволяет нам выразить сложные задачи в терминах более простых подзадач, упрощая их решение. Однако необходимо быть осторожным, чтобы избежать бесконечной рекурсии и убедиться в наличии условия выхода из рекурсии.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что означает ключевое слово this?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ключевое слово <code>this</code> в JavaScript используется для обращения к текущему объекту, в контексте которого выполняется код. Значение <code>this</code> определяется во время выполнения и зависит от того, как вызывается функция.</p><ol><li><p>В методах объекта: <code>this</code> ссылается на сам объект, в котором определен метод. Используется для доступа к свойствам и методам объекта.</p></li><li><p>В глобальной области видимости или в функциях: <code>this</code> ссылается на глобальный объект (например, <code>window</code> в браузере или <code>global</code> в Node.js). Если в строгом режиме (<code>"use strict"</code>) - <code>this</code> будет <code>undefined</code>.</p></li><li><p>В конструкторах: <code>this</code> ссылается на создаваемый экземпляр объекта. Когда функция вызывается с использованием оператора <code>new</code>, <code>this</code> будет указывать на новый объект.</p></li><li><p>При использовании <code>call</code>, <code>apply</code> или <code>bind</code>: <code>this</code> можно явно привязать к определенному объекту.</p></li><li><p>В обработчиках событий: <code>this</code> ссылается на элемент DOM, на котором произошло событие.</p></li></ol><p>Значение <code>this</code> может быть изменено с помощью различных методов, поэтому его значение следует тщательно учитывать при написании кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое потеря контекста, когда происходит и как ее предотвратить?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Потеря контекста в JavaScript происходит, когда функция теряет доступ к своему ожидаемому значению <code>this</code>. Это может произойти при передаче функции по отдельности без контекста, использовании колбэков, применении функций высшего порядка или при вызове функции внутри другой функции.</p><p>Чтобы предотвратить потерю контекста, можно использовать следующие подходы:</p><ol><li><p>Использование стрелочных функций: Стрелочные функции не создают собственного контекста <code>this</code> и наследуют его от родительской области видимости.</p></li><li><p>Привязка контекста с помощью методов <code>bind</code>, <code>call</code> или <code>apply</code>: Эти методы позволяют явно привязать значение <code>this</code> к функции.</p></li><li><p>Использование замыканий: Создание замыкания, в котором сохраняется доступ к нужному контексту, позволяет избежать потери контекста.</p></li><li><p>Использование строго режима (<code>"use strict"</code>): Строгий режим изменяет поведение <code>this</code>, делая его <code>undefined</code> вместо глобального объекта, что помогает выявить потенциальные ошибки.</p></li><li><p>Использование синтаксиса ES6 классов: Классы в JavaScript автоматически привязывают методы к контексту экземпляра класса.</p></li></ol><p>Выбор определенного подхода зависит от конкретной ситуации и требований вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Методы функций bind / call / apply — зачем и в чем разница?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Методы <code>bind</code>, <code>call</code> и <code>apply</code> в JavaScript используются для управления контекстом выполнения функции и передачи аргументов.</p><ul><li><p><code>bind</code>: Создает новую функцию с привязанным контекстом (значением <code>this</code>), которая может быть вызвана позже. Возвращает функцию.</p></li><li><p><code>call</code>: Вызывает функцию, указывая конкретный контекст (значение <code>this</code>) и передавая аргументы в виде списка через запятую. Выполняет функцию немедленно.</p></li><li><p><code>apply</code>: Вызывает функцию, указывая конкретный контекст (значение <code>this</code>) и передавая аргументы в виде массива. Выполняет функцию немедленно.</p></li></ul><p>Основная разница между <code>call</code> и <code>apply</code> заключается в том, как аргументы передаются функции. <code>call</code> принимает аргументы в виде списка, в то время как <code>apply</code> принимает аргументы в виде массива.</p><p>Эти методы полезны, когда нужно вызвать функцию с определенным контекстом или передать аргументы, которые не известны заранее. Например, они часто используются для вызова методов других объектов с определенным контекстом или для использования методов с неизвестным количеством аргументов.</p><p>Применение конкретного метода зависит от контекста и требований вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое DOM?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>DOM (Document Object Model) - это представление HTML- или XML-документа в виде дерева объектов, которое браузер использует для представления веб-страницы. DOM предоставляет программный интерфейс для доступа и изменения элементов, атрибутов и содержимого документа.</p><p>DOM представляет каждый элемент HTML или XML-документа в виде объекта, который имеет свои свойства и методы. Эти объекты объединены в иерархическую структуру, где каждый элемент является дочерним или родительским относительно других элементов. Таким образом, DOM позволяет программистам манипулировать структурой, стилями и содержимым веб-страницы с помощью JavaScript.</p><p>С использованием DOM можно создавать, удалять и изменять элементы, атрибуты, текст и стили на веб-странице. Также можно прослушивать события, выполнять валидацию данных и многое другое.</p><p>DOM является основой для работы с динамическим содержимым и взаимодействием с веб-страницей при разработке на фронтенде с использованием JavaScript.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Сравните атрибуты подключения скрипта async и defer в HTML-документ</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Атрибуты <code>async</code> и <code>defer</code> используются для управления асинхронной загрузкой скриптов в HTML-документе.</p><ul><li><p><code>async</code>: Скрипт будет выполняться асинхронно во время загрузки страницы. Это означает, что он не блокирует парсинг HTML-документа и не останавливает загрузку других элементов страницы. Скрипт выполнится как только загрузится, и порядок выполнения скриптов может быть непредсказуемым. Рекомендуется использовать <code>async</code> для скриптов, которые не зависят от других скриптов и не требуют доступа к DOM-элементам при загрузке.</p></li><li><p><code>defer</code>: Скрипт будет выполняться после того, как HTML-документ будет полностью загружен, но перед событием <code>DOMContentLoaded</code>. Скрипты с атрибутом <code>defer</code> сохраняют порядок выполнения относительно друг друга. Их выполнение происходит после парсинга HTML, но до завершения построения DOM-дерева. Рекомендуется использовать <code>defer</code> для скриптов, которые зависят от DOM-структуры и требуют доступа к DOM-элементам.</p></li></ul><p>Оба атрибута полезны для ускорения загрузки страницы и улучшения производительности. Выбор между <code>async</code> и <code>defer</code> зависит от того, какой момент выполнения скрипта является критическим для вашего кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какая разница между свойствами HTML-элементов innerHTML и innerText?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между свойствами <code>innerHTML</code> и <code>innerText</code> заключается в том, как они обрабатывают содержимое HTML-элементов.</p><ul><li><p><code>innerHTML</code>: Свойство <code>innerHTML</code> возвращает или устанавливает HTML-код внутри элемента, включая все его потомки. Это позволяет добавлять, изменять или удалять HTML-структуры и элементы внутри выбранного элемента. Оно также позволяет внедрять JavaScript-код и стили внутри элемента.</p></li><li><p><code>innerText</code>: Свойство <code>innerText</code> возвращает или устанавливает текстовое содержимое элемента без учета HTML-тегов. Оно игнорирует все HTML-структуры и элементы внутри элемента и возвращает только видимый текст. При установке значения <code>innerText</code> все HTML-теги будут отброшены, а вместо них будет установлен чистый текст.</p></li></ul><p>Если вам нужно работать с HTML-структурами, добавлять или изменять элементы, используйте <code>innerHTML</code>. Если вам нужно получить только текстовое содержимое элемента без учета HTML-тегов, используйте <code>innerText</code>. Оба свойства полезны в различных сценариях, и выбор зависит от требований вашего приложения или задачи.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Опишите процесс всплытия (bubbling) событий в DOM</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Всплытие событий (bubbling) в DOM — это процесс, при котором событие, вызванное на определенном элементе, распространяется вверх по иерархии его родительских элементов.</p><p>Когда событие происходит на вложенном элементе, оно сначала обрабатывается на самом вложенном элементе, затем переходит к его родителю, затем к родителю родителя и так далее, пока не достигнет корневого элемента (обычно это <code>document</code>).</p><p>Этот механизм позволяет обрабатывать события на разных уровнях иерархии элементов. Например, если у вас есть кнопка внутри блока, и оба элемента имеют обработчики события клика, сначала будет вызван обработчик события на кнопке, а затем обработчик на блоке.</p><p>Всплытие событий можно прервать с помощью метода <code>event.stopPropagation()</code>. Это предотвращает дальнейшее распространение события вверх по иерархии элементов.</p><p>Всплытие событий полезно, когда требуется обрабатывать события на разных уровнях вложенности элементов и использовать делегирование событий для эффективной обработки множества элементов с одним и тем же типом события.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как остановить дефолтную обработку события?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для остановки дефолтной обработки события в JavaScript можно использовать метод <code>event.preventDefault()</code>. Этот метод вызывается в обработчике события и предотвращает выполнение стандартного действия, связанного с событием.</p><p>Например, если у вас есть ссылка (<code>&lt;a&gt;</code> элемент) и вы хотите отменить переход по этой ссылке при клике на нее, вы можете добавить обработчик события и вызвать <code>event.preventDefault()</code>. Это предотвратит переход по ссылке и позволит вам выполнить свою кастомную логику в обработчике события.</p><p>Метод <code>event.preventDefault()</code> работает для различных типов событий, таких как клик, отправка формы, нажатие клавиши и другие. Он является мощным инструментом для контроля над поведением событий и позволяет предотвратить стандартные действия браузера, пока вы выполняете свою специфическую обработку события.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое LocalStorage и SessionStorage? Каков максимальный размер LocalStorage?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>LocalStorage и SessionStorage - это механизмы хранения данных в веб-браузере.</p><p>LocalStorage - это персистентное хранилище данных, которое сохраняет данные после закрытия браузера и доступно для использования в любой вкладке или окне браузера. Данные в LocalStorage сохраняются на неопределенное время, пока не будут явно удалены или очищены.</p><p>SessionStorage - это хранилище данных, связанное с текущей сессией пользователя. Данные в SessionStorage доступны только в пределах текущей сессии, и они удаляются, когда пользователь закрывает вкладку или окно браузера.</p><p>Максимальный размер LocalStorage зависит от браузера, но обычно составляет около 5 МБ. Это значительно больше, чем размер куки, и позволяет хранить большое количество данных на стороне клиента без отправки их на сервер. Однако, стоит помнить, что доступ к LocalStorage и SessionStorage ограничен областью видимости домена, в котором они созданы.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Как получить высоту блока? Его положения о границах документа?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Чтобы получить высоту блока в JavaScript, вы можете использовать свойство <code>offsetHeight</code> или метод <code>getBoundingClientRect().height</code>. <code>offsetHeight</code> возвращает высоту блока, включая вертикальные границы, поля и прокрутку, если она есть. <code>getBoundingClientRect().height</code> возвращает высоту блока без учета вертикальных границ и прокрутки.</p><p>Чтобы получить положение блока относительно границ документа, вы можете использовать свойство <code>offsetTop</code>. Оно возвращает расстояние от верхней границы блока до верхней границы родительского элемента или верхней границы документа, если родительского элемента нет.</p><p>Примеры:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">var</span> block = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myBlock'</span>);
    <span class="hljs-keyword">var</span> height = block.<span class="hljs-property">offsetHeight</span>; <span class="hljs-comment">// Получить высоту блока</span>
    <span class="hljs-keyword">var</span> position = block.<span class="hljs-property">offsetTop</span>; <span class="hljs-comment">// Получить положение блока относительно границ документа</span>
    </code></div></div></pre><p>Обратите внимание, что данные значения могут быть в пикселях или других единицах измерения в зависимости от настроек CSS.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое webpack?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Webpack - это инструмент сборки (бандлера) для JavaScript-приложений. Он позволяет объединять и упаковывать различные модули и ресурсы вашего проекта в единый файл или набор файлов, которые могут быть развернуты на сервере.</p><p>Webpack предоставляет мощные возможности, такие как управление зависимостями, минификация и оптимизация кода, использование препроцессоров CSS и многое другое. Он также поддерживает использование различных загрузчиков и плагинов, которые расширяют его функциональность и позволяют настраивать процесс сборки под конкретные потребности проекта.</p><p>Webpack особенно полезен для разработки современных веб-приложений, использующих модульную архитектуру и множество зависимостей. Он упрощает управление и развертывание кода, улучшает производительность и обеспечивает лучшую поддержку различных функциональностей, таких как загрузка кода по требованию (code splitting), использование новых возможностей ECMAScript и другие.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Чем отличается dev-сборка от prod?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Dev-сборка (development-сборка) и Prod-сборка (production-сборка) представляют два различных варианта сборки проекта с использованием инструментов сборки, таких как Webpack.</p><p>Dev-сборка предназначена для разработки и обладает рядом особенностей. Она обычно включает в себя дополнительную отладочную информацию, не минифицирует код, сохраняет исходные исходники, не выполняет некоторые оптимизации и может быть медленнее в работе. Dev-сборка также может включать функции разработчика, такие как Hot Module Replacement (HMR), которые обеспечивают мгновенное обновление кода без перезагрузки страницы.</p><p>Prod-сборка предназначена для продакшн-окружения. Она оптимизирует код, удаляет ненужные файлы, минифицирует и объединяет ресурсы, чтобы улучшить производительность и снизить размер файлов. Prod-сборка обычно исключает отладочную информацию и другие необходимые для разработки артефакты, чтобы уменьшить размер и повысить быстродействие приложения.</p><p>Отличие между dev-сборкой и prod-сборкой заключается в том, что dev-сборка предоставляет комфортную среду разработки с расширенными возможностями, в то время как prod-сборка оптимизирована для максимальной производительности и минимального размера для развертывания в продакшн-среде.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое блочная модель CSS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Блочная модель CSS — это основной принцип организации и расположения элементов на веб-странице с использованием CSS. Она определяет, как элементы HTML отображаются и взаимодействуют друг с другом внутри блоков.</p><p>Блочная модель состоит из нескольких компонентов: контент (содержимое элемента), отступы (пространство вокруг контента), границы (линии вокруг элемента), и заполнение (пространство между контентом и границами). Все эти компоненты вместе определяют полный размер и расположение элемента на странице.</p><p>Блочная модель позволяет управлять размерами и пространствами вокруг элементов с помощью CSS свойств, таких как width, height, margin, padding, border и других. Правильное использование блочной модели помогает создавать гибкий и удобочитаемый макет веб-страницы, а также контролировать внешний вид и расположение элементов.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какие способы центрирования блочного контента по горизонтали и вертикали знаете?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для центрирования блочного контента по горизонтали и вертикали можно использовать следующие способы:</p><ol><li><p>Центрирование по горизонтали:</p><ul><li>Установка свойства "margin" со значением "auto" для левого и правого отступов элемента.</li><li>Использование свойства "text-align" со значением "center" для родительского элемента.</li></ul></li><li><p>Центрирование по вертикали:</p><ul><li>Использование флексбоксов (flexbox) с помощью свойства "display: flex" для родительского элемента и свойства "align-items: center" для выравнивания по центру по вертикали.</li><li>Использование позиционирования и трансформации: задание свойств "position: absolute" и "transform: translateY(-50%)" для дочернего элемента, а также свойств "top: 50%" и "left: 50%" для родительского элемента.</li></ul></li></ol><p>Конкретный выбор метода центрирования зависит от контекста и требований проекта.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие подходы вам известны (float, flex, grid, etc)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые из подходов для создания макетов и расположения элементов в CSS:</p><ol><li><p>Float: Используется для обтекания элементами текста. Элементы плавают влево или вправо, создавая многоколоночный макет. Не рекомендуется для сложных макетов.</p></li><li><p>Flexbox: Гибкий контейнер, позволяющий управлять расположением элементов внутри него по горизонтали или вертикали. Удобен для создания одномерных макетов.</p></li><li><p>CSS Grid: Мощный инструмент для создания двумерных макетов. Позволяет определить сетку из ячеек и управлять их размещением. Обладает более сложным синтаксисом, но предоставляет больше гибкости.</p></li><li><p>Positioning: Использование свойств position, top, left, right, bottom для точного позиционирования элементов на странице. Может быть полезным для создания сложных макетов, но требует аккуратного управления.</p></li><li><p>CSS Columns: Позволяет разбить текстовое содержимое на колонки, упрощая создание многоколоночных макетов.</p></li></ol><p>Каждый подход имеет свои особенности и применяется в зависимости от требований проекта. Часто комбинируются несколько подходов для достижения нужного результата.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как сделать приложение responsive?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для создания responsive приложения следует использовать следующие подходы:</p><ol><li>Адаптивная вёрстка: Используйте медиа-запросы, чтобы изменять стили и макет в зависимости от размера экрана.</li><li>Гибкая сетка: Используйте систему сетки (например, Flexbox или CSS Grid) для создания гибкого и адаптивного макета.</li><li>Fluid Images: Установите максимальную ширину для изображений, чтобы они масштабировались пропорционально размеру контейнера.</li><li>Mobile-First: Разрабатывайте сначала для мобильных устройств, затем наращивайте функциональность и стили для больших экранов.</li><li>Responsive Typography: Используйте относительные единицы измерения (например, em или rem) для текста, чтобы он масштабировался вместе с контейнером.</li><li>Тестирование на разных устройствах: Проверьте своё приложение на разных устройствах и в браузерах с помощью инструментов разработчика.</li></ol><p>Обратите внимание, что responsive дизайн - это итеративный процесс, требующий тестирования и оптимизации для разных устройств и экранов.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т.д.)?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Префиксы для CSS-свойств (-webkit-, -moz-, и т.д.) используются для поддержки экспериментальных или вендорных свойств, которые ещё не полностью стандартизированы или не поддерживаются всеми браузерами. Они позволяют разработчикам использовать новые возможности CSS, не дожидаясь окончательной спецификации.</p><p>Когда браузер видит свойство с префиксом, он понимает, что это экспериментальная или вендорная возможность, и обрабатывает его соответствующим образом. Если браузер поддерживает эту возможность, то свойство с префиксом будет применено. Если браузер не поддерживает свойство с префиксом, он просто проигнорирует его.</p><p>По мере развития стандартов CSS и установления браузерных реализаций, префиксы становятся менее необходимыми. В идеале, разработчики должны использовать безпрефиксные версии свойств, когда они становятся доступными, и удалять устаревшие префиксы для поддержки современных браузеров.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как упростить написание кроссбраузерных стилей?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для упрощения написания кроссбраузерных стилей веб-разработчики могут использовать следующие подходы:</p><ol><li><p>Использование CSS-фреймворков, таких как Bootstrap или Foundation, которые предоставляют готовые стили и компоненты, с учетом кроссбраузерности.</p></li><li><p>Использование CSS-препроцессоров, таких как Sass или Less, которые позволяют использовать переменные, миксины и другие возможности для более эффективной и организованной разработки стилей.</p></li><li><p>Использование CSS-полифиллов, которые предоставляют эмуляцию новых возможностей CSS для старых браузеров. Например, можно использовать полифиллы для CSS Grid или Flexbox.</p></li><li><p>Использование автоматических инструментов, таких как Autoprefixer, который добавляет вендорные префиксы автоматически на основе данных о поддержке браузерами.</p></li><li><p>Тестирование в различных браузерах и устройствах, чтобы убедиться, что стили отображаются корректно и согласно ожиданиям.</p></li></ol><p>Комбинация этих подходов поможет упростить написание кроссбраузерных стилей и обеспечить более однородное отображение вашего веб-сайта на разных платформах и браузерах.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что такое CSS-препроцессоры? С какими работали? Что нового они приносят в стандартный CSS?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>CSS-препроцессоры - это инструменты, которые расширяют возможности стандартного CSS, добавляя переменные, функции, миксины и другие функциональности. Они позволяют разработчикам писать более организованный и модульный CSS-код.</p><p>Некоторые из известных CSS-препроцессоров:</p><ol><li><p>Sass (Syntactically Awesome Style Sheets): Я работал с Sass. Он предлагает множество возможностей, включая переменные, миксины, вложенность правил, операции и импорт файлов.</p></li><li><p>Less (Leaner CSS): Less предлагает подобные функциональности как Sass, также имеет синтаксис похожий на CSS.</p></li><li><p>Stylus: Stylus имеет более гибкий синтаксис, позволяющий писать CSS с использованием минимального количества скобок и точек с запятой.</p></li></ol><p>CSS-препроцессоры помогают в разработке более эффективного и переиспользуемого CSS-кода, упрощают поддержку и обновление стилей, а также обеспечивают лучшую организацию проекта. Они также предлагают возможности, которых нет в стандартном CSS, такие как миксины, которые позволяют повторно использовать блоки стилей, и переменные, которые упрощают изменение значений в нескольких местах одновременно.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Работали ли с классовыми компонентами? В чем их особенность?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, я работал с классовыми компонентами в React. Основная особенность классовых компонентов заключается в том, что они используют классы ES6 для определения компонента и наследования от базового класса React.Component. Они имеют встроенное состояние (state) и могут обрабатывать жизненный цикл компонента, такие как componentDidMount, componentDidUpdate и т.д.</p><p>Классовые компоненты обладают большей функциональностью и гибкостью по сравнению с функциональными компонентами. Они позволяют использовать локальное состояние, создавать методы и обрабатывать события. Они также предоставляют возможность использовать компоненты высшего порядка (HOC) и расширять функциональность компонентов с помощью наследования.</p><p>Однако с появлением React Hooks классовые компоненты стали менее рекомендуемым подходом, так как функциональные компоненты с хуками предлагают более простой и декларативный способ написания компонентов. Hooks позволяют использовать состояние и другие функциональности ранее доступные только в классовых компонентах без необходимости использовать классы и наследование.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Какие данные лучше хранить в состоянии компонента, а какие передавать через пропсы? Приведите пример.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Лучше хранить в состоянии компонента данные, которые изменяются во время работы компонента и влияют на его внутреннее состояние или внешний вид. Например, пользовательский ввод, текущая страница, открытое/закрытое состояние модального окна и т.д.</p><p>Данные, которые не изменяются внутри компонента и передаются извне, лучше передавать через пропсы. Пропсы обычно используются для передачи данных от родительского компонента к дочернему компоненту. Например, список элементов, параметры конфигурации и обработчики событий.</p><p>Пример: Предположим, у нас есть компонент <code>TodoList</code>, который отображает список задач. Список задач будет передан в <code>TodoList</code> через пропсы, так как он не будет изменяться внутри компонента. Однако, текущая выбранная задача будет храниться в состоянии компонента, так как она может изменяться в результате взаимодействия пользователя с компонентом.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Ознакомлены ли с хуками? В чем их преимущества? Приходилось ли делать свои и с какой целью?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, ознакомлен с хуками в React. Преимущества хуков включают удобство и гибкость при работе с состоянием и жизненным циклом компонентов. Они позволяют использовать функциональные компоненты с возможностью управления состоянием и выполнения побочных эффектов.</p><p>Да, приходилось создавать свои хуки. Это позволяет абстрагировать повторяющуюся логику и делать ее повторно используемой. Например, можно создать хук для работы с API запросами или для обработки форм. Это позволяет сократить дублирование кода и упрощает поддержку и тестирование приложения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Ознакомлены ли с фрагментами и порталами? Зачем они нужны?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, ознакомлен с фрагментами и порталами в React. Фрагменты позволяют группировать дочерние элементы без создания лишних DOM-узлов. Они полезны, когда требуется возвращать несколько элементов из компонента без оборачивания их в дополнительный контейнер.</p><p>Порталы позволяют рендерить дочерние элементы в другое место в дереве DOM. Это полезно, когда требуется разместить элементы за пределами корневого узла компонента, чтобы контролировать их позиционирование и взаимодействие с другими элементами.</p><p>Фрагменты и порталы обеспечивают более гибкую и эффективную работу с дочерними элементами в React приложениях.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Когда и для чего используют рефы?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Рефы в React используются для получения прямого доступа к DOM-элементам или компонентам внутри компонентов. Они позволяют обойти управляемую природу React и получить доступ к определенным элементам или компонентам напрямую.</p><p>Рефы полезны в следующих случаях:</p><ol><li>Получение значения полей ввода или других свойств DOM-элементов.</li><li>Фокусировка на определенном элементе после монтирования компонента.</li><li>Использование сторонних библиотек или плагинов, которые требуют доступа к DOM-элементам.</li><li>Измерение размеров или позиций элементов на странице.</li></ol><p>Однако стоит помнить, что прямой доступ к DOM может противоречить концепции управляемого состояния React, поэтому необходимо использовать рефы осторожно и только там, где это действительно необходимо.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие вы знаете методы жизненного цикла компонента?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В React есть несколько методов жизненного цикла компонента:</p><ol><li><p><code>componentDidMount()</code>: Вызывается сразу после монтирования компонента в DOM. Часто используется для инициализации данных, подписки на события или запросов к серверу.</p></li><li><p><code>componentDidUpdate(prevProps, prevState)</code>: Вызывается после обновления компонента. Позволяет реагировать на изменения пропсов или состояния и выполнить соответствующие действия.</p></li><li><p><code>componentWillUnmount()</code>: Вызывается перед удалением компонента из DOM. Здесь можно отписаться от событий, очистить ресурсы или выполнить другие завершающие операции.</p></li><li><p><code>shouldComponentUpdate(nextProps, nextState)</code>: Определяет, следует ли выполнять перерисовку компонента после обновления пропсов или состояния. Позволяет оптимизировать производительность, избегая ненужных перерисовок.</p></li><li><p><code>getDerivedStateFromProps(nextProps, prevState)</code>: Позволяет обновить состояние компонента на основе новых пропсов. Редко используется, поскольку управляемое состояние рекомендуется хранить в пропсах.</p></li><li><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>: Вызывается перед фактическим обновлением DOM. Позволяет захватить текущее состояние DOM перед его изменением.</p></li><li><p><code>constructor(props)</code>: Вызывается при создании компонента. Используется для инициализации состояния и привязки методов к контексту.</p></li></ol><p>Кроме того, введение хуков в React 16.8 предоставило новый подход к работе с жизненным циклом компонентов.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>В каком методе жизненного цикла компонента лучше делать запросы на сервер? Почему?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В методе жизненного цикла компонента, наиболее подходящем для выполнения запросов на сервер, является <code>componentDidMount()</code>.</p><p>Причина в том, что <code>componentDidMount()</code> вызывается сразу после монтирования компонента в DOM. Это означает, что компонент уже отображается на странице, и пользователю уже доступен контент. Поэтому в этом методе наиболее удобно инициировать запросы к серверу для получения данных, не прерывая процесс отображения компонента.</p><p>Такой подход позволяет избежать блокировки интерфейса и обеспечить более плавное и отзывчивое пользовательское взаимодействие. Кроме того, использование <code>componentDidMount()</code> также помогает разделить ответственность компонента, где запросы к серверу инициируются только после его полного монтирования, а не во время рендеринга.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>В каком методе жизненного цикла компонента лучше делать подписку и отписку от листенера? Почему? Зачем отписываться?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Лучше всего подписываться и отписываться от листенера в методе жизненного цикла компонента <code>componentDidMount()</code> и <code>componentWillUnmount()</code> соответственно.</p><p>Метод <code>componentDidMount()</code> вызывается сразу после монтирования компонента в DOM, поэтому он является идеальным местом для создания подписки на листенер. Здесь вы можете зарегистрировать обработчик события или подписаться на внешний источник данных.</p><p>Метод <code>componentWillUnmount()</code> вызывается перед тем, как компонент будет размонтирован и удален из DOM. В этом методе рекомендуется отписаться от листенера и выполнить другие необходимые действия для очистки ресурсов, связанных с компонентом. Отписка от листенера важна для предотвращения утечек памяти и избежания возможных ошибок, связанных с обработкой событий после удаления компонента.</p><p>Отписываясь от листенера, вы уверены, что ваш компонент не будет продолжать получать и обрабатывать события после своего размонтирования, что помогает поддерживать чистоту и надежность кода.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Был ли опыт работы с контекстом? Когда его следует использовать?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, опыт работы с контекстом был. Контекст в React представляет собой механизм передачи данных от верхнего компонента к вложенным компонентам без необходимости явной передачи через пропсы.</p><p>Контекст следует использовать, когда необходимо передать данные между компонентами, которые находятся на разных уровнях иерархии. Это позволяет избежать передачи пропсов через каждый промежуточный компонент и упрощает управление состоянием в приложении.</p><p>Однако следует использовать контекст осторожно и только в случаях, когда это действительно необходимо, так как излишнее использование контекста может привести к усложнению понимания и поддержки кода. Также важно обратить внимание на возможные проблемы с производительностью и переиспользованием компонентов при использовании контекста.</p><p>В целом, контекст в React полезен в ситуациях, когда требуется передача данных по дереву компонентов без лишней рутины передачи пропсов, но следует осторожно оценивать его использование и рассматривать альтернативные подходы, если это возможно.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>В чем особенность PureComponent?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Особенность PureComponent заключается в том, что он реализует поведение метода <code>shouldComponentUpdate</code> автоматически, сравнивая текущие и предыдущие пропсы и состояние компонента. Если эти значения не изменились, PureComponent предотвращает перерисовку компонента.</p><p>Это позволяет оптимизировать производительность приложения, уменьшая количество ненужных перерисовок компонентов. Однако, PureComponent работает только с поверхностным сравнением пропсов и состояния, поэтому он может пропустить изменения вложенных объектов или массивов.</p><p>Для правильной работы PureComponent необходимо, чтобы пропсы передавались по значению, а не по ссылке, и чтобы внутри компонента не происходило мутации состояния. Также следует учитывать, что PureComponent имеет небольшие накладные расходы на сравнение значений, поэтому его следует использовать с осторожностью и только там, где это действительно необходимо.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Работал ли с мемоизированными селекторами (memoized selectors)? Для чего их используют и какой принцип работы?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, я работал с мемоизированными селекторами. Мемоизированные селекторы - это функции, которые кэшируют результаты своих вычислений на основе входных данных (например, состояния Redux) и возвращают закэшированный результат, если входные данные не изменились.</p><p>Они используются для оптимизации производительности приложений, особенно в контексте библиотеки Redux. Мемоизированные селекторы позволяют избежать повторных вычислений и перерисовок компонентов, когда входные данные не изменились.</p><p>Принцип работы мемоизированных селекторов основан на сохранении кэша результатов вычислений и проверке изменений входных данных. Если входные данные не изменились, мемоизированный селектор возвращает закэшированный результат, минуя повторные вычисления. Если же входные данные изменились, селектор выполняет вычисления заново и обновляет кэш.</p><p>Это помогает улучшить производительность приложения, особенно при работе с большим объемом данных или сложными вычислениями, и предотвращает ненужные перерисовки компонентов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>В чем видите преимущества библиотеки React?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Преимущества библиотеки React включают:</p><ol><li><p>Компонентный подход: Реакт использует компонентный подход, который позволяет разбивать интерфейс на небольшие и переиспользуемые компоненты. Это упрощает разработку, тестирование и поддержку кода.</p></li><li><p>Виртуальный DOM: Реакт использует виртуальный DOM, который позволяет эффективно обновлять только измененные части интерфейса, минимизируя операции с реальным DOM и повышая производительность.</p></li><li><p>Односторонний поток данных: Реакт поддерживает однонаправленный поток данных, что облегчает отслеживание и управление состоянием приложения.</p></li><li><p>Разделение ответственности: Реакт позволяет разделить ответственность между разработчиками фронтенда и бэкенда, так как предоставляет возможность создания компонентов интерфейса независимо от серверной логики.</p></li><li><p>Большое сообщество: Реакт имеет активное и обширное сообщество разработчиков, что облегчает получение помощи, нахождение решений и использование готовых компонентов и библиотек.</p></li><li><p>Поддержка мобильной разработки: Реакт Native позволяет разрабатывать мобильные приложения с использованием JavaScript и React, что упрощает переиспользование кода и разработку для разных платформ.</p></li></ol><p>В целом, React предлагает эффективные инструменты для разработки пользовательских интерфейсов, повышая производительность, переиспользуемость и удобство разработки.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Почему библиотека React быстра? Что такое Virtual DOM и Shadow DOM?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Библиотека React является быстрой из-за использования виртуального DOM и своей оптимизированной реализации.</p><p>Виртуальный DOM - это внутреннее представление DOM-структуры в памяти. Реакт сравнивает виртуальный DOM с реальным DOM и эффективно обновляет только измененные части. Это минимизирует операции с реальным DOM и повышает производительность.</p><p>Shadow DOM - это спецификация веб-стандарта, которая позволяет создавать изолированные сферы для стилей и DOM-дерева. Он обеспечивает инкапсуляцию стилей и избегает конфликтов с другими стилями на странице.</p><p>React использует виртуальный DOM для оптимизации обновлений и обеспечения эффективности. При обновлении компонента React сначала обновляет виртуальный DOM, затем сравнивает его с предыдущим состоянием и применяет только необходимые изменения на реальный DOM. Это позволяет избегать ненужных манипуляций с реальным DOM и улучшает производительность приложения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Зачем в списках ключи? Можно ли делать ключами индексы элементов массива? Когда это оправдано?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ключи в списках React нужны для эффективного обновления компонентов. Ключи помогают React отслеживать изменения элементов списка и корректно обновлять только изменившиеся элементы.</p><p>Использование индексов массива в качестве ключей возможно, но не рекомендуется. Если порядок элементов может изменяться или элементы могут быть добавлены или удалены, использование индексов может привести к проблемам. При изменении порядка или добавлении/удалении элементов индексы могут не соответствовать элементам, что приведет к неправильному обновлению или потере состояния.</p><p>Рекомендуется использовать уникальные и стабильные идентификаторы в качестве ключей, такие как уникальные идентификаторы объектов данных. Это обеспечит корректное обновление списка, даже если порядок или содержимое элементов изменится.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>В чем главная идея Redux?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Главная идея Redux - управление состоянием приложения. Он предоставляет предсказуемую и однонаправленную потоку данных. В основе Redux лежит концепция единственного хранилища (store), содержащего состояние всего приложения. Компоненты не имеют собственного состояния, они получают данные из хранилища и обновляют его через действия (actions). Редюсеры (reducers) обрабатывают действия и обновляют состояние в хранилище. Компоненты могут подписываться на изменения состояния и обновляться автоматически. Это обеспечивает единообразный подход к управлению состоянием приложения и упрощает отладку и тестирование.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Работа со стилями в React.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В React стили можно работать несколькими способами. Один из них - использование CSS-классов. Компоненты могут иметь свои собственные CSS-классы, которые определяются в отдельных CSS-файлах или встроены в компоненты с помощью библиотеки styled-components. Классы могут применяться к элементам компонента с помощью атрибута <code>className</code>.</p><p>Еще один способ - использование инлайн-стилей. Вместо классов, стили задаются непосредственно внутри компонента с помощью объекта JavaScript, передаваемого через атрибут <code>style</code>. Это позволяет динамически изменять стили на основе состояния компонента или передавать их в виде пропсов.</p><p>Для усложненных случаев стилизации компонентов существуют библиотеки, такие как CSS-модули или CSS-in-JS, которые предоставляют более гибкий и мощный способ работы со стилями в React.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>React — это библиотека или фреймворк? Какая разница между этими двумя понятиями</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>React является JavaScript библиотекой для создания пользовательских интерфейсов. Разница между библиотекой и фреймворком заключается в уровне контроля и гибкости, который предоставляется разработчику.</p><p>Библиотека, такая как React, предоставляет набор инструментов и функций, которые помогают в разработке приложений, но оставляет разработчику свободу выбора и контроль над другими аспектами приложения, такими как маршрутизация, управление состоянием или HTTP-запросы.</p><p>Фреймворк, с другой стороны, предоставляет более всесторонний набор инструментов, правил и структуру для разработки приложений. Фреймворк определяет, каким образом разрабатывать приложение и предлагает готовую архитектуру, инструменты и подходы к различным аспектам приложения.</p><p>Таким образом, React является библиотекой, поскольку он предоставляет инструменты для создания пользовательских интерфейсов, но не навязывает конкретную архитектуру или подходы к другим аспектам приложения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Можно ли использовать jQuery вместе с React? Почему да/ нет?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, можно использовать jQuery вместе с React, но это не рекомендуется. React и jQuery имеют разные подходы к обновлению и управлению DOM, что может привести к конфликтам и непредсказуемому поведению. React использует виртуальный DOM и управляет обновлениями через компоненты, в то время как jQuery напрямую манипулирует существующим DOM.</p><p>Рекомендуется использовать React в чистом виде и использовать его встроенные функциональности для манипуляции с DOM, обработки событий и обновлений состояния. Если требуется использовать существующий код на jQuery, то можно попробовать интегрировать его с React с помощью специальных библиотек или плагинов, которые обеспечивают совместимость и управление конфликтами.</p><p>Однако, в большинстве случаев рекомендуется избегать использования jQuery вместе с React и полностью перейти на реактивный подход, используя нативные возможности React для работы с DOM и состоянием компонентов.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое codemod?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Codemod (code modification tool) - это инструмент, который автоматизирует изменение кодовой базы программного проекта. Он позволяет совершать массовые изменения в исходном коде, например, заменять устаревшие API, внедрять новые практики программирования или обновлять синтаксис языка.</p><p>Codemodы часто используются для миграции кода на новые версии библиотек, фреймворков или языков программирования. Они позволяют автоматически применить необходимые изменения к большому количеству файлов, что экономит время и уменьшает вероятность ошибок.</p><p>Codemodы работают на основе анализа и преобразования абстрактного синтаксического дерева (AST) исходного кода. Они могут использовать различные методы обхода и модификации AST, например, с помощью плагинов или шаблонов.</p><p>Codemodы являются мощным инструментом для автоматизации изменений в кодовой базе, повышая эффективность и однородность разработки и обновления программного обеспечения.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Приходилось ли настраивать проект React с нуля? С помощью каких инструментов вы это делали?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, приходилось настраивать проект React с нуля. Для этого я использовал инструменты, такие как Create React App (CRA) или webpack с настройкой конфигурации вручную. CRA предоставляет готовую структуру проекта и предконфигурированные инструменты сборки, что упрощает начало работы. С другой стороны, настройка проекта с помощью webpack дает больше гибкости и позволяет более тонко настроить сборку и работу с модулями, стилями и другими ресурсами. Выбор инструментов зависит от требований проекта и предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Перечислите все библиотеки, которые использовали в связке с React.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В связке с React я использовал следующие библиотеки: React Router для маршрутизации в приложении, Redux для управления состоянием, Axios для работы с HTTP-запросами, Styled Components для стилизации компонентов, Formik для управления формами, React-Bootstrap для использования готовых компонентов интерфейса, Moment.js для работы с датами и временем. Конечно, выбор библиотек зависит от требований проекта и индивидуальных предпочтений разработчика.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Что самое сложное из того что вам приходилось реализовывать с помощью React?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Одним из самых сложных задач, которые я реализовывал с помощью React, было создание сложных форм с валидацией и динамическими полями. Это требовало работы с состоянием компонентов, обработки пользовательского ввода, динамического добавления и удаления полей, а также валидации данных. Приходилось также учитывать различные сценарии использования и обеспечивать хорошую пользовательскую интерактивность. Все это требовало глубокого понимания работы с React и использования соответствующих инструментов и библиотек для облегчения процесса разработки.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое REPL?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>REPL (Read-Eval-Print Loop) - это среда программирования, которая обеспечивает интерактивное взаимодействие с кодом. Она состоит из трех основных шагов: чтения (Read) ввода пользователя, выполнения (Eval) кода и вывода (Print) результатов. Цикл повторяется, позволяя пользователям немедленно видеть результаты своего кода. REPL-среды широко используются для экспериментов, отладки и быстрого прототипирования кода, так как они позволяют мгновенно видеть результаты и взаимодействовать с кодом на ходу. Примерами популярных REPL-сред для JavaScript являются Node.js REPL, браузерные консоли разработчика и интерактивные среды, такие как CodePen и JSFiddle.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое streams в Node.js?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Streams в Node.js представляют собой мощный механизм для обработки и передачи данных в потоковом режиме. Они позволяют эффективно работать с большими объемами данных, так как данные обрабатываются по мере их поступления, а не полностью загружаются в память. Streams могут быть использованы для чтения и записи файлов, обработки сетевых запросов, манипуляции данными в памяти и т.д. В Node.js существует четыре типа потоков: чтение (Readable), запись (Writable), двунаправленный (Duplex) и преобразования (Transform). Каждый тип потока предоставляет методы и события для управления потоком данных. Это позволяет разрабатывать эффективные и масштабируемые приложения, которые могут обрабатывать данные постепенно и минимизировать использование памяти.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое middleware?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Middleware в контексте программирования - это промежуточное программное обеспечение, которое обрабатывает запросы и/или ответы в процессе выполнения приложения. Веб-приложения, особенно те, построенные на базе фреймворков, часто используют middleware для выполнения дополнительных операций, таких как обработка аутентификации, регистрация маршрутов, обработка ошибок и многое другое. Middleware имеет доступ к объектам запроса и ответа, и может выполнять определенные действия перед передачей управления следующему обработчику. Он позволяет создавать модульную и расширяемую архитектуру приложения, где каждая функция middleware выполняет конкретную задачу, а цепочка middleware обрабатывает запросы последовательно. Это позволяет легко добавлять и изменять функциональность приложения без необходимости модификации основного кода.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Зачем используют функцию setImmediate?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Функция <code>setImmediate</code> используется в среде выполнения Node.js для планирования выполнения коллбэк-функции после завершения текущей фазы событий. В отличие от <code>setTimeout</code>, которая планирует выполнение коллбэка после указанной задержки, <code>setImmediate</code> позволяет планировать выполнение коллбэка в конце текущей фазы событий, сразу после завершения текущих асинхронных операций. Это делает <code>setImmediate</code> полезной для обработки коллбэков после завершения I/O операций или выполнения других асинхронных задач. Он позволяет сгруппировать коллбэки и обеспечить более эффективное использование ресурсов процессора, уменьшая задержку перед выполнением коллбэка.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Зачем нужен app.param() в express?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Метод <code>app.param()</code> в Express используется для определения обработчиков параметров маршрута. Он позволяет назначить общую функцию или middleware для обработки определенных параметров в URL-пути. Когда в маршруте встречается параметр с заданным именем, определенная функция или middleware будет вызвана для обработки этого параметра перед выполнением основного обработчика маршрута.</p><p><code>app.param()</code> полезен, когда требуется выполнить определенные действия над параметрами маршрута, например, извлечение данных из базы данных или проверка наличия ресурса. Это позволяет сократить дублирование кода и упростить обработку параметров в различных маршрутах.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое token based authentication?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Token-based authentication (аутентификация на основе токенов) - это метод аутентификации, который использует токены для идентификации и авторизации пользователей. При входе в систему пользователю выдается уникальный токен, который затем передается в каждом последующем запросе для проверки прав доступа.</p><p>В этом подходе сервер создает токен, часто в формате JSON Web Token (JWT), содержащий информацию о пользователе и его правах. Токен передается клиенту, который сохраняет его (например, в локальном хранилище) и отправляет обратно в каждом запросе в заголовке или в теле запроса. Сервер проверяет токен и, если он действителен и содержит соответствующие права доступа, разрешает выполнение запроса.</p><p>Преимущества такой аутентификации включают легкость масштабирования, возможность создания stateless API и удобство взаимодействия с разными клиентами. Токены также могут иметь срок действия, что повышает безопасность системы.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Напишите простой запрос к бд для вычисления трех авторов, у которых больше всего книг.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для выполнения запроса к базе данных, вычисляющего трех авторов с наибольшим числом книг, можно использовать следующий SQL-запрос:</p><p>SELECT author_id, COUNT(book_id) AS book_count
    FROM books
    GROUP BY author_id
    ORDER BY book_count DESC
    LIMIT 3;</p><p>Этот запрос сначала считает количество книг для каждого автора, группируя записи по идентификатору автора. Затем результаты сортируются в порядке убывания количества книг и ограничиваются первыми тремя записями. Результатом будет три строки с идентификаторами авторов и количеством их книг.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Напишите запрос, который выбирает последние три комментария для конкретного пользователя для двух таблиц: комментарии и пользователи.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для выбора последних трех комментариев для конкретного пользователя из таблиц "комментарии" и "пользователи" можно использовать следующий SQL-запрос:</p><p>SELECT c.comment_content
    FROM комментарии AS c
    JOIN пользователи AS u ON c.user_id = u.user_id
    WHERE u.username = 'имя_пользователя'
    ORDER BY c.comment_date DESC
    LIMIT 3;</p><p>В этом запросе мы объединяем таблицы "комментарии" и "пользователи" с помощью оператора JOIN по полю user_id. Затем мы указываем имя конкретного пользователя в предложении WHERE. Результаты сортируются по дате комментария в порядке убывания и ограничиваются трех последними комментариями с помощью LIMIT. В итоге будет выбраны содержания последних трех комментариев для указанного пользователя.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Спроектируйте простую схему базы данных для библиотеки.</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Простая схема базы данных для библиотеки может состоять из нескольких таблиц:</p><ol><li><p>Таблица "Книги" (Books):</p><ul><li>book_id (уникальный идентификатор книги)</li><li>title (название книги)</li><li>author (автор книги)</li><li>genre (жанр книги)</li><li>year (год издания)</li></ul></li><li><p>Таблица "Читатели" (Readers):</p><ul><li>reader_id (уникальный идентификатор читателя)</li><li>name (имя читателя)</li><li>email (электронная почта читателя)</li><li>phone (телефон читателя)</li><li>address (адрес читателя)</li></ul></li><li><p>Таблица "Выдача книг" (Borrowings):</p><ul><li>borrowing_id (уникальный идентификатор операции выдачи)</li><li>book_id (идентификатор книги)</li><li>reader_id (идентификатор читателя)</li><li>borrowing_date (дата выдачи)</li><li>return_date (дата возврата)</li></ul></li></ol><p>В этой схеме у каждой книги есть уникальный идентификатор book_id, каждый читатель имеет уникальный идентификатор reader_id, а операции выдачи и возврата книг записываются в таблицу "Выдача книг" с указанием соответствующих идентификаторов книг и читателей. Это простая схема, которая может быть дополнена другими таблицами и связями в зависимости от более конкретных требований и функциональности библиотеки.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Зачем используют SQL-оператор HAVING?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>SQL-оператор HAVING используется для фильтрации данных после выполнения оператора GROUP BY. Он позволяет применить условие к группированным данным, исключив некоторые группы или задав условия для агрегатных функций.</p><p>Оператор HAVING особенно полезен при использовании агрегатных функций, таких как COUNT, SUM, AVG, и т.д. Он позволяет отфильтровать результаты на основе значений этих функций. Например, вы можете использовать HAVING, чтобы выбрать только те группы, у которых сумма значения больше определенного порога или количество записей в группе превышает заданное значение.</p><p>Пример запроса с использованием HAVING:
    SELECT category, SUM(price) as total_price
    FROM products
    GROUP BY category
    HAVING total_price &gt; 1000;</p><p>В данном примере оператор HAVING фильтрует группы по условию total_price &gt; 1000, оставляя только те группы, у которых сумма цен превышает 1000.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Зачем используется SQL-оператор LEFT JOIN?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>SQL-оператор LEFT JOIN используется для объединения двух таблиц по указанному условию, при этом возвращаются все строки из левой (первой) таблицы и соответствующие строки из правой (второй) таблицы. Если нет соответствующих строк в правой таблице, то возвращается NULL.</p><p>LEFT JOIN полезен, когда необходимо получить все строки из левой таблицы вместе с соответствующими значениями из правой таблицы. Он позволяет комбинировать данные из двух таблиц на основе общих значений в указанных столбцах.</p><p>Пример использования LEFT JOIN:
    SELECT customers.name, orders.order_number
    FROM customers
    LEFT JOIN orders ON customers.id = orders.customer_id;</p><p>В данном примере используется LEFT JOIN для соединения таблиц customers и orders по столбцу customer_id. Результатом будет список имен клиентов из таблицы customers вместе с номерами заказов из таблицы orders. Если у клиента нет заказов, то для него будут возвращены NULL значения в столбце order_number.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Чем отличается embed- от reference-связи в MongoDB?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В MongoDB есть два типа связей для организации данных между коллекциями: embed-связь и reference-связь. Рассмотрим их отличия и примеры использования каждого типа.</p><ol><li><p>Embed-связь (встраивание):</p><ul><li>При embed-связи данные одной коллекции встраиваются непосредственно в документ другой коллекции.</li><li>Это позволяет хранить связанные данные в одном документе и извлекать их с помощью одного запроса.</li><li>Embed-связь обычно используется для связанных данных, которые имеют отношение «один к одному» или «один ко многим».</li></ul><p>Пример:
    Предположим, у нас есть коллекция "Users" и коллекция "Posts". Мы можем встроить данные о постах пользователя в документ пользователя:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css">{
      _id: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">"user_id"</span>),
      name: <span class="hljs-string">"John Doe"</span>,
      email: <span class="hljs-string">"john@example.com"</span>,
      posts: [
        {
          title: <span class="hljs-string">"Post 1"</span>,
          content: <span class="hljs-string">"Lorem ipsum dolor sit amet."</span>,
          date: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">"2023-06-14T00:00:00Z"</span>)
        },
        {
          title: <span class="hljs-string">"Post 2"</span>,
          content: <span class="hljs-string">"Praesent in nulla consequat."</span>,
          date: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">"2023-06-15T00:00:00Z"</span>)
        }
      ]
    }
    </code></div></div></pre></li><li><p>Reference-связь (ссылка):</p><ul><li>При reference-связи данные в одной коллекции содержат ссылку (идентификатор) на данные в другой коллекции.</li><li>Это позволяет разделять данные между коллекциями и получать данные по ссылке при необходимости.</li><li>Reference-связь обычно используется для связанных данных, которые имеют отношение «многие ко многим».</li></ul><p>Пример:
    Предположим, у нас есть коллекция "Users" и коллекция "Comments". В документе комментария мы можем хранить ссылку на пользователя, который оставил комментарий:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css">{
      _id: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">"comment_id"</span>),
      content: <span class="hljs-string">"Great post!"</span>,
      user: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">"user_id"</span>),
      date: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">"2023-06-16T00:00:00Z"</span>)
    }
    </code></div></div></pre><p>Здесь поле "user" содержит ссылку (ObjectId) на документ пользователя в коллекции "Users".</p></li></ol></div>`,
    group: "Junior",
  },
  {
    front: `<h2>В одном проекте программисты сохраняют данные в MongoDB-коллекции комментариев, используя следующие типы данных (смотрите ниже). Что плохого в этом решении?
    id: ObjectID
    text: string
    author_id: string
    created_at: Date</h2>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Одним из проблемных аспектов этого решения является хранение идентификатора автора комментария в виде строки (author_id: string) вместо ссылки на коллекцию пользователей. Использование ссылки на коллекцию пользователей (reference-связь) позволит обеспечить целостность данных и обновлять информацию об авторе единообразно во всех комментариях. Если автор изменит свои данные, то их нужно будет обновить только в одном месте - в коллекции пользователей.</p><p>Кроме того, сохранение идентификатора комментария в виде ObjectID (id: ObjectID) может привести к проблемам при поиске и запросах, особенно если другие части системы ожидают строковое представление идентификатора. В таких случаях могут потребоваться дополнительные преобразования данных.</p><p>Также стоит обратить внимание на отсутствие индексов в данной схеме. Создание соответствующих индексов (например, на поле created_at) может значительно повысить производительность запросов к коллекции комментариев.</p><p>В целом, использование ссылок на коллекцию пользователей, более подходящих типов данных для идентификаторов и применение индексов помогут улучшить производительность и управляемость базы данных.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>В проекте понадобилось внести изменения в структуру таблиц, добавить несколько полей и индексы. Как программисты будут делать это на продакшени?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для внесения изменений в структуру таблиц на продакшене рекомендуется использовать подходы миграций или изменений схемы данных (schema changes). Миграции позволяют управлять эволюцией базы данных, применяя последовательные изменения к существующей схеме.</p><p>Программисты могут создать миграции, которые содержат необходимые изменения: добавление новых полей, создание индексов и другие манипуляции с таблицами. Затем миграции могут быть применены к базе данных на продакшене.</p><p>Существуют различные инструменты для работы с миграциями, такие как Flyway, Liquibase или Sequelize, которые позволяют создавать и применять миграции с помощью скриптов или программного кода.</p><p>Важно проводить тестирование миграций на тестовой среде и обеспечить резервное копирование данных перед применением миграций на продакшене. Это поможет избежать потери данных и обеспечить безопасность процесса обновления структуры таблиц.</p></div>`,
    group: "Junior",
  },
  {
    front:
      "<h1>Каждый раз, когда вы делаете pull, почему-то случается конфликт в последней строке во всех файлах, которые вы редактировали. Что происходит?</h1>",
    back: `<div contenteditable="true" role="textbox" aria-multiline="true" tabindex="0" data-content="" _d-id="8" aria-disabled="false" aria-labelledby="translation-results-heading" aria-placeholder=""><p _d-id="52"><span _d-id="14609" class="--l --r sentence_highlight">Эти различия возникают из-за того, что разные ОС имеют разное представление о том, чем заканчивается строка.</span></p><p _d-id="53"><span _d-id="14610" class="--l --r sentence_highlight"><br _d-id="45"></span></p><p _d-id="54"><span _d-id="14611" class="--l --r sentence_highlight">Git обычно хорошо справляется с этим, устанавливая по умолчанию значение конфигурации core.eol в 'native'. </span><span _d-id="14613" class="--l --r sentence_highlight">Однако, если у разработчика по какой-то причине нет такой настройки, или он коммитит файлы в стиле UNIX из Windows или наоборот, вы можете получить такие проблемы.</span></p><p _d-id="55"><span _d-id="14614" class="--l --r sentence_highlight"><br _d-id="49"></span></p><p _d-id="56"><span _d-id="14615" class="--l --r sentence_highlight">Лучше всего найти источник проблемы и решить ее там, в противном случае можно попробовать установить другие значения для core.eol (lf/crlf) и посмотреть, устранит ли это проблему. </span><span _d-id="14617" class=" --l --r bg-[#E1F0F5] text-[#25282D] aligned-sentence-highlight sentence_highlight">Если это происходит только на определенном пути, а не во всем проекте, вам лучше определить файл gitattributes для этого пути.</span></p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что делает команда git fetch?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Команда <code>git fetch</code> используется для получения обновлений из удаленного репозитория, но без автоматического слияния с текущей рабочей веткой. Она загружает все новые коммиты, ветки и теги из удаленного репозитория в ваш локальный репозиторий.</p><p>После выполнения <code>git fetch</code>, вы будете иметь доступ к обновленным данным, но они не будут автоматически объединены с вашей текущей веткой. Это позволяет вам просмотреть и проанализировать изменения перед объединением с вашей рабочей веткой.</p><p>Команда <code>git fetch</code> обновляет информацию о ветках и коммитах в удаленном репозитории, а также обновляет вашу локальную копию удаленных веток, чтобы отразить последние изменения. После выполнения <code>git fetch</code> вы можете выполнить <code>git merge</code> или <code>git rebase</code>, чтобы объединить изменения с вашей текущей веткой.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Какие git hygiene подходы вы знаете?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Git hygiene подходы относятся к ряду практик и принципов, направленных на поддержание чистоты и организации вашего Git-репозитория. Некоторые из таких подходов включают:</p><ol><li><p>Правильное именование веток: Используйте осмысленные имена веток, которые отражают их назначение и содержимое.</p></li><li><p>Регулярное удаление ненужных веток: Удаляйте ветки после их объединения или завершения работы, чтобы избежать накопления мусора.</p></li><li><p>Чистка истории коммитов: Используйте <code>git rebase</code> для объединения мелких коммитов в более смысловые и логически связанные изменения.</p></li><li><p>Использование <code>.gitignore</code>: Создайте файл <code>.gitignore</code>, чтобы исключить ненужные файлы и папки из отслеживания Git.</p></li><li><p>Разделение функциональности по веткам: Разрабатывайте новую функциональность в отдельных ветках и объединяйте их только после полного тестирования.</p></li><li><p>Регулярное выполнение <code>git pull</code>: Обновляйте свою локальную копию репозитория с помощью <code>git pull</code>, чтобы получать последние изменения из удаленного репозитория.</p></li><li><p>Комментарии в коммитах: Пишите информативные комментарии к коммитам, чтобы они были понятны другим разработчикам.</p></li><li><p>Резервное копирование: Регулярно делайте резервные копии вашего репозитория, чтобы избежать потери данных.</p></li></ol><p>Эти подходы помогают поддерживать чистоту и организацию вашего Git-репозитория, что облегчает совместную работу и отслеживание изменений.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Что такое CI/CD? Для чего это нужно?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>CI/CD (Continuous Integration/Continuous Deployment) - это практика разработки программного обеспечения, которая включает автоматизацию процесса интеграции кода, его тестирования и непрерывного развертывания изменений в продуктивную среду. Вот несколько кейсов использования CI/CD в приложениях на React и Node.js:</p><ol><li><p>Автоматическая сборка и тестирование:</p><ul><li>При каждом коммите или пуше в репозиторий CI-система может автоматически собирать приложение React и запускать тесты.</li><li>Это помогает выявлять проблемы своевременно и предотвращает накопление ошибок, ускоряя обратную связь и обнаружение проблем.</li></ul></li><li><p>Непрерывная интеграция:</p><ul><li>При использовании CI/CD-подхода каждое изменение кода, внесенное разработчиками, интегрируется в общую ветку разработки.</li><li>CI-система автоматически запускает сборку, тестирование и проверку стиля кода для всех изменений, что позволяет выявлять конфликты и проблемы совместной работы команды.</li></ul></li><li><p>Автоматическое развертывание (Continuous Deployment):</p><ul><li>CI/CD позволяет автоматически развертывать приложение в продуктивную среду после успешной сборки и тестирования.</li><li>Это упрощает и ускоряет процесс развертывания и обновления приложения, минимизирует ручную работу и снижает риск человеческих ошибок.</li></ul></li><li><p>Управление окружениями:</p><ul><li>CI/CD-инструменты могут помочь в управлении различными окружениями, такими как разработка, тестирование, стейджинг и продуктивное окружение.</li><li>Вы можете настроить автоматическое развертывание приложения на каждом из окружений, используя соответствующие конфигурации и переменные окружения.</li></ul></li><li><p>Мониторинг и трассировка:</p><ul><li>CI/CD-инструменты могут быть интегрированы с системами мониторинга и трассировки, что позволяет отслеживать процесс сборки, тестирования и развертывания приложения.</li><li>Вы можете настроить оповещения и журналирование для быстрого обнаружения и решения проблем.</li></ul></li></ol><p>Каждый из этих кейсов CI/CD имеет свои преимущества и помогает повысить качество и скорость разработки приложений на React и Node.js.</p></div>`,
    group: "Junior",
  },
  {
    front: "<h1>Как реализовать CI/CD на github?</h1>",
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для реализации CI/CD на GitHub можно использовать различные инструменты и сервисы. Один из популярных вариантов - это использование GitHub Actions. С помощью Actions вы можете создавать и настраивать автоматические рабочие процессы (workflows), которые выполняются при определенных событиях, таких как push, pull request или расписание.</p><p>Внутри рабочего процесса вы можете определить шаги, которые включают сборку, тестирование, развертывание и другие действия. Для каждого шага вы можете использовать различные инструменты и скрипты в зависимости от ваших потребностей.</p><p>GitHub Actions позволяет интегрироваться с различными сервисами, такими как AWS, Azure, Google Cloud и другими, чтобы обеспечить полный процесс CI/CD.</p><p>Чтобы настроить CI/CD с помощью GitHub Actions, вам потребуется создать файл конфигурации (например, <code>.github/workflows/main.yml</code>), определить нужные шаги и запустить процесс. GitHub Actions предоставляет обширную документацию и примеры для помощи в настройке CI/CD процесса на GitHub.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>yaml</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">CI/CD</span> <span class="hljs-string">Pipeline</span>

    <span class="hljs-attr">on:</span>
      <span class="hljs-attr">push:</span>
        <span class="hljs-attr">branches:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">main</span>
    
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-attr">build-and-deploy:</span>
        <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span>
        
        <span class="hljs-attr">steps:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span>
            <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span>
            
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span>
            <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span>
            <span class="hljs-attr">with:</span>
              <span class="hljs-attr">node-version:</span> <span class="hljs-number">14</span>
              
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span>
            <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span>
            
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">React</span> <span class="hljs-string">app</span>
            <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span>
            
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">tests</span>
            <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">test</span>
            
          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">production</span>
            <span class="hljs-attr">uses:</span> <span class="hljs-string">easingthemes/ssh-deploy@v2</span>
            <span class="hljs-attr">with:</span>
              <span class="hljs-attr">host:</span> <span class="hljs-string">$ {{</span> <span class="hljs-string">secrets.PRODUCTION_HOST</span> <span class="hljs-string">}}</span>
              <span class="hljs-attr">username:</span> <span class="hljs-string">$ {{</span> <span class="hljs-string">secrets.PRODUCTION_USERNAME</span> <span class="hljs-string">}}</span>
              <span class="hljs-attr">password:</span> <span class="hljs-string">$ {{</span> <span class="hljs-string">secrets.PRODUCTION_PASSWORD</span> <span class="hljs-string">}}</span>
              <span class="hljs-attr">local_dir:</span> <span class="hljs-string">build/</span>
              <span class="hljs-attr">remote_dir:</span> <span class="hljs-string">/var/www/html</span>
    </code></div></div></pre><ol><li><p>Событие <code>push</code> на ветку <code>main</code> запускает рабочий процесс.</p></li><li><p>Рабочий процесс выполняется на виртуальной машине <code>ubuntu-latest</code>.</p></li><li><p>В шаге <code>Checkout repository</code> выполняется клонирование репозитория.</p></li><li><p>В шаге <code>Set up Node.js</code> настраивается окружение Node.js с помощью actions/setup-node.</p></li><li><p>Шаг <code>Install dependencies</code> устанавливает зависимости проекта с помощью <code>npm install</code>.</p></li><li><p>В шаге <code>Build React app</code> выполняется сборка приложения React с помощью <code>npm run build</code>.</p></li><li><p>Шаг <code>Run tests</code> запускает тесты приложения с помощью <code>npm run test</code>.</p></li><li><p>Шаг <code>Deploy to production</code> использует действие easingthemes/ssh-deploy для развертывания собранного приложения на удаленном сервере. Здесь используются секреты (например, <code>PRODUCTION_HOST</code>, <code>PRODUCTION_USERNAME</code>, <code>PRODUCTION_PASSWORD</code>), которые должны быть предварительно настроены в настройках репозитория GitHub.</p></li></ol></div><div class="markdown prose w-full break-words dark:prose-invert light"><p><code>actions/setup-node</code> - это действие (action) в GitHub Actions, которое обеспечивает настройку окружения Node.js для рабочего процесса. Оно устанавливает указанную версию Node.js и добавляет ее в путь окружения, чтобы ее можно было использовать в последующих шагах рабочего процесса.</p><p>Когда вы используете <code>actions/setup-node</code> в вашем рабочем процессе, вы можете указать версию Node.js, которую вы хотите использовать, и инструмент автоматически установит и настроит эту версию.</p><p>Вот пример использования <code>actions/setup-node</code> из предыдущего примера:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>yaml</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span>
  <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span>
  <span class="hljs-attr">with:</span>
    <span class="hljs-attr">node-version:</span> <span class="hljs-number">14</span>
</code></div></div></pre><p>В этом примере:</p><ul><li><code>name</code> - название шага в рабочем процессе.</li><li><code>uses</code> - указывает на использование действия <code>actions/setup-node@v2</code>.</li><li><code>with</code> - определяет входные параметры для действия. Здесь мы указываем версию Node.js, которую хотим установить (в данном случае, <code>14</code>).</li></ul><p>После выполнения этого шага, указанная версия Node.js будет установлена и готова к использованию в следующих шагах рабочего процесса.</p><p><code>actions/setup-node</code> предоставляет удобный способ настройки Node.js-окружения в рамках GitHub Actions и позволяет легко управлять версиями Node.js для ваших проектов.</p></div>`,
    group: "Junior",
  },
];
