const dbMiddle = [
  {
    front: `<h1>Расскажите о пирамиде тестирования.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Пирамида тестирования - это модель, которая описывает оптимальное соотношение различных типов тестов в процессе разработки программного обеспечения. Она состоит из трех уровней тестирования: юнит-тестирование, интеграционное тестирование и функциональное тестирование.</p><ol><li><p>Модульное тестирование (Unit Testing):</p><ul><li>Тестируются отдельные модули, компоненты или функции вашего приложения.</li><li>Кейс: Проверка, что React компонент правильно рендерится и работает с ожидаемыми данными.</li><li>Пример: Использование библиотеки Jest для написания тестов и проверки функциональности отдельных React компонентов или Node.js модулей.</li></ul></li><li><p>Интеграционное тестирование (Integration Testing):</p><ul><li>Тестируется взаимодействие различных компонентов и модулей приложения.</li><li>Кейс: Проверка, что React компоненты взаимодействуют с Node.js API и базой данных корректно.</li><li>Пример: Использование библиотеки Testing Library вместе с инструментами, такими как supertest, для написания интеграционных тестов, которые проверяют взаимодействие между React компонентами и Node.js сервером.</li></ul></li><li><p>Функциональное тестирование (End-to-End Testing):</p><ul><li>Тестируется весь путь выполнения функциональности приложения от начала до конца.</li><li>Кейс: Проверка, что веб-страницы React приложения работают корректно в браузере и взаимодействуют с сервером.</li><li>Пример: Использование инструментов, таких как Cypress или Puppeteer, для написания функциональных тестов, которые автоматизируют взаимодействие с браузером и проверяют функциональность React+Node.js приложения от начала до конца.</li></ul></li></ol></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие типы автоматизированных тестов представился случай писать? Какие библиотеки при этом использовали? Какие инструменты предпочитаете?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Использовал только Cypress</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое code coverage? Обязательно ли 100% покрытие тестами кода?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Code coverage - это метрика, измеряющая, насколько код программы охвачен тестами. Она показывает, какие части кода были выполнены в процессе запуска тестов. 100% покрытие тестами не является обязательным, но является желательной целью. Полное покрытие позволяет выявить потенциальные проблемы и улучшить качество кода, но может быть сложно достичь, особенно для больших проектов. Решение о достаточном уровне покрытия зависит от конкретного проекта, его требований, рисков и ресурсов. Важно стремиться к балансу между покрытием тестами и другими факторами, такими как время, ресурсы и приоритеты проекта.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как запретить браузеру отдавать кэш на HTTP-запрос?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для запрета браузеру отдавать кэш на HTTP-запросы можно использовать заголовки Cache-Control и Pragma. В заголовке Cache-Control нужно указать значение "no-cache", а в заголовке Pragma - значение "no-cache". Это сообщает браузеру не использовать кэшированные данные и выполнять запрос каждый раз напрямую к серверу. Пример использования этих заголовков:</p><p>Cache-Control: no-cache
    Pragma: no-cache</p><p>При передаче этих заголовков браузер будет обязан выполнять запрос каждый раз, не обращаясь к кэшу.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое XSS (Cross-Site Scripting)?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>XSS (Cross-Site Scripting) или межсайтовый скриптинг - это тип уязвимости веб-приложений, при котором злоумышленник внедряет вредоносный скрипт на веб-страницу, которая затем выполняется на стороне клиента (браузера) у других пользователей, посещающих эту страницу. Это может привести к выполнению несанкционированного кода JavaScript в контексте доверенного веб-сайта.</p><p>XSS может возникнуть из-за недостаточной обработки и фильтрации пользовательского ввода, который включает в себя HTML, JavaScript или другие сценарии. Примеры атак XSS могут включать внедрение вредоносных скриптов через поля ввода форм, комментарии, URL-параметры и другие места, где пользовательский ввод отображается на странице без должной проверки.</p><p>Существуют три основных типа XSS-атак:</p><ol><li><p>Stored XSS (XSS с хранением): Злоумышленник внедряет вредоносный код на сервере, и этот код сохраняется в базе данных или файле. Когда страница загружается, вредоносный код выполняется для всех пользователей, получающих доступ к этой странице.</p></li><li><p>Reflected XSS (Рефлектированный XSS): Вредоносный код передается веб-серверу вместе с запросом от пользователя. Сервер возвращает этот код в ответе без должной фильтрации, и браузер выполняет его на стороне клиента. Этот тип XSS обычно проявляется в виде вредоносных ссылок, отправляемых по электронной почте или размещаемых на веб-страницах.</p></li><li><p>DOM-based XSS (DOM-ориентированный XSS): Вредоносный код изменяет DOM (Document Object Model) на стороне клиента. Уязвимость обусловлена неправильной обработкой JavaScript, который изменяет DOM и отображается на странице.</p></li></ol><p>Атаки XSS могут иметь различные последствия, включая кражу пользовательских данных, перенаправление на фальшивые веб-сайты, выполнение несанкционированных действий от имени пользователя и другие вредоносные действия.</p><p>Для предотвращения атак XSS рекомендуется использовать корректную фильтрацию и экранирование пользовательского ввода при отображении его на веб-странице, а также использовать контекстно-зависимую безопасность (CSP) и другие механизмы защиты, чтобы ограничить выполнение ненадежного кода JavaScript.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о паттернах Observer, Pub / Sub. Какая между ними разница? Приведите примеры реализации этих паттернов в известных фреймворках/ библиотеках/браузерных API.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Паттерн Observer (Наблюдатель) и Pub/Sub (Издатель-Подписчик) относятся к паттернам поведения, используемым для реализации коммуникации между компонентами или объектами.</p><p>Паттерн Observer представляет отношение один-ко-многим, где один объект (наблюдаемый) содержит список зависимых объектов (наблюдателей) и автоматически уведомляет их об изменениях состояния.</p><p>Примеры реализации паттерна Observer включают JavaScript-фреймворк Vue.js с использованием метода <code>watch</code>, а также пакет RxJS, который предоставляет богатые возможности для работы с наблюдаемыми последовательностями.</p><p>Паттерн Pub/Sub подразумевает наличие посредника (или "шину"), через которую издатели публикуют сообщения, а подписчики получают их без явного знания друг о друге.</p><p>Примеры реализации паттерна Pub/Sub включают библиотеку EventEmitter в Node.js, которая предоставляет возможность создания и прослушивания событий, а также библиотеку Redux в React, которая использует паттерн Pub/Sub для управления состоянием приложения.</p><p>Разница между паттернами заключается в способе организации коммуникации: Observer фокусируется на зависимостях между наблюдателями и наблюдаемыми объектами, в то время как Pub/Sub использует посредника для передачи сообщений между издателями и подписчиками.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>С какой целью может быть использован event listener события fetch self.addEventListener('fetch', event => {})?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Использование события <code>fetch</code> в <code>self.addEventListener('fetch', event =&gt; {})</code> позволяет перехватывать и обрабатывать каждый HTTP-запрос, инициированный в браузере.</p><p>Основная цель такого использования - предоставление контроля над запросами и возможность модифицировать их поведение. Некоторые примеры целей использования включают:</p><ol><li><p>Кэширование: Вы можете использовать событие <code>fetch</code> для проверки наличия данных в кэше и возврата их без отправки запроса на сервер, что улучшит производительность и снизит нагрузку на сеть.</p></li><li><p>Автономная работа: Вы можете использовать событие <code>fetch</code>, чтобы обрабатывать запросы, даже если отсутствует подключение к сети. Это позволяет создавать приложения, которые могут работать в автономном режиме и предоставлять пользователю более непрерывный опыт.</p></li><li><p>Интерцептирование и модификация запросов: Событие <code>fetch</code> предоставляет возможность перехватывать запросы и вносить изменения в URL, заголовки или тело запроса. Это может быть полезно для добавления авторизационных заголовков, применения логики обработки ошибок или других преобразований данных.</p></li><li><p>Отправка запросов на альтернативные серверы: Путем обработки события <code>fetch</code>, вы можете перенаправлять запросы на другие серверы или использовать различные конечные точки в зависимости от условий, что полезно при создании прокси-серверов или распределенных систем.</p></li></ol><p>Использование события <code>fetch</code> дает гибкость и контроль над запросами, позволяя разработчикам создавать более мощные и адаптивные веб-приложения.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Event loop и как он работает? Расскажите о микрозадачах и макрозадачах.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Event loop - это механизм, который позволяет JavaScript обрабатывать асинхронные операции и события. Он работает следующим образом:</p><ol><li><p>JavaScript код выполняется в единственном потоке. Когда код выполняется, события добавляются в очередь событий.</p></li><li><p>Когда JavaScript выполнил текущую задачу, он проверяет очередь событий на наличие событий для обработки.</p></li><li><p>Если в очереди событий есть события, JavaScript извлекает первое событие и обрабатывает его.</p></li><li><p>Обработка события может включать выполнение соответствующего обработчика события и выполнение другого кода, связанного с этим событием.</p></li><li><p>После обработки события JavaScript возвращается к проверке очереди событий и повторяет процесс, пока очередь не будет полностью обработана.</p></li></ol><p>Микрозадачи и макрозадачи относятся к различным типам задач, которые могут быть добавлены в очередь событий:</p><ul><li><p>Микрозадачи - это задачи более высокого приоритета, которые обрабатываются перед обычными событиями. Они выполняются в порядке их добавления в очередь микрозадач. Примеры микрозадач включают промисы и методы <code>queueMicrotask()</code>, мутации DOM и других асинхронных операций, которые должны быть выполнены как можно скорее после завершения текущей операции, а также обработчики событий DOM.</p></li><li><p>Макрозадачи - это обычные задачи, добавляемые в очередь событий. Они обрабатываются после выполнения всех микрозадач. Примеры макрозадач включают обработчики событий, асинхронные функции и таймеры.</p></li></ul><p>Event loop и микрозадачи/макрозадачи вместе обеспечивают асинхронное выполнение кода и позволяют JavaScript обрабатывать события эффективно.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Для чего испрользуют setTimeout с временем 0?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Использование <code>setTimeout</code> с временем 0 (ноль) является распространенным приемом в JavaScript, который позволяет планировать выполнение функции на следующей итерации цикла событий. Несмотря на то, что время задержки указано как 0, функция, переданная в <code>setTimeout</code>, все равно будет выполняться асинхронно после текущей операции и завершения текущей итерации цикла событий.</p><p>Есть несколько причин, по которым используется <code>setTimeout</code> с временем 0:</p><ol><li><p>Поставить задачу в очередь макрозадач: Использование <code>setTimeout</code> с временем 0 позволяет поставить задачу в очередь макрозадач, чтобы она выполнилась после завершения текущей операции и всех микрозадач в очереди. Это полезно, когда вам нужно выполнить некоторый код после завершения текущего кода, но перед следующей операцией в цикле событий.</p></li><li><p>Создание асинхронной операции: Даже с временем задержки 0, <code>setTimeout</code> создает асинхронную операцию, которая будет выполняться после всех синхронных операций. Это может быть полезно, когда вы хотите разделить выполнение кода на несколько итераций цикла событий, чтобы предотвратить блокировку UI или позволить другим задачам выполниться.</p></li><li><p>Предотвращение блокировки стека вызовов (call stack): Использование <code>setTimeout</code> с временем 0 позволяет сделать паузу и дать возможность другим задачам выполниться, прежде чем код внутри функции <code>setTimeout</code> будет добавлен в стек вызовов и выполнен. Это помогает предотвратить блокировку стека вызовов и сгладить выполнение кода.</p></li></ol><p>Важно отметить, что использование <code>setTimeout</code> с временем 0 не гарантирует мгновенного выполнения задачи. Время задержки 0 указывает, что задача должна быть запланирована как можно скорее, но точное время выполнения будет зависеть от текущего состояния цикла событий и загруженности системы.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое temporal dead zone?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Temporal Dead Zone (TDZ) - это фаза во время исполнения кода на JavaScript, когда переменные объявлены с помощью let и const, но ещё не доступны для использования до момента их инициализации. В этой фазе обращение к переменным вызывает ошибку "ReferenceError". TDZ существует для обеспечения предсказуемости и избегания ошибок связанных с неправильным использованием переменных до их объявления и инициализации. Как только переменная инициализируется, она выходит из TDZ и становится доступной для использования в остальной части блока кода. Это помогает разработчикам обнаруживать и предотвращать ошибки, связанные с неявной и неправильной инициализацией переменных.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как работает boxing / unboxing в JavaScript?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript, boxing и unboxing - это процессы преобразования примитивных типов данных в и из объектных типов данных.</p><p>Boxing происходит, когда примитивное значение (например, число или строка) оборачивается в соответствующий объектный тип данных (Number, String и т.д.). Это позволяет использовать методы и свойства объекта для работы с примитивными значениями.</p><p>Unboxing, с другой стороны, происходит, когда объектный тип данных преобразуется обратно в примитивное значение. Например, при сравнении объектного типа данных со значением примитивного типа, происходит unboxing и объект преобразуется в соответствующий примитивный тип.</p><p>JavaScript автоматически выполняет boxing и unboxing, чтобы обеспечить совместимость между примитивными и объектными типами данных. Это позволяет разработчикам использовать методы и операции объектов для работы с примитивными значениями без явного создания объектов или преобразования типов.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между оператором in и методом hasOwnProperty?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Оператор <code>in</code> и метод <code>hasOwnProperty</code> используются для проверки наличия свойства в объекте, но есть небольшая разница в их поведении.</p><p>Оператор <code>in</code> проверяет, существует ли свойство в самом объекте или в его цепочке прототипов. Если свойство найдено, то возвращает <code>true</code>, в противном случае возвращает <code>false</code>.</p><p>Метод <code>hasOwnProperty</code> проверяет только существование свойства в самом объекте, игнорируя его цепочку прототипов. Он возвращает <code>true</code>, если свойство существует непосредственно в объекте, и <code>false</code> в противном случае.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'a'</span> <span class="hljs-keyword">in</span> obj); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'b'</span> <span class="hljs-keyword">in</span> obj); <span class="hljs-comment">// false</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'a'</span>)); <span class="hljs-comment">// true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'b'</span>)); <span class="hljs-comment">// false</span>
    </code></div></div></pre><p>Таким образом, если важно проверить наличие свойства только в самом объекте, следует использовать <code>hasOwnProperty</code>, а если нужно учесть и цепочку прототипов, используйте оператор <code>in</code>.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите, с помощью чего в JS реализуются такие ООП-парадигмы, как инкапсуляция, полиморфизм, абстракция?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript, ООП-парадигмы реализуются с помощью следующих средств:</p><ol><li><p>Инкапсуляция: В JavaScript инкапсуляция достигается путем использования замыканий и приватных переменных. Функции-конструкторы и модули позволяют создавать приватные переменные и методы, которые не доступны извне. Также введение классов с использованием ключевых слов <code>class</code> и <code>private</code> в более новых версиях JavaScript позволяет определить приватные члены класса.</p></li><li><p>Полиморфизм: В JavaScript полиморфизм достигается благодаря динамической типизации и возможности объектов иметь различные методы с одним и тем же именем. Это позволяет вызывать методы объекта, не зависимо от его конкретного типа, что обеспечивает гибкость и переиспользование кода.</p></li><li><p>Абстракция: В JavaScript абстракция достигается путем определения и использования классов, объектов или функций, которые скрывают детали реализации и предоставляют только необходимый интерфейс. Это позволяет создавать более понятный и модульный код, который легче поддерживать и расширять.</p></li></ol><p>Эти ООП-парадигмы в JavaScript основаны на его гибкости и возможностях функционального программирования. С их помощью разработчики могут создавать более эффективный и структурированный код.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое прототип? Как работает прототипное наследование в JS?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Прототип в JavaScript — это объект, который используется для наследования свойств и методов других объектов. Каждый объект в JavaScript имеет прототип, который может быть либо другим объектом, либо значением null.</p><p>При доступе к свойству или методу объекта, если оно не найдено в самом объекте, JavaScript автоматически ищет его в прототипе этого объекта. Если свойство не найдено и в прототипе, поиск продолжается в прототипе прототипа, и так далее, пока не будет найдено или не достигнут прототип с значением null.</p><p>Таким образом, прототипное наследование в JavaScript основано на цепочке прототипов. Когда создается новый объект, он наследует свойства и методы своего прототипа. Если какое-либо свойство или метод изменяется в прототипе, оно автоматически будет отражаться во всех объектах, наследующих данный прототип.</p><p>Прототипное наследование в JavaScript позволяет создавать иерархию объектов, где объекты могут наследовать и переопределять свойства и методы других объектов, обеспечивая гибкость и повторное использование кода.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какая разница между композицией и наследованием?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между композицией и наследованием заключается в том, как объекты получают функциональность.</p><p>Наследование позволяет классу наследовать свойства и методы от другого класса. При наследовании происходит передача кода и состояния от родительского класса к дочернему классу, создавая иерархию классов.</p><p>Композиция, с другой стороны, представляет собой составление объектов из других объектов или компонентов, которые предоставляют нужную функциональность. Вместо наследования, объект содержит или ссылается на другие объекты, чтобы достичь нужного поведения.</p><p>Основное отличие состоит в том, что наследование создает жесткую иерархию классов, которая может быть ограничена одним родительским классом, в то время как композиция позволяет более гибкое и динамическое комбинирование функциональности разных компонентов.</p><ol><li><p>Композиция в React:
    В React композиция основана на концепции компонентов, которые могут быть собраны вместе для создания более сложных интерфейсов. Вместо наследования компоненты в React обычно комбинируются путем включения одних компонентов внутри других.</p><p>Например, у вас может быть компонент <code>Header</code>, который отображает заголовок приложения, и компонент <code>Navbar</code>, который содержит навигационные элементы. Вы можете использовать композицию, включив компонент <code>Navbar</code> внутри компонента <code>Header</code>:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>jsx</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>My App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Navbar</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      );
    }
    </code></div></div></pre><p>В этом примере компонент <code>Navbar</code> включается внутри компонента <code>Header</code>, и они работают вместе для отображения заголовка и навигационной панели.</p></li><li><p>Наследование в Node.js:
    В Node.js наследование широко используется для расширения функциональности базовых классов и создания специализированных классов на их основе.</p><p>Например, у вас может быть базовый класс <code>Animal</code>, представляющий общие свойства и методы животного. Затем вы можете создать специализированный класс <code>Dog</code>, который наследует функциональность от класса <code>Animal</code> и добавляет свои собственные уникальные свойства и методы:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
      }
    
      <span class="hljs-title function_">speak</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Animal speaks'</span>);
      }
    }
    
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
      <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, breed</span>) {
        <span class="hljs-variable language_">super</span>(name);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">breed</span> = breed;
      }
    
      <span class="hljs-title function_">bark</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Woof!'</span>);
      }
    }
    </code></div></div></pre><p>В этом примере класс <code>Dog</code> наследует конструктор и метод <code>speak()</code> от базового класса <code>Animal</code>, но также добавляет собственный метод <code>bark()</code>. Теперь вы можете создавать экземпляры класса <code>Dog</code> и использовать его методы:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> myDog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">'Buddy'</span>, <span class="hljs-string">'Labrador'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myDog.<span class="hljs-property">name</span>); <span class="hljs-comment">// Output: Buddy</span>
    myDog.<span class="hljs-title function_">speak</span>(); <span class="hljs-comment">// Output: Animal speaks</span>
    myDog.<span class="hljs-title function_">bark</span>(); <span class="hljs-comment">// Output: Woof!</span>
    </code></div></div></pre><p>В этом примере класс <code>Dog</code> наследует функциональность от класса <code>Animal</code>, что позволяет создавать объекты с общими свойствами и методами для всех классов <code>Animal</code>, включая <code>Dog</code>.</p></li></ol></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему не стоит использовать конструкторы типа new String?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Не рекомендуется использовать конструкторы типа <code>new String</code>, потому что они создают объекты-обертки вместо примитивных строк. Это может привести к неожиданному поведению и проблемам сравнения строк.</p><p>Объекты-обертки, созданные с помощью <code>new String</code>, имеют дополнительные свойства и методы, которые обычным строкам не доступны. Это может вызвать непредсказуемые ошибки, особенно при сравнении строк с использованием операторов равенства (<code>==</code> или <code>===</code>), так как объекты-обертки не сравниваются по значению, а по ссылке.</p><p>Кроме того, использование конструктора <code>new String</code> менее эффективно с точки зрения производительности, так как создание объектов-оберток требует больше ресурсов, чем простое использование примитивных строк.</p><p>Вместо конструкторов типа <code>new String</code> рекомендуется использовать литеральную нотацию для создания строк, например: <code>var str = "Hello";</code>. Это позволяет работать с примитивными строками и избегать потенциальных проблем, связанных с объектами-обертками.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое записи (records) и кортежи (tuples)? Чем они отличаются от обычных объектов?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Записи (records) и кортежи (tuples) являются структурами данных, которые позволяют хранить несколько значений в одной переменной.</p><p>Основное отличие от обычных объектов заключается в том, что записи и кортежи имеют фиксированное количество полей и часто представляют собой неизменяемые (immutable) структуры данных. В отличие от объектов, которые могут иметь переменное число свойств и могут быть изменены, записи и кортежи обычно предназначены для хранения данных, которые не подлежат изменению.</p><p>Записи и кортежи часто используются для структурирования и передачи данных в функциях или методах. Они обеспечивают более явное и строгое определение структуры данных, что может способствовать пониманию и поддержке кода.</p><p>В некоторых языках программирования, таких как Swift, записи и кортежи имеют встроенную поддержку языка и предоставляют удобный синтаксис для работы с ними. В других языках, таких как JavaScript, их можно эмулировать с помощью объектов или массивов, однако это требует дополнительной логики.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие отличия в поведении ES5 функции-конструктора и ES2015 класса?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Основные отличия между ES5 функцией-конструктором и ES2015 классом в поведении заключаются в синтаксисе и некоторых дополнительных возможностях классов.</p><ol><li><p>Синтаксис: В ES5 функции-конструкторы определяются с помощью функций и используют ключевое слово "new" для создания экземпляров. В ES2015 классы определяются с использованием ключевого слова "class" и имеют специальные методы для определения конструктора и других методов.</p></li><li><p>Наследование: В ES5 наследование достигается путем установки прототипного свойства "prototype" функции-конструктора. В ES2015 классы поддерживают более читаемый синтаксис наследования с помощью ключевого слова "extends".</p></li><li><p>Статические методы: ES2015 классы имеют встроенную поддержку статических методов, которые могут быть вызваны на самом классе, а не на его экземплярах. В ES5 функциям-конструкторам приходится явно добавлять методы в их прототип.</p></li><li><p>Геттеры и сеттеры: ES2015 классы предоставляют синтаксис для определения геттеров и сеттеров для свойств класса, что позволяет управлять доступом к данным.</p></li></ol><p>В целом, ES2015 классы представляют более современный и удобный синтаксис для определения объектно-ориентированных конструкций в JavaScript и предлагают некоторые дополнительные возможности, которых нет в ES5 функциях-конструкторах.</p></div><div class="markdown prose w-full break-words dark:prose-invert light"><p>Вот пример функции-конструктора в синтаксисе ES5 и класса в синтаксисе ES2015:</p><p>ES5 функция-конструктор:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello, my name is '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'John'</span>, <span class="hljs-number">25</span>);
person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: Hello, my name is John</span>
</code></div></div></pre><p>В этом примере функция-конструктор <code>Person</code> создает новый объект, присваивает ему свойства <code>name</code> и <code>age</code>, а также определяет метод <code>sayHello()</code> через прототип. Затем создается экземпляр <code>person</code> с помощью оператора <code>new</code> и вызывается метод <code>sayHello()</code>.</p><p>ES2015 класс:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
  }

  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">\`Hello, my name is <span class="hljs-subst">\${<span class="hljs-variable language_">this</span>.name}</span>\`</span>);
  }
}

<span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'John'</span>, <span class="hljs-number">25</span>);
person.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// Output: Hello, my name is John</span>
</code></div></div></pre></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как реализовать паттерн «Модуль»?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Паттерн "Модуль" в JavaScript можно реализовать с помощью замыканий (closures). Вот простой пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = (<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-comment">// Приватные данные и функции</span>
        <span class="hljs-keyword">let</span> privateData = <span class="hljs-number">0</span>;
      
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">privateFunction</span> = (<span class="hljs-params"></span>) =&gt; {
          <span class="hljs-comment">// Делать что-то с приватными данными</span>
          privateData++;
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateData);
        };
      
        <span class="hljs-comment">// Возвращаемые методы и свойства являются публичными</span>
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">publicMethod</span>: <span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// Использование приватной функции</span>
            <span class="hljs-title function_">privateFunction</span>();
          },
          <span class="hljs-attr">publicProperty</span>: <span class="hljs-string">'Public data'</span>,
        };
      })();
      
      <span class="hljs-comment">// Использование модуля</span>
      <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// Выводит: 1</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">publicProperty</span>); <span class="hljs-comment">// Выводит: Public data</span>
      </code></div></div></pre><p>В этом примере мы используем самовызывающуюся функцию, которая создает замкнутое окружение, где определены приватные данные и функции. Затем мы возвращаем объект с публичными методами и свойствами, которые имеют доступ к приватным данным и функциям. Это обеспечивает инкапсуляцию и защиту приватных данных от прямого доступа извне.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему typeof null возвращает объект?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript, оператор <code>typeof</code> возвращает строку, указывающую тип операнда. Когда мы используем <code>typeof null</code>, он возвращает значение "object". Это историческая особенность JavaScript, связанная с реализацией исторических версий языка.</p><p>Причина, по которой <code>typeof null</code> возвращает "object", связана со способом представления значений в памяти. В JavaScript все значения объектов, включая <code>null</code>, хранятся в виде 32-битных слов, где первые биты используются для идентификации типа значения. Для всех объектов, включая <code>null</code>, эти биты устанавливаются в 0, что указывает на тип "объект".</p><p>Однако, это считается ошибкой в спецификации JavaScript, и <code>null</code> фактически является отдельным примитивным типом данных. Для проверки типа <code>null</code> можно использовать строгое сравнение (<code>=== null</code>) или дополнительную проверку.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое приведение (преобразование) типов в JS?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Приведение типов в JavaScript относится к процессу автоматического или явного изменения типа значения. В JavaScript значения могут быть приведены к различным типам данных в зависимости от контекста и операций, выполняемых над ними.</p><p>Автоматическое приведение типов происходит, когда JavaScript самостоятельно преобразует значения одного типа в другой, чтобы выполнить операцию. Например, если вы складываете число и строку, JavaScript автоматически преобразует число в строку и выполняет конкатенацию.</p><p>Явное приведение типов, также называемое явным преобразованием, выполняется программистом с помощью функций и операторов. Например, функции <code>Number()</code>, <code>String()</code>, <code>Boolean()</code> позволяют явно преобразовать значение в числовой, строковый или логический тип соответственно.</p><p>Приведение типов может быть полезным, но также может вызывать неожиданные результаты или ошибки, поэтому важно быть внимательным при работе с типами данных в JavaScript.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Garbage Collector?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Garbage Collector (сборщик мусора) - это механизм, встроенный в некоторые языки программирования, в том числе в JavaScript, который автоматически освобождает память, занятую неиспользуемыми объектами.</p><p>Сборщик мусора отслеживает объекты, которые больше не доступны программе, и освобождает память, занимаемую этими объектами. Он определяет, какие объекты больше не могут быть достигнуты из корневого набора (например, глобальные переменные или объекты, на которые есть ссылки), и удаляет их.</p><p>В JS</p><ol><li><p>Отслеживание ссылок: Сборщик мусора отслеживает все ссылки на объекты в программе. Когда объект создается, ему присваивается ссылка. Когда ссылка на объект удаляется или перезаписывается другим значением, сборщик мусора отмечает объект как потенциально доступный для очистки.</p></li><li><p>Маркировка: Сборщик мусора выполняет проход по графу объектов, начиная с глобального объекта (root) и следуя по цепочке ссылок. Он маркирует (помечает) все объекты, которые до сих пор являются достижимыми из глобального объекта.</p></li><li><p>Очистка: После маркировки сборщик мусора проходит по всем объектам в куче памяти и освобождает (очищает) память, занимаемую объектами, которые не были помечены как достижимые. Это означает, что объекты, которые больше не доступны из корневого объекта или из других достижимых объектов, будут удалены из памяти.</p></li><li><p>Компактирование: После очистки сборщик мусора может выполнить операцию компактирования, которая перемещает оставшиеся объекты в памяти, чтобы освободить непрерывные участки памяти. Это помогает уменьшить фрагментацию памяти и повысить эффективность использования ресурсов.</p></li></ol></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите назначение и принципы работы с коллекциями WeakMap и WeakSet? Чем они отличаются от коллекций Map и Set соответственно?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>WeakMap и WeakSet являются особыми типами коллекций в JavaScript, которые имеют некоторые отличия от Map и Set.</p><p>Назначение WeakMap:</p><ul><li>Позволяет использовать объекты в качестве ключей.</li><li>Автоматически освобождает память, когда объекты-ключи больше не используются в программе.</li><li>Не является перебираемой коллекцией, то есть нельзя получить список всех элементов.</li></ul><p>Назначение WeakSet:</p><ul><li>Позволяет хранить уникальные объекты.</li><li>Автоматически удаляет объекты из коллекции, когда они больше не используются в программе.</li><li>Не является перебираемой коллекцией, и у него нет методов для получения элементов.</li></ul><p>Отличия от Map и Set:</p><ul><li>WeakMap и WeakSet не доступны для итерации, то есть нельзя получить список всех элементов.</li><li>В WeakMap и WeakSet ключами могут быть только объекты, в то время как в Map и Set могут быть использованы любые значения.</li><li>В WeakMap и WeakSet отсутствуют методы и свойства, связанные с размером коллекции.</li></ul><p>Принцип работы WeakMap и WeakSet основан на том, что они не препятствуют сборщику мусора удалять объекты, если на них нет сильных ссылок в программе. Это позволяет избежать утечек памяти и упростить управление памятью при работе с объектами.</p><ol><li><p>WeakMap:
    WeakMap - это коллекция, которая позволяет использовать объекты в качестве ключей и связывать с ними значения. Ссылки на ключи в WeakMap являются слабыми, что означает, что если ключ больше не используется, он может быть автоматически удален сборщиком мусора.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
    
    <span class="hljs-keyword">let</span> key1 = {};
    <span class="hljs-keyword">let</span> key2 = {};
    
    wm.<span class="hljs-title function_">set</span>(key1, <span class="hljs-string">'Значение 1'</span>);
    wm.<span class="hljs-title function_">set</span>(key2, <span class="hljs-string">'Значение 2'</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">get</span>(key1)); <span class="hljs-comment">// Вывод: Значение 1</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">get</span>(key2)); <span class="hljs-comment">// Вывод: Значение 2</span>
    
    key1 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ссылка на key1 больше не существует</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(wm.<span class="hljs-title function_">get</span>(key1)); <span class="hljs-comment">// Вывод: undefined, так как ключ1 был удален автоматически</span>
    </code></div></div></pre><p>В этом примере объекты <code>key1</code> и <code>key2</code> используются в качестве ключей в WeakMap, и им сопоставляются значения 'Значение 1' и 'Значение 2' соответственно. После того, как ссылка на <code>key1</code> была установлена в <code>null</code>, ключ1 автоматически удалится из WeakMap при следующем сборке мусора.</p></li><li><p>WeakSet:
    WeakSet - это коллекция, которая хранит набор уникальных объектов. Ссылки на объекты в WeakSet также являются слабыми, что позволяет автоматически удалять объекты из WeakSet, если на них больше нет ссылок из других частей программы.</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();
    
    <span class="hljs-keyword">let</span> obj1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Объект 1'</span> };
    <span class="hljs-keyword">let</span> obj2 = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Объект 2'</span> };
    <span class="hljs-keyword">let</span> obj3 = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Объект 3'</span> };
    
    ws.<span class="hljs-title function_">add</span>(obj1);
    ws.<span class="hljs-title function_">add</span>(obj2);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj1)); <span class="hljs-comment">// Вывод: true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj2)); <span class="hljs-comment">// Вывод: true</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj3)); <span class="hljs-comment">// Вывод: false</span>
    
    obj2 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Ссылка на obj2 больше не существует</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws.<span class="hljs-title function_">has</span>(obj2)); <span class="hljs-comment">// Вывод: false, так как obj2 был автоматически удален</span>
    </code></div></div></pre><p>В этом примере объекты <code>obj1</code>, <code>obj2</code> и <code>obj3</code> добавляются в WeakSet с помощью метода <code>add()</code>. Метод <code>has()</code> используется для проверки наличия объектов в WeakSet. После установки ссылки <code>obj2</code> в <code>null</code>, объект <code>obj2</code> будет удален из WeakSet автоматически.</p></li></ol></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Чем отличается Observable от Promise?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Observable и Promise являются механизмами для работы с асинхронными операциями, но имеют некоторые отличия:</p><ol><li><p>Обработка значений: Promise возвращает единственное значение (успешный результат или ошибку), в то время как Observable может возвращать ноль, одно или более значений в течение времени.</p></li><li><p>Подписка: При использовании Promise мы делаем запрос на выполнение асинхронной операции и ждем ее завершения. В случае Observable мы подписываемся на поток событий и получаем значения по мере их появления.</p></li><li><p>Отмена: Promise не предоставляет нативной поддержки для отмены операции, в то время как Observable позволяет отменять подписки и прекращать получение значений.</p></li><li><p>Композиция: Observable предоставляет богатый набор операторов для манипулирования и комбинирования потоков данных, в то время как у Promise операторов гораздо меньше.</p></li><li><p>Hot и Cold Observable: Observable может быть как горячим (hot), генерирующим события независимо от подписок, так и холодным (cold), генерирующим события только при активной подписке.</p></li></ol><p>В целом, Observable предоставляет более гибкий и мощный инструмент для работы с асинхронными потоками данных, в то время как Promise является более простым и прямолинейным способом работы с однократными асинхронными операциями.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Promise? Назовите порядок выполнения then и catch в цепочке.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Promise - это объект, представляющий асинхронную операцию, которая может завершиться успешно (resolve) или с ошибкой (reject).</p><p>В цепочке Promise, методы then и catch вызываются последовательно в порядке, в котором они определены. Если промис успешно выполнен, вызывается ближайший метод then в цепочке. Если в процессе выполнения происходит ошибка, вызывается ближайший метод catch. Если в цепочке метод then возвращает новый промис, следующий метод then в цепочке будет ожидать завершения этого нового промиса.</p><p>Пример цепочки Promise:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">myPromise
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {
      <span class="hljs-comment">// Обработка успешного выполнения</span>
      <span class="hljs-keyword">return</span> anotherPromise;
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">anotherResult</span> =&gt;</span> {
      <span class="hljs-comment">// Обработка успешного выполнения нового промиса</span>
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
      <span class="hljs-comment">// Обработка ошибки</span>
    });
  </code></div></div></pre><p>В данном примере, если myPromise успешно выполнен, вызывается первый метод then, затем если anotherPromise успешно выполнен, вызывается второй метод then. Если происходит ошибка в любом промисе или в одном из методов then, вызывается метод catch для обработки ошибки.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о последовательном и параллельном выполнении асинхронных функций. В чем разница между Promise.all() и Promise.allSettled()?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При последовательном выполнении асинхронных функций каждая функция запускается только после завершения предыдущей. То есть, функция 2 начинает выполняться только после завершения функции 1, и так далее. В результате получается линейный порядок выполнения.</p><p>При параллельном выполнении асинхронных функций они запускаются одновременно, независимо друг от друга. Результаты могут возвращаться в любом порядке в зависимости от времени выполнения каждой функции.</p><p>Promise.all() используется для параллельного выполнения массива промисов и возвращает новый промис, который выполнится, когда все промисы из массива выполнены успешно. Если хотя бы один промис отклонен, возвращается отклоненный промис.</p><p>Promise.allSettled() также используется для параллельного выполнения массива промисов, но возвращает новый промис, который выполнится, когда все промисы из массива завершены, независимо от их результата (успех или отклонение). Возвращаемый промис содержит массив объектов с информацией о каждом промисе в исходном массиве.</p><p>Таким образом, разница между Promise.all() и Promise.allSettled() заключается в обработке ошибок: Promise.all() отклоняется при первом отклоненном промисе, а Promise.allSettled() ждет завершения всех промисов и возвращает информацию о каждом из них, независимо от результата.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое дескрипторы свойств объектов? Расскажите об их практическом применении</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Дескрипторы свойств объектов - это объекты, которые определяют атрибуты и поведение свойств объекта. Каждое свойство объекта имеет свой дескриптор, который содержит информацию о том, как это свойство ведет себя при чтении, записи и удалении.</p><p>Дескрипторы свойств позволяют контролировать доступ к свойствам объекта и их поведение. Они могут быть использованы для:</p><ol><li>Определения доступности свойства (например, чтение, запись).</li><li>Определения, является ли свойство перечислимым (будет ли оно видимо при переборе свойств объекта).</li><li>Определения возможности изменения свойства (например, запретить изменение значения).</li><li>Установки функций-геттеров и функций-сеттеров для свойств объекта.</li><li>Определения присутствия свойства в прототипе объекта и его доступности для наследуемых объектов.</li></ol><p>Практическое применение дескрипторов свойств включает контроль доступа к свойствам, создание вычисляемых свойств с помощью геттеров и сеттеров, реализацию инкапсуляции и более точную настройку поведения объектов в JavaScript.</p></div><div class="markdown prose w-full break-words dark:prose-invert light"><p>Вот пример использования дескрипторов свойств объектов в JavaScript:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">let</span> obj = {};

    <span class="hljs-comment">// Добавление свойства с дескриптором</span>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">'name'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-string">'John'</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Запрет на изменение значения</span>
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Позволяет перечислять свойство в циклах</span>
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// Запрет на удаление свойства и изменение дескриптора</span>
    });
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// Вывод: John</span>
    
    obj.<span class="hljs-property">name</span> = <span class="hljs-string">'Mike'</span>; <span class="hljs-comment">// Не приведет к изменению значения</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// Вывод: John</span>
    
    <span class="hljs-keyword">delete</span> obj.<span class="hljs-property">name</span>; <span class="hljs-comment">// Не удалит свойство</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// Вывод: John</span>
    </code></div></div></pre><p>В этом примере мы используем метод <code>Object.defineProperty</code> для добавления свойства <code>name</code> в объект <code>obj</code> с определенными дескрипторами.</p><p>Дескрипторы свойств объекта включают следующие параметры:</p><ul><li><code>value</code>: Значение свойства.</li><li><code>writable</code>: Указывает, может ли значение свойства быть изменено. По умолчанию <code>false</code>.</li><li><code>enumerable</code>: Указывает, будет ли свойство перечисляемым при итерации по объекту. По умолчанию <code>false</code>.</li><li><code>configurable</code>: Указывает, могут ли быть изменены или удалены свойство и его дескрипторы. По умолчанию <code>false</code>.</li></ul><p>В приведенном примере свойство <code>name</code> становится неизменяемым, перечисляемым и нельзя удалить или изменить его дескрипторы.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Назовите несколько способов создания неизменного объекта в JavaScript</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В JavaScript нет встроенного механизма для создания полностью неизменных объектов, так как большинство объектов являются изменяемыми по умолчанию. Однако, можно использовать некоторые приемы для создания объектов, которые максимально приближены к неизменяемости:</p><ol><li><p>Использование <code>Object.freeze()</code>: Этот метод замораживает объект, делая его свойства неизменными. Попытки изменить или удалить свойства будут игнорироваться или вызывать ошибку.</p></li><li><p>Использование <code>Object.seal()</code>: Этот метод запечатывает объект, позволяя изменять значения его существующих свойств, но не позволяет добавлять новые свойства или удалять существующие.</p></li><li><p>Использование библиотек и фреймворков: В некоторых сторонних библиотеках и фреймворках, таких как Immutable.js или Immer.js, предоставляются инструменты для создания неизменных структур данных, таких как списки, карты или записи.</p></li></ol><p>Но важно отметить, что эти методы обеспечивают неизменность только на поверхностном уровне, то есть они не предотвращают изменение вложенных объектов или массивов внутри неизменяемого объекта. Для достижения полной неизменности при работе с более сложными структурами данных можно использовать более специализированные библиотеки или написать собственные функции и классы для работы с неизменными объектами.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как создать свойство объекта, которое нельзя будет изменить?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Чтобы создать свойство объекта, которое нельзя будет изменить, можно использовать метод <code>Object.defineProperty()</code>. Вот пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> obj = {};

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">'propertyName'</span>, {
      <span class="hljs-attr">value</span>: <span class="hljs-string">'initial value'</span>,
      <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// Запрещает изменение значения</span>
    });
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">propertyName</span>); <span class="hljs-comment">// 'initial value'</span>
    obj.<span class="hljs-property">propertyName</span> = <span class="hljs-string">'new value'</span>; <span class="hljs-comment">// Не изменит значение</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">propertyName</span>); <span class="hljs-comment">// 'initial value'</span>
    </code></div></div></pre><p>В этом примере свойство <code>propertyName</code> создается с флагом <code>writable: false</code>, что означает, что его значение нельзя будет изменить позже. Если попытаться изменить значение такого свойства, изменения будут проигнорированы или вызовут ошибку, если находитесь в строгом режиме.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем нужен конструктор Proxy? Приведите пример использования.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Конструктор <code>Proxy</code> используется для создания объекта-прокси, который позволяет перехватывать и кастомизировать операции с другими объектами. Он предоставляет возможность создавать обертки над объектами и изменять их поведение при доступе, изменении или удалении свойств.</p><p>Пример использования конструктора <code>Proxy</code>:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> target = {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,
      };
      
      <span class="hljs-keyword">const</span> handler = {
        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, prop</span>) {
          <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'age'</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Age: <span class="hljs-subst">$ {target[prop]}</span>'</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> target[prop];
          }
        },
      };
      
      <span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 'John'</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">age</span>); <span class="hljs-comment">// 'Age: 30'</span>
      </code></div></div></pre><p>В этом примере создается прокси объект <code>proxy</code> для объекта <code>target</code>. При обращении к свойству <code>age</code> прокси перехватывает операцию <code>get</code> и возвращает кастомизированное значение. В остальных случаях прокси просто передает операции объекту <code>target</code>.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое ArrayBuffer? В чем разница между Uint32Array и Float32Array?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p><code>ArrayBuffer</code> - это объект, представляющий буфер памяти фиксированного размера. Он предоставляет способ хранения двоичных данных, таких как числа, байты и другие типы данных, без привязки к конкретному типу.</p><p><code>Uint32Array</code> и <code>Float32Array</code> - это два различных типа "представлений" (<code>view</code>) массива байтов внутри <code>ArrayBuffer</code>. Разница между ними заключается в том, как интерпретируются данные в массиве байтов:</p><ul><li><code>Uint32Array</code> интерпретирует каждые 4 байта как беззнаковое 32-битное целое число.</li><li><code>Float32Array</code> интерпретирует каждые 4 байта как число с плавающей точкой одинарной точности (32 бита).</li></ul><p>Таким образом, <code>Uint32Array</code> используется для работы с целыми числами без знака, а <code>Float32Array</code> - для работы с числами с плавающей точкой одинарной точности. Оба типа предоставляют оптимизированные методы и свойства для манипуляции и чтения данных из буфера.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о генераторах и итераторах.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Генераторы и итераторы - это функциональные возможности JavaScript, которые позволяют создавать итерируемые объекты и контролировать процесс их итерации.</p><p>Генераторы - это функции, которые могут приостанавливать свое выполнение и возвращать промежуточные результаты. Они создаются с использованием ключевого слова <code>function*</code> и содержат оператор <code>yield</code> для возврата значений.</p><p>Итераторы - это объекты, которые предоставляют последовательный доступ к элементам коллекции. Они реализуют метод <code>next()</code>, который возвращает объект с двумя свойствами: <code>value</code> (текущий элемент) и <code>done</code> (флаг, указывающий на завершение итерации).</p><p>Генераторы могут использоваться для создания итераторов. Каждый вызов метода <code>next()</code> на итераторе вызывает выполнение генератора до ближайшего оператора <code>yield</code> и возвращает соответствующее значение. Генератор может продолжать свое выполнение с последней точки приостановки.</p><p>Генераторы и итераторы полезны для работы с большими коллекциями данных или для генерации последовательностей значений по требованию, таких как бесконечные потоки данных или асинхронные операции.</p><p>Пример использования генератора и итератора:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generateNumbers</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> number = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">yield</span> number++;
  }
}

<span class="hljs-keyword">const</span> iterator = <span class="hljs-title function_">generateNumbers</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span>
<span class="hljs-comment">// ...</span>
</code></div></div></pre></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о типе данных Symbol и его практическом применении. Как перевести число из 10-разрядной системы в 16(2,8)-разрядную систему счисления?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Тип данных Symbol в JavaScript представляет собой уникальное и неизменяемое значение. Символы используются для создания уникальных идентификаторов, которые не пересекаются с другими свойствами объектов.</p><p>Практическое применение символов включает использование их в качестве ключей свойств объекта, чтобы избежать конфликтов имен. Они также используются для определения специальных поведений объектов, например, при определении итераторов или обработчиков событий.</p><p>Чтобы перевести число из десятичной системы счисления в шестнадцатеричную, двоичную или восьмеричную системы, можно использовать встроенные методы <code>toString()</code> или <code>parseInt()</code> с указанием соответствующей системы счисления. Например:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> decimalNumber = <span class="hljs-number">42</span>;

    <span class="hljs-comment">// Перевод в шестнадцатеричную систему</span>
    <span class="hljs-keyword">const</span> hexadecimalNumber = decimalNumber.<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hexadecimalNumber); <span class="hljs-comment">// "2a"</span>
    
    <span class="hljs-comment">// Перевод в двоичную систему</span>
    <span class="hljs-keyword">const</span> binaryNumber = decimalNumber.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(binaryNumber); <span class="hljs-comment">// "101010"</span>
    
    <span class="hljs-comment">// Перевод в восьмеричную систему</span>
    <span class="hljs-keyword">const</span> octalNumber = decimalNumber.<span class="hljs-title function_">toString</span>(<span class="hljs-number">8</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(octalNumber); <span class="hljs-comment">// "52"</span>
    </code></div></div></pre><p>Обратное преобразование из шестнадцатеричной, двоичной или восьмеричной системы обычно выполняется с помощью метода <code>parseInt()</code>, указывая соответствующую систему счисления во втором параметре.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Объясните, что означает currying. Приведите пример использования на практике.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Currying - это техника функционального программирования, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает только один аргумент.</p><p>Пример использования currying:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">a</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) {
          <span class="hljs-keyword">return</span> a * b;
        };
      }
      
      <span class="hljs-comment">// Используем функцию multiply с одним аргументом</span>
      <span class="hljs-keyword">const</span> multiplyByTwo = <span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiplyByTwo</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// Выведет 8</span>
      
      <span class="hljs-comment">// Используем функцию multiply непосредственно</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)); <span class="hljs-comment">// Выведет 15</span>
      </code></div></div></pre><p>В данном примере функция <code>multiply</code> принимает аргумент <code>a</code> и возвращает функцию, которая принимает аргумент <code>b</code> и производит их умножение. Таким образом, мы можем создать новую функцию <code>multiplyByTwo</code>, которая всегда будет умножать число на 2, просто вызвав <code>multiply</code> с аргументом 2. Позже мы можем вызвать <code>multiplyByTwo</code> с аргументом 4 и получить результат 8.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Приведите пример функции с мемоизацией. Когда следует применять эту технику?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Вот пример функции с мемоизацией:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoizedFunction</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> cache = {};
      
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) {
          <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">in</span> cache) {
            <span class="hljs-keyword">return</span> cache[n];
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">const</span> result = <span class="hljs-comment">/* выполнение вычислений */</span>;
            cache[n] = result;
            <span class="hljs-keyword">return</span> result;
          }
        };
      }
      </code></div></div></pre><p>Мемоизация - это техника, при которой результаты выполнения функции сохраняются в кэше, чтобы избежать повторных вычислений при повторных вызовах с теми же аргументами. Её следует применять в случаях, когда функция имеет дорогостоящие вычисления и вызывается с одними и теми же аргументами несколько раз. Мемоизация позволяет значительно ускорить выполнение функции, избегая повторных вычислений и использования ранее полученных результатов из кэша.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое чейнинг функций? Напишите пример с использованием этого подхода.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Чейнинг функций - это подход, при котором методы вызываются последовательно на объекте и каждый метод возвращает измененный объект, что позволяет вызывать следующий метод без необходимости промежуточных переменных.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> calculator = {
        <span class="hljs-attr">value</span>: <span class="hljs-number">0</span>,
        <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> += num;
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
        },
        <span class="hljs-title function_">multiply</span>(<span class="hljs-params">num</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> *= num;
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
        },
        <span class="hljs-title function_">subtract</span>(<span class="hljs-params">num</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> -= num;
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
        },
        <span class="hljs-title function_">getResult</span>(<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;
        }
      };
      
      <span class="hljs-keyword">const</span> result = calculator.<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">subtract</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">getResult</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// Output: 7</span>
      </code></div></div></pre><p>В приведенном примере мы можем последовательно вызывать методы <code>add()</code>, <code>multiply()</code>, <code>subtract()</code> на объекте <code>calculator</code>, не сохраняя промежуточные результаты. Это удобно и позволяет нам компактно и читаемо выполнять цепочку операций на объекте.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между function и arrow function?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Основные различия между функцией и стрелочной функцией (arrow function) в JavaScript:</p><ol><li><p>Синтаксис: Стрелочная функция имеет более краткий синтаксис. Она может быть записана в виде <code>() =&gt; {}</code>, в то время как обычная функция имеет синтаксис <code>function() {}</code>.</p></li><li><p>Контекст выполнения (this): Стрелочные функции не создают собственный контекст выполнения (this) и не привязывают его к себе. Вместо этого, они наследуют контекст выполнения от окружающего кода.</p></li><li><p>Невозможность использования в качестве конструктора: Стрелочные функции не могут быть использованы в качестве конструкторов для создания объектов с помощью оператора <code>new</code>.</p></li><li><p>Аргументы: Стрелочные функции не имеют своего собственного объекта <code>arguments</code>. Вместо этого, они получают доступ к аргументам своего окружающего контекста.</p></li><li><p>Неявное возвращение: Стрелочные функции имеют неявное возвращение значения, если код находится на одной строке. В обычной функции необходимо использовать явное ключевое слово <code>return</code> для возврата значения.</p></li></ol><p>В целом, использование обычных функций и стрелочных функций зависит от контекста и требований конкретной ситуации. Обычные функции предлагают большую гибкость, в то время как стрелочные функции предлагают более краткий синтаксис и удобство в определенных сценариях.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем принципиальная разница между событиями mouseleave и mouseout?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Основная разница между событиями <code>mouseleave</code> и <code>mouseout</code> заключается в их поведении при вложенных элементах.</p><p><code>mouseleave</code> срабатывает, когда курсор мыши покидает границу элемента, на котором событие было привязано, но не срабатывает, если курсор перемещается внутри этого элемента над его дочерними элементами.</p><p><code>mouseout</code> срабатывает, когда курсор мыши покидает границу элемента, на котором событие было привязано, и также срабатывает, когда курсор перемещается над дочерними элементами этого элемента.</p><p>Таким образом, <code>mouseleave</code> предназначено для отслеживания только покидания границы самого элемента, в то время как <code>mouseout</code> также отслеживает перемещение курсора над его дочерними элементами.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В каком порядке обрабатываются пользовательские события в DOM (click, mouseover и т.п.)? FIFO или LIFO?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>События в DOM обрабатываются в порядке FIFO (First-In-First-Out), что означает, что события обрабатываются в том порядке, в котором они произошли. Когда происходит событие, оно помещается в очередь событий. Затем обработчики событий вызываются в порядке их поступления в очередь.</p><p>Таким образом, если произошло несколько событий (например, <code>click</code> и <code>mouseover</code>), событие <code>click</code> будет обработано первым, а затем событие <code>mouseover</code> в том порядке, в котором они произошли.</p><p>Обработка событий в порядке LIFO (Last-In-First-Out) не является типичным для DOM и может быть реализована с использованием специальных методов или структур данных, но не является стандартным поведением.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Event bubbling и Event capturing?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Event bubbling и event capturing - это две фазы обработки событий в DOM.</p><p>При использовании event bubbling событие сначала обрабатывается на самом вложенном элементе, затем переходит к его родительским элементам и так далее, пока не достигнет корневого элемента. Это означает, что обработчики событий сначала вызываются на вложенных элементах, а затем на их родителях.</p><p>Event capturing - это противоположная фаза, где событие сначала обрабатывается на корневом элементе, затем переходит к его дочерним элементам и так далее, пока не достигнет самого вложенного элемента.</p><p>Стандартное поведение в DOM - это сначала event capturing, а затем event bubbling. Однако можно явно указать использование event capturing с помощью метода <code>addEventListener</code> с третьим аргументом <code>true</code>.</p><p>Оба этих механизма позволяют контролировать порядок обработки событий на разных элементах и используются для реализации делегирования событий и других продвинутых паттернов обработки событий.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Сравните методы объекта event stopPropagation и stopImmediateProparation</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Метод <code>stopPropagation</code> и метод <code>stopImmediatePropagation</code> объекта <code>event</code> используются для остановки дальнейшего распространения события в DOM.</p><p>Метод <code>stopPropagation</code> предотвращает дальнейшее всплытие события. Он останавливает передачу события родительским элементам, но не препятствует выполнению других обработчиков событий на текущем элементе.</p><p>Метод <code>stopImmediatePropagation</code> делает то же самое, но с более сильным эффектом. Он останавливает дальнейшее всплытие и немедленно прекращает выполнение остальных обработчиков событий на текущем элементе. То есть, он предотвращает вызов любых оставшихся обработчиков событий в цепочке.</p><p>Использование <code>stopPropagation</code> полезно, когда вы хотите предотвратить всплытие события, но продолжить выполнение других обработчиков на текущем элементе. А использование <code>stopImmediatePropagation</code> полезно, когда вы хотите остановить дальнейшее выполнение всех остальных обработчиков событий на текущем элементе.</p><p>Оба метода позволяют точно контролировать распространение событий в DOM и выбирать, какие обработчики событий должны быть выполнены.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие подходы оптимизации производительности вебстраницы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые подходы для оптимизации производительности веб-страницы:</p><ol><li><p>Оптимизация загрузки ресурсов: сжатие и кэширование файлов, использование сжатия gzip, минимизация и объединение CSS и JavaScript файлов.</p></li><li><p>Оптимизация изображений: использование сжатых форматов (например, JPEG или WebP), оптимизация размера изображений, ленивая загрузка изображений.</p></li><li><p>Улучшение работы сети: минимизация запросов к серверу, сокращение размера передаваемых данных, использование асинхронной загрузки ресурсов.</p></li><li><p>Оптимизация кода: удаление неиспользуемого кода, оптимизация и минимизация CSS и JavaScript, использование легковесных библиотек и фреймворков.</p></li><li><p>Кэширование: использование браузерного кэша, кэширование на сервере.</p></li><li><p>Ленивая загрузка: отложенная загрузка некритических ресурсов, отложенная инициализация скриптов.</p></li><li><p>Оптимизация отрисовки: использование CSS спрайтов, минимизация и упрощение CSS селекторов, улучшение производительности CSS анимаций.</p></li><li><p>Асинхронная обработка задач: использование веб-воркеров для выполнения вычислительно интенсивных задач в фоновом режиме.</p></li><li><p>Минимизация перерисовок и рефлов: использование CSS свойства <code>will-change</code>, избегание изменений размеров элементов, использование пакетной модификации DOM.</p></li><li><p>Тестирование и мониторинг производительности: использование инструментов для измерения производительности, проведение тестирования на разных устройствах и сетях, поиск и устранение узких мест.</p></li></ol><p>Эти подходы помогают улучшить время загрузки, отзывчивость и общую производительность веб-страницы.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как реализован механизм same-origin policy в браузере? На какие браузерные API он распространяется?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Same-Origin Policy (SOP) - это механизм безопасности в браузере, который регулирует взаимодействие между документами из разных источников. Он запрещает JavaScript-коду на веб-странице получать доступ к данным и взаимодействовать с ресурсами, которые находятся в другом источнике, если они имеют разные источники, протоколы или порты.</p><p>SOP применяется к следующим браузерным API:</p><ol><li><p>XMLHttpRequest: Браузер запрещает выполнение запросов на другой источник.</p></li><li><p>Fetch API: Аналогично XMLHttpRequest, Fetch API также подчиняется политике same-origin.</p></li><li><p>Document Object Model (DOM): Скрипты на веб-странице не могут получить доступ к содержимому и структуре документа из другого источника.</p></li><li><p>Cookies: Куки, установленные для одного источника, не передаются на запросы к другому источнику.</p></li><li><p>Web Storage: Ограничения политики same-origin распространяются на использование localStorage и sessionStorage.</p></li><li><p>Web Workers: Web Workers работают в ограниченной среде, где также действует SOP.</p></li><li><p>Iframes: Ифреймы на веб-странице также подчиняются политике same-origin.</p></li></ol><p>Механизм same-origin policy помогает обеспечить безопасность веб-приложений, предотвращая несанкционированный доступ к данным и защищая пользователей от потенциальных угроз безопасности, связанных с межсайтовым скриптингом и манипуляцией данными с других источников.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Назовите способы хранения данных в браузере. Сравните их.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Существуют несколько способов хранения данных в браузере:</p><ol><li><p>Cookies: Небольшие текстовые файлы, сохраняемые на клиентской стороне. Они имеют ограниченный объем (4 Кб) и отправляются с каждым запросом на сервер.</p></li><li><p>Web Storage (localStorage и sessionStorage): Позволяют хранить данные в браузере без отправки на сервер. Объем хранилища составляет около 5 Мб. Данные сохраняются в виде пар ключ-значение.</p></li><li><p>IndexedDB: Более мощная база данных, позволяющая хранить структурированные данные. Имеет большой объем хранения и поддерживает индексацию для эффективного поиска.</p></li><li><p>Web SQL Database: Устаревшая технология, позволяющая использовать SQL-подобный язык для работы с базой данных в браузере.</p></li><li><p>Cache API: Позволяет кэшировать ресурсы, такие как изображения и стили, для более быстрой загрузки в будущем.</p></li></ol><p>Сравнение:</p><ul><li>Cookies просты в использовании, но ограничены по объему и отправляются с каждым запросом.</li><li>Web Storage предлагает больший объем хранения и простой интерфейс, но данные остаются на клиентской стороне.</li><li>IndexedDB предоставляет мощную функциональность базы данных, но требует более сложной логики работы.</li><li>Web SQL Database устарел и не рекомендуется для использования.</li><li>Cache API полезен для кэширования ресурсов, но не предназначен для хранения пользовательских данных.</li></ul><p>Выбор метода хранения данных зависит от требований приложения: размера данных, необходимости отправки на сервер, структуры данных и функциональных возможностей, которые требуются для работы с данными.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите особенности передачи данных между worker'ами и основным потоком между разделенными worker'ами.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Web worker'ы - это механизм в браузере, позволяющий выполнять вычисления в фоновом потоке, освобождая основной поток для отзывчивого пользовательского интерфейса. Особенности передачи данных между worker'ами и основным потоком:</p><ol><li><p>Передача данных между основным потоком и worker'ом: Для этого используется механизм сообщений. Основной поток и worker могут обмениваться сообщениями с помощью методов postMessage и onmessage.</p></li><li><p>Передача данных между разделенными worker'ами: В отличие от обмена с основным потоком, обмен данными между разделенными worker'ами возможен только через основный поток. Основной поток может служить посредником, пересылая сообщения между различными worker'ами.</p></li></ol><p>При передаче данных через сообщения между worker'ами и основным потоком следует учитывать следующие особенности:</p><ul><li>Данные передаются по значению, а не по ссылке. Это означает, что копии данных создаются при передаче, а не передается сам объект.</li><li>Некоторые типы данных, такие как функции и некоторые объекты, не могут быть переданы через сообщения. При передаче необходимо сериализовать данные в JSON или другой формат.</li></ul><p>При передаче данных между разделенными worker'ами через основной поток следует учитывать потенциальную задержку, связанную с передачей данных через посредника. Это может повлиять на производительность, особенно при передаче больших объемов данных.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Transferable-объекты?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Transferable-объекты - это специальный тип объектов в JavaScript, которые могут быть переданы между различными потоками или worker'ами без копирования данных. При передаче Transferable-объекта его владение переходит к получателю, и исходный отправитель больше не имеет доступа к этому объекту.</p><p>Transferable-объекты обычно используются вместе с API, такими как Web Workers или SharedArrayBuffer, для оптимизации передачи больших объемов данных. Передача Transferable-объектов осуществляется через метод postMessage с использованием опции transferList.</p><p>Примером Transferable-объектов являются SharedArrayBuffer, ArrayBuffer, ImageBitmap и OffscreenCanvas. При передаче этих объектов через postMessage с указанием transferList, они могут быть эффективно переданы без копирования данных, что повышает производительность и уменьшает использование памяти.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о способах оптимизации выполнения ресурсоемких операций JS для улучшения производительности рендеринга контента на странице.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для оптимизации выполнения ресурсоемких операций JavaScript и улучшения производительности рендеринга контента на странице можно использовать следующие подходы:</p><ol><li><p>Разбиение задач на мелкие части и выполнение их асинхронно или в фоновом потоке с использованием Web Workers. Это позволяет освободить главный поток выполнения для более отзывчивого взаимодействия с пользователем.</p></li><li><p>Ленивая загрузка данных или ресурсов при необходимости. Таким образом, избегается лишнее загружение и обработка ненужных данных, снижая время выполнения операций.</p></li><li><p>Кэширование результатов вычислений или промежуточных данных для повторного использования. Это позволяет избежать повторных вычислений и ускоряет выполнение операций.</p></li><li><p>Использование алгоритмов с более низкой сложностью, если это возможно. Это может быть достигнуто путем оптимизации алгоритмов или выбора более эффективных алгоритмических подходов.</p></li><li><p>Оптимизация работы с DOM, минимизация обращений к нему и использование пакетных операций для минимизации перерисовок и рефлоу.</p></li><li><p>Использование асинхронных операций, таких как промисы или async/await, для управления асинхронными задачами и предотвращения блокировки главного потока выполнения.</p></li></ol><p>Комбинируя эти подходы и анализируя узкие места в производительности приложения, можно значительно улучшить процесс рендеринга и общую производительность страницы.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему ResizeObserver вызывает события изменения размера до воспроизведения элемента, а не после?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>ResizeObserver вызывает события изменения размера до воспроизведения элемента для того, чтобы обеспечить корректность и надежность измерений. Изменение размера элемента может привести к изменению его положения и расположения на странице. Предварительное определение изменений размера позволяет другим частям кода или компонентам адекватно реагировать на эти изменения, например, перерасполагая элементы или пересчитывая размеры других компонентов. Это помогает избежать ситуаций, когда элементы или их компоненты не соответствуют ожидаемым размерам после воспроизведения, что может привести к непредсказуемым последствиям или ошибкам в разметке страницы. Предварительные события изменения размера позволяют обработчикам принять соответствующие меры заранее и подготовиться к изменениям, гарантируя более плавное и предсказуемое воспроизведение элементов.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите, как вы понимаете Web Accessibility?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Web Accessibility (веб-доступность) означает создание веб-сайтов и приложений, которые доступны и используемы людьми с различными способностями, включая людей с ограниченными физическими или когнитивными возможностями. Это включает в себя обеспечение доступа к информации и функциональности с помощью различных технологий и устройств, таких как чтение с экрана, управление клавиатурой, использование адаптивного дизайна и другие.</p><p>Веб-доступность важна, потому что она позволяет создавать инклюзивное и равноправное онлайн-пространство для всех пользователей. Это включает устранение барьеров, которые могут исключать людей с ограничениями, и обеспечение равных возможностей доступа к информации, товаров и услуг.</p><p>Соблюдение принципов веб-доступности помогает расширить аудиторию пользователей, улучшить удовлетворенность клиентов, соответствовать нормативным требованиям и демонстрировать социальную ответственность. Это достигается путем использования доступного дизайна, разметки и кодирования, а также тестирования и проверки доступности веб-сайтов и приложений.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите алгоритм создания функционала, обеспечивающего чтение содержимого .txt-файла при перетаскивании его из файловой системы в окно браузера.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для создания функционала чтения содержимого .txt-файла при перетаскивании его в окно браузера, можно использовать следующий алгоритм:</p><ol><li>На HTML-странице создается область (например, div), которая будет принимать перетаскиваемый файл.</li><li>Добавляется обработчик события "dragover" для области, чтобы предотвратить стандартное поведение браузера по открытию файла.</li><li>Добавляется обработчик события "drop" для области, который срабатывает при бросании файла в область.</li><li>В обработчике события "drop" получаем доступ к файлу через объект события.</li><li>Создаем экземпляр объекта FileReader.</li><li>Добавляем обработчик события "load" для объекта FileReader, который срабатывает при завершении чтения файла.</li><li>В обработчике события "load" получаем содержимое файла из объекта FileReader и выполняем необходимые действия с ним (например, выводим содержимое на страницу).</li></ol><p>Этот алгоритм использует HTML5 Drag and Drop API и FileReader API для обработки перетаскивания файла и чтения его содержимого.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Объясните разницу между единицами измерения px, em, rem.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между единицами измерения px, em и rem заключается в том, как они определяют размеры элементов:</p><ul><li><p>px (пиксель) - это абсолютная единица измерения, которая определяет размеры элементов в пикселях. Значение px не изменяется в зависимости от контекста или настроек пользователя.</p></li><li><p>em - это относительная единица измерения, которая зависит от размера шрифта родительского элемента. Значение em устанавливает размеры элементов относительно размера шрифта родительского элемента.</p></li><li><p>rem - это относительная единица измерения, которая зависит от размера шрифта корневого элемента (обычно &lt;html&gt;). Значение rem устанавливает размеры элементов относительно размера шрифта корневого элемента, что делает его удобным для создания простой и предсказуемой масштабируемости.</p></li></ul><p>Использование em и rem позволяет создавать более гибкую и адаптивную веб-разметку, а также облегчает изменение размеров элементов на основе стилей и настроек шрифтов.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем нужны CSS-переменные? Приведите несколько примеров использования.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>CSS-переменные (или пользовательские свойства) предоставляют возможность объявлять и переиспользовать значения в CSS. Они полезны для:</p><ol><li><p>Централизованного управления стилями: Можно определить общие значения (например, цвета, размеры) в CSS-переменных, что позволяет быстро изменять эти значения на всем сайте.</p></li><li><p>Адаптивной вёрстки: CSS-переменные могут использоваться для настройки стилей на разных устройствах и экранах, что упрощает создание адаптивного дизайна.</p></li><li><p>Темизации: Можно создавать различные темы, определяя значения CSS-переменных для каждой темы, и легко переключаться между ними.</p></li><li><p>Анимации и переходы: CSS-переменные могут быть использованы для создания плавных анимаций и переходов, позволяя легко изменять значения в процессе анимации.</p></li></ol><p>Примеры использования CSS-переменных:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css"><span class="hljs-selector-pseudo">:root</span> {
        <span class="hljs-attr">--primary-color</span>: <span class="hljs-number">#007bff</span>;
        <span class="hljs-attr">--font-size</span>: <span class="hljs-number">16px</span>;
      }
      
      <span class="hljs-selector-class">.button</span> {
        <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">var</span>(--primary-color);
        <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">var</span>(--font-size);
      }
      
      <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">768px</span>) {
        <span class="hljs-selector-pseudo">:root</span> {
          <span class="hljs-attr">--font-size</span>: <span class="hljs-number">14px</span>;
        }
      }
      
      <span class="hljs-selector-class">.dark-theme</span> {
        <span class="hljs-attr">--primary-color</span>: <span class="hljs-number">#333</span>;
      }
      </code></div></div></pre><p>В этом примере CSS-переменные определяют цвета и размеры, используемые в стилях кнопок, а также позволяют адаптировать размер шрифта для разных устройств и создавать темы с различными цветовыми схемами.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что произойдет при добавлении следующего селектора? * { box-sizing: border-box; }</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При добавлении селектора <code>* { box-sizing: border-box; }</code> будет применяться свойство <code>box-sizing: border-box;</code> ко всем элементам на веб-странице, включая все дочерние элементы. Это изменит модель размеров элементов таким образом, что ширина и высота элемента будут включать в себя размеры границ и отступов, а не только контента.</p><p>Такая модель размеров упрощает расчеты и позиционирование элементов, особенно при использовании отступов и границ. К примеру, если элемент имеет ширину 100px и границу шириной 2px, то с помощью <code>box-sizing: border-box;</code> общая ширина элемента останется 100px, и граница будет вписываться в это значение, не увеличивая размеры элемента.</p><p>Этот селектор является удобным способом применить изменение модели размеров ко всем элементам на странице без необходимости изменять их стили по отдельности.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как адаптировать страницу печати?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для адаптации страницы к печати в CSS можно использовать медиа-запрос <code>@media print</code>. В этом режиме можно изменять стили, чтобы контент лучше выглядел на печати. Например, можно скрыть ненужные элементы, изменить размеры и шрифты, добавить разрывы страниц и т.д. Кроме того, можно использовать свойства <code>page-break-before</code> и <code>page-break-after</code> для контроля разрывов страниц при печати. Также стоит обратить внимание на использование относительных единиц измерения, чтобы контент приспосабливался к размеру бумаги.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите особенности кастомизации стилей обычных частей форм.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для кастомизации стилей обычных частей форм можно использовать псевдоэлементы и псевдоклассы, такие как <code>::placeholder</code>, <code>::selection</code>, <code>:hover</code>, <code>:focus</code> и другие. Также можно использовать свойство <code>appearance</code> для изменения внешнего вида элементов формы. При этом следует учитывать, что поддержка свойства <code>appearance</code> может различаться в разных браузерах. Для полной кастомизации формы рекомендуется использовать CSS-фреймворки или создавать собственные компоненты с помощью HTML и CSS.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое progressive рендеринг? Какие подходы используются?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Progressive рендеринг - это стратегия загрузки и отображения контента на веб-странице поэтапно, по мере его получения от сервера. Она позволяет пользователю видеть и взаимодействовать с контентом быстрее, даже если загрузка еще не завершена.</p><p>Подходы, используемые для progressive рендеринга, включают:</p><ol><li>Постепенная загрузка изображений, где небольшие версии изображений загружаются сначала, а затем постепенно заменяются более качественными версиями.</li><li>Использование ленивой загрузки (lazy loading) для отложенной загрузки контента, находящегося вне области видимости пользователя.</li><li>Приоритезация загрузки критического контента, такого как стили и скрипты, чтобы страница могла быстро отобразиться и стать интерактивной.</li><li>Кэширование контента для повторных посещений, чтобы ускорить загрузку страницы.</li></ol><p>Эти подходы позволяют улучшить восприятие пользователем скорости загрузки и обеспечить более плавное взаимодействие с веб-страницей.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Назовите несколько способов реализации lazy-loading медиаресурсов на странице</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Несколько способов реализации lazy-loading медиаресурсов на странице:</p><ol><li><p>Использование атрибута <code>loading="lazy"</code>: Добавление атрибута <code>loading="lazy"</code> к тегу <code>&lt;img&gt;</code> или <code>&lt;iframe&gt;</code> позволяет браузеру отложить загрузку медиаресурса до тех пор, пока он не станет видимым в области просмотра.</p></li><li><p>Intersection Observer API: Использование Intersection Observer API позволяет отслеживать, когда элемент становится видимым в окне просмотра, и тогда загружать медиаресурс. Это более гибкий подход, который позволяет лениво загружать медиаресурсы в зависимости от их положения на странице.</p></li><li><p>JavaScript и события прокрутки: С помощью JavaScript можно отслеживать события прокрутки страницы и загружать медиаресурсы по мере приближения к ним. Например, при достижении определенной позиции на странице можно динамически добавить элемент с медиаресурсом в DOM.</p></li></ol><p>Эти способы позволяют оптимизировать загрузку медиаресурсов, ускорить время загрузки страницы и улучшить пользовательский опыт.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Назовите популярные шаблонизаторы для фронтенд-разработки. Опишите особенности их использования.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые популярные шаблонизаторы для фронтенд-разработки:</p><ol><li><p>Handlebars: Простой и интуитивно понятный шаблонизатор, использующий синтаксис Mustache. Позволяет разделять HTML и логику шаблонов. Поддерживает условные операторы, циклы и частичные шаблоны.</p></li><li><p>Pug (бывший Jade): Шаблонизатор с минималистичным синтаксисом. Использует отступы для организации кода. Позволяет создавать компактные и читаемые шаблоны.</p></li><li><p>EJS (Embedded JavaScript): Позволяет встраивать JavaScript-код непосредственно в шаблоны. Поддерживает условные операторы, циклы и функции. Легко интегрируется с Node.js.</p></li></ol><p>Основная задача шаблонизаторов - упростить создание и поддержку динамического контента. Они позволяют разделить логику и представление, повышают переиспользуемость кода и облегчают работу с динамическими данными, такими как переменные, условия и циклы. Шаблонизаторы способствуют более чистому и организованному коду, а также повышают удобство разработки и обслуживания проекта.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Назовите популярные CSS-методологии и их отличия</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые популярные CSS-методологии:</p><ol><li><p>BEM (Block Element Modifier): Рекомендует использовать классы в формате "блок__элемент--модификатор". Объединяет HTML, CSS и JavaScript вместе для более понятной структуры и повторного использования кода.</p></li><li><p>SMACSS (Scalable and Modular Architecture for CSS): Предлагает разделение стилей на базовые, макетные, модульные, состояний и темы. Стремится к гибкой и масштабируемой архитектуре стилей.</p></li><li><p>OOCSS (Object-Oriented CSS): Сосредоточивается на создании независимых и переиспользуемых компонентов, которые могут быть использованы в разных проектах.</p></li></ol><p>Отличия между ними:</p><ul><li>BEM подчеркивает иерархическую структуру именования, в то время как SMACSS и OOCSS склоняются к более модульной организации кода.</li><li>BEM и SMACSS уделяют больше внимания структуре и организации стилей, в то время как OOCSS более акцентируется на создании независимых компонентов.</li><li>BEM имеет строгие правила именования классов, в то время как SMACSS и OOCSS оставляют больше свободы в выборе именования.</li></ul><p>Каждая методология имеет свои преимущества и может быть выбрана в зависимости от требований проекта и личных предпочтений разработчика.</p></div><div class="markdown prose w-full break-words dark:prose-invert light"><p>Пример BEM:
    HTML:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>html</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__element"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block__element--modifier"</span>&gt;</span>Some text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </code></div></div></pre><p>CSS:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css"><span class="hljs-selector-class">.block</span> {
      <span class="hljs-comment">/* стили блока */</span>
    }
    
    <span class="hljs-selector-class">.block__element</span> {
      <span class="hljs-comment">/* стили элемента блока */</span>
    }
    
    <span class="hljs-selector-class">.block__element--modifier</span> {
      <span class="hljs-comment">/* стили модификатора элемента блока */</span>
    }
    </code></div></div></pre><p>Пример SMACSS:
    HTML:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>html</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"block"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"element"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"modifier"</span>&gt;</span>Some text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </code></div></div></pre><p>CSS:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css"><span class="hljs-selector-class">.block</span> {
      <span class="hljs-comment">/* стили блока */</span>
    }
    
    <span class="hljs-selector-class">.element</span> {
      <span class="hljs-comment">/* стили элемента */</span>
    }
    
    <span class="hljs-selector-class">.modifier</span> {
      <span class="hljs-comment">/* стили модификатора */</span>
    }
    </code></div></div></pre><p>Пример OOCSS:
    HTML:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>html</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box-content"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box-content__highlight"</span>&gt;</span>Some text<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    </code></div></div></pre><p>CSS:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>css</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-css"><span class="hljs-selector-class">.box</span> {
      <span class="hljs-comment">/* общие стили блока */</span>
    }
    
    <span class="hljs-selector-class">.box-content</span> {
      <span class="hljs-comment">/* общие стили содержимого блока */</span>
    }
    
    <span class="hljs-selector-class">.box-content__highlight</span> {
      <span class="hljs-comment">/* стили для выделения содержимого блока */</span>
    }
    </code></div></div></pre><p>В каждом из этих стилей, BEM, SMACSS и OOCSS, основной принцип состоит в разделении стилей на независимые блоки, элементы и модификаторы. Это помогает создавать модульный и легко поддерживаемый код CSS. Однако, у каждого подхода есть свои особенности и нюансы, поэтому важно выбрать подход, который лучше всего подходит для вашего проекта и команды разработчиков.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие форматы изображений поддерживают анимацию?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Форматы изображений, которые поддерживают анимацию, включают GIF, APNG (Animated PNG) и WebP. GIF - это наиболее широко известный и поддерживаемый формат анимированных изображений. APNG - это расширение PNG, которое также поддерживает анимацию, но имеет более высокое качество и поддерживается в некоторых современных браузерах. WebP - это формат изображения, разработанный компанией Google, который обеспечивает хорошее сжатие и поддержку анимации, но имеет ограниченную поддержку браузеров.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как отследить прогресс/ окончание CSS @keyframes анимаций или плавных переходов, реализованных с помощью transition, в JS?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для отслеживания прогресса и окончания CSS @keyframes анимаций или плавных переходов, реализованных с помощью transition, вы можете использовать события, связанные с анимацией и переходами.</p><p>Для анимаций, вы можете использовать события 'animationstart', 'animationend' и 'animationiteration'. Например, с помощью JavaScript, вы можете добавить слушатель события 'animationend' к элементу, чтобы определить, когда анимация завершилась.</p><p>Для переходов, вы можете использовать событие 'transitionend', которое срабатывает, когда завершается переход. Таким образом, вы можете прослушивать это событие и выполнять соответствующие действия после завершения перехода.</p><p>В обоих случаях вы можете использовать JavaScript для добавления обработчиков событий к соответствующим элементам и выполнения необходимых действий после завершения анимации или перехода.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие свойства CSS могут быть обработаны непосредственно через GPU? Что такое композитные слои и почему их большое количество может привести к аварийному завершению работы браузера на мобильных устройствах?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые свойства CSS, которые могут быть обработаны непосредственно через GPU (графический процессор), включают transform, opacity, filter, и анимации и переходы, реализованные с помощью CSS @keyframes и transition.</p><p>Композитные слои - это отдельные графические поверхности, которые браузер использует для рендеринга элементов веб-страницы. При большом количестве композитных слоев браузеру требуется больше ресурсов, так как каждый слой должен быть отрисован и обновлен отдельно.</p><p>Большое количество композитных слоев может привести к аварийному завершению работы браузера на мобильных устройствах из-за ограниченных вычислительных возможностей и ограниченного доступа к памяти. При достижении предела возможностей устройства браузер может выйти из строя или зависнуть.</p><p>Оптимизация количества композитных слоев путем объединения элементов, использования аппаратного ускорения и применения оптимизаций рендеринга может помочь избежать проблем с производительностью и аварийными завершениями браузера на мобильных устройствах.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как переиспользовать инлайн SVG-элементы на странице?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для переиспользования инлайн SVG-элементов на странице можно использовать элемент <code>&lt;symbol&gt;</code> и элемент <code>&lt;use&gt;</code>.</p><ol><li>Определите <code>&lt;symbol&gt;</code> с уникальным идентификатором и содержимым SVG элемента, который хотите переиспользовать.</li><li>Используйте элемент <code>&lt;use&gt;</code> для ссылки на <code>&lt;symbol&gt;</code> и укажите его идентификатор с помощью атрибута <code>xlink:href</code>.</li></ol><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>html</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">symbol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"icon"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">circle</span> <span class="hljs-attr">cx</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">cy</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">r</span>=<span class="hljs-string">"40"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">symbol</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#icon"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlink:href</span>=<span class="hljs-string">"#icon"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">y</span>=<span class="hljs-string">"0"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
  </code></div></div></pre><p>В данном примере, <code>&lt;symbol&gt;</code> с id "icon" содержит <code>&lt;circle&gt;</code>. Затем, два элемента <code>&lt;use&gt;</code> используют ссылку на <code>&lt;symbol&gt;</code> с id "icon" для отображения круга на разных позициях на странице. Таким образом, инлайн SVG-элемент <code>&lt;circle&gt;</code> переиспользуется на странице.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1> Опишите способы оптимизации файлов SVG.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Вот несколько способов оптимизации файлов SVG:</p><ol><li><p>Удаление ненужных элементов и атрибутов: Избавьтесь от неиспользуемых элементов и атрибутов в SVG-файле.</p></li><li><p>Сокращение атрибутов: Используйте сокращенные формы атрибутов, например, замените <code>fill="black"</code> на <code>fill="#000"</code>.</p></li><li><p>Сжатие файлов: Используйте сжатие для уменьшения размера SVG-файла. Можно воспользоваться инструментами, такими как SVGO или онлайн-сервисы для сжатия.</p></li><li><p>Использование векторной оптимизации: Векторные графики могут быть оптимизированы путем устранения непрерывных линий, сокращения пути и удаления дублирующихся элементов.</p></li><li><p>Использование символьных ссылок: Если у вас есть повторяющиеся элементы в SVG, используйте символьные ссылки (symbolic links) или ссылки на шаблоны (template references) для повторного использования этих элементов.</p></li><li><p>Внедрение в CSS: Иногда можно внедрить SVG-код прямо в CSS-файл, используя <code>background-image</code> или <code>mask-image</code>, чтобы уменьшить количество HTTP-запросов.</p></li><li><p>Использование внешних файлов: Если у вас есть несколько SVG-изображений на странице, вы можете рассмотреть возможность использования внешних файлов и кэширования их браузером.</p></li></ol><p>Комбинация этих методов может помочь оптимизировать SVG-файлы, сократить размер и улучшить производительность загрузки.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как реализовать иконочный шрифт из определенного набора SVG-файлов?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для создания иконочного шрифта из набора SVG-файлов вы можете использовать следующие шаги:</p><ol><li><p>Создайте набор SVG-файлов, представляющих иконки, которые вы хотите включить в шрифт.</p></li><li><p>Импортируйте каждый SVG-файл в редактор иконок, такой как Fontello или IcoMoon. Эти инструменты позволяют объединять SVG-файлы в иконочный шрифт.</p></li><li><p>Подберите символьное имя для каждой иконки в шрифте.</p></li><li><p>Настройте параметры шрифта, такие как размер, способ отображения и прочие параметры, в соответствии с вашими потребностями.</p></li><li><p>Сгенерируйте иконочный шрифт, получив файлы шрифта в форматах, таких как TTF, EOT, WOFF, WOFF2, SVG.</p></li><li><p>Подключите сгенерированные файлы шрифта к вашему проекту, используя CSS-правила <code>@font-face</code>.</p></li><li><p>Используйте символьные имена, чтобы вставлять иконки в HTML-код, используя псевдоэлементы или классы.</p></li></ol><p>Таким образом, вы создадите иконочный шрифт из набора SVG-файлов и сможете использовать его для отображения иконок на вашем веб-сайте.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое ложное жирное или ложное курсивное (Faux) начертание шрифтов?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Ложное жирное (Faux Bold) и ложное курсивное (Faux Italic) начертания шрифтов являются эффектами, которые могут быть применены к шрифту в CSS для имитации жирного или курсивного стиля, когда сам шрифт не содержит соответствующих начертаний.</p><p>В случае ложного жирного начертания, браузер или приложение может увеличить толщину контура символов шрифта для создания визуального эффекта жирности.</p><p>В случае ложного курсивного начертания, браузер или приложение может наклонить символы шрифта, чтобы создать эффект курсива.</p><p>Однако, следует отметить, что ложные начертания могут иметь некоторые ограничения и не всегда выглядят так же качественно, как настоящие начертания шрифта. Лучшим решением будет использование шрифтов, которые уже содержат жирные и курсивные начертания, чтобы обеспечить более точное и согласованное отображение текста.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое #shadow-root в инспекторе HTML-страницы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>#shadow-root — это встроенный компонент Shadow DOM (объектная модель документа), который предоставляет изолированный сегмент DOM для создания и управления компонентами веб-интерфейса.</p><p>В инспекторе HTML-страницы #shadow-root отображается как корневой узел внутри элемента, указывающий на наличие веб-компонента с использованием Shadow DOM. Внутри #shadow-root содержится отдельное дерево элементов, скрытое от внешнего DOM. Это позволяет инкапсулировать структуру и стили компонента, предотвращая их воздействие на внешний контент.</p><p>Когда вы просматриваете #shadow-root в инспекторе, вы можете увидеть дочерние элементы, стили, обработчики событий и другие свойства, привязанные к данному компоненту. Это позволяет разработчикам изучать и отлаживать компоненты, а также модифицировать их поведение, если это разрешено.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем нужны Custom Elements?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Custom Elements (пользовательские элементы) позволяют разработчикам создавать свои собственные HTML-элементы с пользовательским поведением и функциональностью. Они предоставляют мощный инструмент для создания переиспользуемых компонентов, которые можно использовать в веб-приложениях.</p><p>Основные преимущества Custom Elements:</p><ol><li><p>Расширяемость HTML: Custom Elements позволяют расширять стандартный набор HTML-элементов, создавая новые собственные элементы с желаемым поведением и стилизацией.</p></li><li><p>Изоляция компонентов: Custom Elements работают в рамках Shadow DOM, что обеспечивает изоляцию стилей, DOM-структуры и функциональности компонента от внешнего контента, предотвращая конфликты и обеспечивая более простую поддержку и модификацию компонентов.</p></li><li><p>Переиспользуемость: Custom Elements позволяют создавать независимые и переиспользуемые компоненты, которые могут быть использованы в разных проектах или даже распространены через пакеты или библиотеки.</p></li><li><p>Расширяемость функциональности: Разработчики могут добавлять свои собственные методы, свойства и события к Custom Elements, делая их более гибкими и функциональными.</p></li></ol><p>Custom Elements являются важной составной частью Web Components, предоставляющих мощные инструменты для создания модульных и переиспользуемых компонентов веб-интерфейса.</p></div><div class="markdown prose w-full break-words dark:prose-invert light"><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title function_">observedAttributes</span>() {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'text'</span>];
  }

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_text</span> = <span class="hljs-string">''</span>;

    <span class="hljs-comment">// Добавляем функциональность, когда элемент добавляется в DOM</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'CustomElement создан!'</span>);
  }

  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Вызывается, когда элемент добавляется в DOM</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'CustomElement добавлен в DOM!'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
  }

  <span class="hljs-title function_">disconnectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Вызывается, когда элемент удаляется из DOM</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'CustomElement удален из DOM!'</span>);
  }

  <span class="hljs-title function_">attributeChangedCallback</span>(<span class="hljs-params">name, oldValue, newValue</span>) {
    <span class="hljs-comment">// Вызывается, когда атрибут элемента изменяется</span>
    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">'text'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_text</span> = newValue;
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
    }
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">text</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_text</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">text</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'text'</span>, value);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">\`&lt;p&gt;<span class="hljs-subst">\${<span class="hljs-variable language_">this</span>._text}</span>&lt;/p&gt;\`</span>;
  }
}

customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">'custom-element'</span>, <span class="hljs-title class_">CustomElement</span>);
</code></div></div></pre><p>Теперь у нашего пользовательского элемента есть свойство <code>text</code>, которое отображается внутри элемента. Когда значение этого свойства изменяется, пользовательский элемент автоматически обновляется.</p><p>Пример использования:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>html</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">custom-element</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> customElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'custom-element'</span>);
  customElement.<span class="hljs-property">text</span> = <span class="hljs-string">'Привет, мир!'</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></div></div></pre></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему удаление лишних символов пробелов/ символов переноса в HTML не отражается на конечной производительности загрузки страницы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Удаление лишних символов пробелов и символов переноса в HTML-коде не оказывает значительного влияния на производительность загрузки страницы по нескольким причинам:</p><ol><li><p>Сжатие данных: При передаче HTML-кода по сети используется сжатие данных, которое эффективно сжимает пробельные символы. Это означает, что удаление пробелов на этапе разработки не приведет к существенному сокращению размера передаваемых данных.</p></li><li><p>Кэширование: Браузеры используют механизм кэширования, который сохраняет загруженные ресурсы (включая HTML-код) на локальном устройстве. При последующих запросах страницы браузер может загрузить HTML-код из кэша, минуя процесс передачи по сети.</p></li><li><p>Обработка на стороне клиента: Большинство современных браузеров имеют оптимизированные алгоритмы обработки HTML-кода, которые эффективно пропускают и игнорируют лишние пробельные символы во время парсинга. Это означает, что удаление пробелов не приведет к значительному ускорению процесса обработки и рендеринга страницы.</p></li></ol><p>В целом, удаление лишних пробелов в HTML-коде может сделать код более компактным и читаемым для разработчиков, но не оказывает значительного влияния на производительность загрузки страницы. Более важные факторы, такие как оптимизация изображений, минимизация CSS и JavaScript-кода, имеют более существенное влияние на производительность загрузки страницы.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1> Что такое контекст отображения canvas? Какие существуют типы контекста для рендеринга двумерной и трехмерной графики?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Контекст отображения (display context) в Canvas — это объект, предоставляющий методы для рисования двумерной и трехмерной графики на элементе &lt;canvas&gt; в HTML. Существуют два основных типа контекста для рендеринга:</p><ol><li><p>Контекст 2D (2D context): Этот тип контекста, доступный через метод getContext("2d"), используется для рисования двумерной графики. Он предоставляет методы для создания путей, рисования геометрических фигур, заполнения и обводки объектов, настройки цвета и стиля, а также управления трансформациями и анимацией.</p></li><li><p>Контекст WebGL (Web Graphics Library): Этот тип контекста, доступный через метод getContext("webgl"), используется для рендеринга трехмерной графики с помощью WebGL, который является низкоуровневым API для взаимодействия с графическими аппаратными ресурсами браузера. Контекст WebGL предоставляет возможность создания и управления 3D-моделями, текстурами, шейдерами и освещением для создания интерактивных 3D-сцен на веб-страницах.</p></li></ol><p>Оба типа контекста отображения предоставляют мощные инструменты для создания визуальных эффектов и интерактивности на веб-страницах, но каждый из них имеет свои особенности и применяется в различных сценариях.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое JSX? Что лежит в его основе?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JSX (JavaScript XML) - это расширение языка JavaScript, которое позволяет встраивать код HTML-подобной разметки в JavaScript. Оно используется в фреймворках, таких как React, для создания декларативных пользовательских интерфейсов.</p><p>JSX основан на комбинации синтаксиса XML и JavaScript. Он позволяет разработчикам создавать компоненты, которые объединяют логику JavaScript и шаблоны разметки в одном файле. JSX позволяет вставлять JavaScript-выражения внутри разметки, что облегчает манипуляцию данными и динамическое создание интерфейса.</p><p>JSX преобразуется в обычный JavaScript с помощью транспилятора, например Babel, который преобразует JSX-синтаксис в вызовы функций и объекты JavaScript. Таким образом, JSX позволяет разработчикам писать код, который легко читается и поддерживается, и в то же время обеспечивает мощные возможности для создания интерфейсов с помощью компонентов и динамической обработки данных.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Для чего нужно свойство key при рендеринге списков?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Свойство key в React используется для оптимизации процесса рендеринга списков. Каждому элементу списка присваивается уникальный ключ, который помогает React отслеживать идентичность элементов при обновлении списка.</p><p>Когда происходят изменения в списке (добавление, удаление, перемещение элементов), React сравнивает ключи старых и новых элементов. Если ключи совпадают, React сохраняет состояние элемента, а не создает его заново. Это позволяет избежать перерисовки всего списка и улучшает производительность.</p><p>Ключи также используются для установления уникальности элементов списка при операциях, таких как поиск, сортировка или фильтрация. Они помогают React корректно обновлять только измененные элементы, сохраняя состояние остальных.</p><p>Важно, чтобы ключи были стабильными и уникальными в рамках списка. Использование неправильных или повторяющихся ключей может привести к непредсказуемому поведению и ошибкам в рендеринге списков.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между функциональными и классовыми компонентами?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Основная разница между функциональными и классовыми компонентами в React заключается в синтаксисе и способе определения компонента.</p><p>Функциональные компоненты определяются как обычные функции, которые принимают пропсы и возвращают JSX элементы. Они являются более простыми и лаконичными в написании, а также могут использовать хуки для работы с состоянием и другими возможностями React.</p><p>Классовые компоненты определяются как ES6 классы, которые расширяют базовый класс <code>React.Component</code>. Они имеют методы жизненного цикла, такие как <code>componentDidMount</code> и <code>componentDidUpdate</code>, и используют состояние (<code>this.state</code>) для хранения данных. Однако классовые компоненты имеют более объемный синтаксис и могут быть менее прямолинейными для понимания.</p><p>В React 16.8 были введены хуки, что позволило функциональным компонентам использовать состояние и другие функциональности, которые ранее были доступны только в классовых компонентах. Поэтому функциональные компоненты стали более предпочтительным подходом для большинства разработчиков, так как они обладают простым и гибким синтаксисом. Однако классовые компоненты все еще могут использоваться в старом коде или в случаях, когда требуется использование методов жизненного цикла, которые не предоставляются хуками.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем и когда нужно передавать props в super() при использовании классовых компонентов?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Когда вы создаете классовый компонент в React, вам нужно вызвать конструктор родительского класса (<code>super()</code>) перед доступом к <code>this</code>. Если вы хотите передать пропсы в конструктор родительского класса, вам необходимо передать их в <code>super()</code>.</p><p>Это особенно полезно, когда вы хотите использовать пропсы в конструкторе для инициализации состояния или для других целей. Например, если вы хотите использовать значение пропса в качестве начального состояния компонента, вы можете передать его в <code>super(props)</code> и затем присвоить его <code>this.state</code>.</p><p>Пример:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>jsx</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
          <span class="hljs-variable language_">super</span>(props);
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
            <span class="hljs-attr">count</span>: props.<span class="hljs-property">initialCount</span>
          };
        }
      
        <span class="hljs-comment">// остальной код компонента</span>
      }
      </code></div></div></pre><p>Таким образом, передача пропсов в <code>super()</code> позволяет использовать их внутри конструктора родительского класса и обеспечивает правильную инициализацию состояния компонента.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему необходимо использовать setState() для обновления внутреннего состояния компонента?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Использование метода <code>setState()</code> в React для обновления внутреннего состояния компонента важно по нескольким причинам:</p><ol><li><p>Обновление реактивности: При вызове <code>setState()</code> React обнаруживает изменения состояния компонента и аккуратно обновляет соответствующую часть виртуального DOM и перерисовывает только измененные элементы. Это повышает производительность, поскольку избегается полная перерисовка компонента.</p></li><li><p>Синхронность и безопасность: Использование <code>setState()</code> гарантирует, что обновления состояния будут выполнены синхронно и в правильном порядке, а не асинхронно. Кроме того, React обеспечивает безопасность обновления состояния, исключая прямые манипуляции с состоянием, что может привести к несогласованному состоянию компонента.</p></li><li><p>Вызов методов жизненного цикла: Использование <code>setState()</code> вызывает соответствующие методы жизненного цикла компонента, такие как <code>shouldComponentUpdate()</code> и <code>componentDidUpdate()</code>, что позволяет выполнять дополнительные действия перед обновлением или после обновления компонента.</p></li></ol><p>В целом, использование <code>setState()</code> вместо прямого изменения состояния является рекомендуемым подходом, который обеспечивает правильное обновление компонента и поддерживает консистентность и производительность в React-приложении.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как работает CSS Grid?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>CSS Grid - это мощный модуль CSS для создания сеток и управления размещением элементов на веб-странице. Работа CSS Grid основана на создании сетки с помощью контейнера и его дочерних элементов. Основные принципы работы:</p><ol><li><p>Создание сетки: Задается контейнер с помощью свойства <code>display: grid</code>, которое указывает браузеру, что контейнер должен быть обработан как сетка.</p></li><li><p>Определение колонок и строк: С помощью свойств <code>grid-template-columns</code> и <code>grid-template-rows</code> определяются размеры и количество колонок и строк в сетке.</p></li><li><p>Размещение элементов: Дочерним элементам контейнера присваиваются свойства, такие как <code>grid-column</code> и <code>grid-row</code>, для указания, в каких колонках и строках они должны располагаться.</p></li><li><p>Управление пространством: Используя свойства <code>grid-gap</code>, <code>grid-column-gap</code> и <code>grid-row-gap</code>, можно управлять пространством между элементами в сетке.</p></li><li><p>Адаптивность: CSS Grid позволяет легко настраивать поведение сетки для разных разрешений экрана с помощью медиа-запросов и свойства <code>grid-template-areas</code>.</p></li></ol><p>CSS Grid предоставляет много возможностей для создания сложных и гибких макетов, позволяя контролировать положение и размеры элементов на веб-странице.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем заключается принцип "подъема состояния" в React?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Принцип "подъема состояния" в React заключается в перемещении состояния из компонентов-потомков в их общего родителя. Это делается для обеспечения синхронизации и общего управления состоянием между компонентами. Когда несколько компонентов нуждаются в доступе и изменении одних и тех же данных, состояние переносится в ближайший общий родительский компонент.</p><p>Применение этого принципа помогает сократить дублирование кода, упростить управление состоянием и улучшить взаимодействие между компонентами. Поднимая состояние, изменения в одном компоненте автоматически отражаются в других компонентах, которые используют это состояние.</p><p>Однако следует помнить, что не всегда необходимо поднимать все состояние. Этот принцип следует применять тогда, когда компоненты действительно зависят от общего состояния, и только в тех случаях, когда это улучшает архитектуру и удобство разработки приложения.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие библиотеки менеджмента состояния React-приложения вы знаете? Для чего они?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Некоторые из популярных библиотек для менеджмента состояния в React-приложениях:</p><ol><li><p>Redux: Централизованное хранение состояния приложения, облегчает управление и обновление состояния.</p></li><li><p>MobX: Реактивное программирование с использованием наблюдаемых объектов. Управление состоянием осуществляется автоматически при изменении данных.</p></li><li><p>Zustand: Минималистичная библиотека для управления состоянием. Использует хук useState и контекст для создания глобального состояния.</p></li><li><p>Recoil: Управление состоянием с помощью атомов, которые представляют отдельные единицы состояния. Обеспечивает легкую передачу и синхронизацию данных между компонентами.</p></li><li><p>Context API: Встроенная в React возможность для передачи данных через дерево компонентов. Полезна для простых случаев управления состоянием.</p></li></ol><p>Эти библиотеки помогают управлять сложным состоянием приложения, облегчают обновление и синхронизацию данных между компонентами, а также упрощают отладку и тестирование кода. Выбор конкретной библиотеки зависит от требований и особенностей проекта.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Когда следует использовать Redux? Какие есть альтернативы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Redux следует использовать в случаях, когда у вас есть сложное состояние, которое должно быть доступно из разных частей приложения и управляемое централизованно. Это может быть полезно при больших проектах с множеством компонентов, которые должны взаимодействовать с общим состоянием.</p><p>Альтернативы Redux включают:</p><ol><li><p>Context API: Встроенная в React возможность передачи данных через дерево компонентов. Это подходит для простых случаев управления состоянием, но может стать неудобным при больших приложениях с глубокой вложенностью компонентов.</p></li><li><p>MobX: Библиотека, которая предоставляет реактивное программирование с использованием наблюдаемых объектов. Она позволяет автоматически обновлять состояние при изменении данных и является более декларативной по сравнению с Redux.</p></li><li><p>Zustand: Минималистичная библиотека для управления состоянием. Она использует хук useState и контекст для создания глобального состояния. Это хороший выбор для простых приложений, где не требуется сложная логика управления состоянием.</p></li></ol><p>Выбор между Redux и его альтернативами зависит от требований и масштаба вашего проекта. Если вам нужно централизованное управление сложным состоянием и вы ожидаете, что ваше приложение будет расти и развиваться, то Redux может быть хорошим выбором.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Redux vs Mobx?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Redux и MobX - две популярные библиотеки для управления состоянием в React-приложениях.</p><p>Redux предлагает строгую архитектуру с использованием однонаправленного потока данных и чистых функций-редьюсеров. Он подходит для больших проектов, где необходимо централизованное управление состоянием и сложная бизнес-логика. Redux обеспечивает предсказуемость и отслеживаемость изменений состояния, но требует больше кода и конфигурации.</p><p>MobX, с другой стороны, предлагает более декларативный и реактивный подход. Он использует наблюдаемые объекты, которые автоматически обновляют представление при изменении данных. MobX более прост в использовании и требует меньше кода для настройки, особенно для небольших проектов. Однако он может быть менее предсказуемым и менее подходящим для сложных бизнес-логик и больших проектов.</p><p>Выбор между Redux и MobX зависит от требований вашего проекта, предпочтений разработчиков и масштаба приложения. Если вам нужно более строгое управление состоянием и большая предсказуемость, выберите Redux. Если вы предпочитаете более декларативный и простой подход, то MobX может быть лучшим выбором.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о базовом принципе работы React Hooks.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Базовый принцип работы React Hooks заключается в возможности использования состояния и других функциональных возможностей React в функциональных компонентах без необходимости создания классовых компонентов. Hooks позволяют нам добавлять состояние, эффекты и другую функциональность внутри функциональных компонентов.</p><p>Основным хуком является useState, который позволяет добавлять локальное состояние в функциональный компонент. Другие хуки, такие как useEffect, useContext и useMemo, позволяют добавлять эффекты, работу с контекстом и мемоизацию.</p><p>Hooks следуют принципу «одной ответственности» и позволяют разделять логику компонента на более мелкие и повторно используемые куски. Они также обеспечивают лучшую читаемость и тестируемость кода, поскольку логика компонента становится более декларативной и модульной.</p><p>Принцип работы Hooks основан на механизмах замыкания и хранения состояния внутри React-контекста. Каждый хук имеет свою собственную внутреннюю память, которая сохраняется между рендерами компонента, и React автоматически отслеживает зависимости и обновляет компоненты при изменении состояния или данных.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между createRef и useRef?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Разница между <code>createRef</code> и <code>useRef</code> заключается в их использовании и возвращаемых значениях.</p><p><code>createRef</code> используется в классовых компонентах для создания ссылок на DOM-элементы. Он возвращает объект-ссылку, который можно привязать к <code>ref</code> атрибуту элемента и получить доступ к нему в методах класса.</p><p><code>useRef</code> используется в функциональных компонентах и имеет более широкий спектр применения. Он возвращает изменяемый объект, который сохраняет свое значение между рендерами компонента. <code>useRef</code> полезен для сохранения и получения состояния, не вызывая повторный рендер компонента.</p><p>Кроме того, <code>useRef</code> также предоставляет свойство <code>current</code>, где можно хранить и получать значения. Изменение значения <code>current</code> не вызывает повторный рендер компонента, поэтому его использование не приводит к обновлению пользовательского интерфейса.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Когда следует использовать React refs? Когда не стоит?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>React refs следует использовать в следующих случаях:</p><ol><li>Когда вам нужен доступ к DOM-элементам, таким как получение значения инпута или изменение размеров элемента.</li><li>Когда вам требуется взаимодействие с компонентами классов, которые не поддерживают хуки.</li><li>Когда вам нужно сохранить состояние, которое не вызывает повторный рендер компонента, например, для сохранения предыдущего состояния.</li></ol><p>Однако, использование React refs не всегда является лучшим подходом:</p><ol><li>Если вы можете решить задачу с помощью состояния и пропсов, то рекомендуется использовать их, поскольку это обеспечивает более декларативный и предсказуемый подход.</li><li>Если у вас есть альтернативные способы решения задачи без использования refs, например, с помощью событий или хуков, то стоит предпочесть эти способы, так как они могут быть более простыми и понятными.</li></ol><p>В целом, следует использовать React refs только в случаях, когда это действительно необходимо для решения конкретных задач, связанных с взаимодействием с DOM или классовыми компонентами.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие недостатки библиотеки React видите?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Несмотря на множество преимуществ, у React также есть некоторые недостатки:</p><ol><li>Крутой обучательный порог: React имеет крутую кривую обучения, особенно для разработчиков без предыдущего опыта работы с компонентными фреймворками.</li><li>Отсутствие стандартного подхода к управлению состоянием: React не предоставляет стандартного инструмента для управления состоянием приложения. Разработчики могут использовать Flux-архитектуру, Redux или MobX, что может вызывать путаницу.</li><li>Использование JSX: JSX-синтаксис, используемый в React, может вызывать замешательство у разработчиков, особенно у тех, кто привык работать с чистым HTML и CSS.</li><li>Размер бандла: Размер бандла React-приложения может быть значительным, особенно если в проекте используются множество сторонних библиотек и зависимостей.</li><li>Необходимость в компонентной архитектуре: Разработка в React требует разделения пользовательского интерфейса на множество компонентов, что может быть сложным для небольших и простых проектов.</li></ol><p>Несмотря на эти недостатки, React по-прежнему является одним из самых популярных и мощных фреймворков для разработки пользовательского интерфейса.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие паттерны используете вместе с React?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Вместе с React я часто использую следующие паттерны:</p><ol><li><p>Контейнер-компоненты и компоненты представления (Container-View): Разделяю компоненты на контейнеры, которые отвечают за управление состоянием и взаимодействие с внешними источниками данных, и компоненты представления, которые отображают данные и обрабатывают пользовательский ввод.</p></li><li><p>Паттерн "Подъем состояния" (Lifting State Up): Использую этот паттерн, чтобы поднимать общее состояние и логику управления состоянием на более высокий уровень компонентов, когда несколько компонентов должны совместно использовать и изменять одни и те же данные.</p></li><li><p>Компоненты высшего порядка (Higher-Order Components, HOC): Использую HOC для оборачивания компонентов и добавления дополнительной функциональности или поведения без изменения существующей логики компонента.</p></li><li><p>Рендер-пропсы (Render Props): Использую этот паттерн, когда нужно передать компоненту функцию, которая будет использоваться для рендеринга определенной части содержимого компонента.</p></li><li><p>Контекст (Context): Использую контекст, когда нужно передавать данные глубоко вниз по дереву компонентов без явной передачи через пропсы.</p></li></ol><p>Эти паттерны помогают мне создавать чистый, модульный и масштабируемый код при разработке с использованием React.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как относитесь к типизации вместе с React?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Я положительно отношусь к типизации вместе с React. Использование системы типов, такой как TypeScript или Flow, позволяет выявлять ошибки на этапе компиляции, предоставлять автодополнение и подсказки во время разработки, а также облегчает понимание кода другим разработчикам.</p><p>Типизация помогает предотвратить ошибки, связанные с передачей неправильных данных между компонентами, обнаруживать потенциальные проблемы при изменении интерфейсов компонентов и повышает общую надежность приложения.</p><p>Однако, типизация не является обязательной и может добавлять дополнительную сложность в разработку, особенно для небольших проектов или в командах, где не все разработчики привыкли к работе с типами. Поэтому, выбор использования типизации вместе с React зависит от требований проекта, размера команды и предпочтений разработчиков.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как построить хорошую архитектуру React-проекта?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для построения хорошей архитектуры React-проекта рекомендую следующие подходы:</p><ol><li><p>Разделение на компоненты: Разделите интерфейс на множество маленьких компонентов, каждый из которых отвечает за свою функцию. Это повышает переиспользуемость и улучшает поддержку кода.</p></li><li><p>Единообразие: Соблюдайте единообразие в стиле кодирования, нейминге компонентов и файловой структуре. Это делает код более понятным и облегчает сопровождение.</p></li><li><p>Управление состоянием: Используйте соответствующую библиотеку управления состоянием, такую как Redux или MobX, для централизованного хранения и обновления данных приложения.</p></li><li><p>Разделение ответственности: Разделяйте логику компонентов, бизнес-логику и отображение данных. Это позволяет лучше поддерживать и тестировать код.</p></li><li><p>Маршрутизация: Используйте библиотеку маршрутизации, такую как React Router, для управления навигацией в приложении.</p></li><li><p>Тестирование: Напишите тесты для компонентов и логики приложения. Используйте библиотеки тестирования, такие как Jest или React Testing Library, для обеспечения качества кода.</p></li><li><p>Оптимизация: Оптимизируйте производительность приложения, избегая лишних рендеров, используя мемоизацию и ленивую загрузку компонентов.</p></li><li><p>Документация: Создайте хорошо структурированную документацию, объясняющую архитектуру, использование компонентов и особенности проекта.</p></li></ol><p>Соблюдение этих принципов поможет создать хорошо организованный и легко поддерживаемый React-проект.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Оптимизация React-приложений? Как измерить производительность программы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для оптимизации React-приложений рекомендую следующие подходы:</p><ol><li><p>Минимизация лишних рендеров: Используйте мемоизацию и PureComponent/React.memo для предотвращения повторных рендеров компонентов при отсутствии изменений в пропсах или состоянии.</p></li><li><p>Ленивая загрузка компонентов: Разделите приложение на кодовые сплиты и загружайте компоненты по требованию. Это ускоряет начальную загрузку и улучшает производительность.</p></li><li><p>Оптимизация работы с состоянием: Используйте управление состоянием (например, Redux) для избегания глубоких обновлений компонентов и оптимизации работы с данными.</p></li><li><p>Использование селекторов: Используйте библиотеки селекторов (например, Reselect) для создания мемоизированных селекторов, которые предотвращают повторные вычисления при неизменных входных данных.</p></li><li><p>Асинхронная загрузка данных: Загружайте данные асинхронно и показывайте промежуточное состояние или загрузочные индикаторы пользователю.</p></li></ol><p>Чтобы измерить производительность программы, можно использовать инструменты разработчика браузера, такие как Chrome DevTools. Они предоставляют информацию о времени рендеринга, использовании ресурсов и производительности JavaScript кода. Можно также использовать библиотеки для профилирования, например, React Profiler, для определения узких мест и оптимизации производительности приложения.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Можно ли приложение на React встроить в другое приложение на React?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Да, приложение на React можно встроить в другое приложение на React. Это достигается путем использования компонента-контейнера, который может включать в себя компоненты приложения и обрабатывать их состояние и данные. Встроенное приложение может быть отрисовано внутри другого компонента при помощи JSX-синтаксиса. Это позволяет создавать модульные и масштабируемые приложения, где различные компоненты могут быть повторно использованы и встроены в разные части приложения.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Почему Node.js однопоточный, а не многопоточный?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Node.js основан на JavaScript, который изначально разрабатывался для выполнения в браузерах, где основной поток выполнения является однопоточным. Node.js сохраняет эту однопоточную модель для обеспечения согласованности и простоты программирования. Вместо создания множества потоков, Node.js использует асинхронную модель ввода-вывода (I/O), которая позволяет обрабатывать множество запросов без блокирования основного потока. Это позволяет Node.js эффективно обрабатывать большое количество параллельных соединений, таких как обработка HTTP-запросов. Кроме того, однопоточная модель облегчает разработку и отладку кода, упрощает синхронизацию данных и предотвращает состояние гонки. Однако, Node.js также поддерживает многопоточность через использование потоков-детей и рабочих потоков, что позволяет выполнять вычислительно интенсивные задачи параллельно.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое event driven development?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Event-driven development (EDD) - это подход к разработке программного обеспечения, основанный на обработке событий. В EDD программа реагирует на различные события, которые происходят в системе, и выполняет соответствующие действия. События могут быть вызваны пользовательским вводом, изменением состояния программы, получением данных из внешних источников и т. д. Главная идея EDD заключается в том, чтобы разделить выполнение программы на обработку событий и ожидание новых событий, вместо традиционного последовательного выполнения кода. Это позволяет создавать отзывчивые и масштабируемые системы, которые эффективно реагируют на изменения и обрабатывают несколько событий параллельно. EDD широко используется во многих областях, включая веб-разработку, пользовательские интерфейсы, серверные приложения и другие системы, где важно эффективно обрабатывать асинхронные события.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Сравните fork() и spawn() методы.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Методы fork() и spawn() являются функциями для создания новых процессов в Node.js. Они имеют несколько различий:</p><ol><li><p>fork() используется для создания дочернего процесса, который является точной копией родительского процесса, включая все открытые файлы и соединения. Дочерний процесс может использовать свой собственный Event Loop и выполнять код независимо от родительского процесса. С другой стороны, spawn() создает новый процесс, в котором может быть выполнена указанная команда.</p></li><li><p>fork() используется, когда требуется выполнить параллельные вычисления или разделить задачи между процессами. Родительский и дочерний процессы могут взаимодействовать через механизм IPC (Inter-Process Communication). Спавн() обычно используется для запуска внешних программ или команд.</p></li><li><p>При использовании fork(), каждый процесс имеет свой собственный экземпляр Node.js и может использовать модули и глобальные переменные независимо друг от друга. При использовании spawn(), можно выполнить любую команду из командной строки, не ограничиваясь Node.js.</p></li></ol><p>В целом, fork() более подходит для параллельных вычислений и взаимодействия между процессами, а spawn() - для запуска внешних программ или команд.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о Node.js используемых фреймворках. Какая между ними разница?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Node.js имеет множество фреймворков, которые облегчают разработку веб-приложений. Некоторые популярные фреймворки для Node.js включают Express.js, Koa.js и Nest.js.</p><p>Express.js - это легкий и гибкий фреймворк, который предоставляет минимальный набор функций для создания веб-приложений. Он имеет простой API и широкую поддержку со стороны сообщества.</p><p>Koa.js - это более современный фреймворк, разработанный тем же автором, что и Express.js. Koa.js предоставляет более удобный способ управления асинхронными операциями с использованием промисов и асинхронных функций (async/await).</p><p>Nest.js - это фреймворк, основанный на TypeScript, который предлагает модульную и масштабируемую архитектуру для разработки серверных приложений. Он включает в себя функциональность для обработки маршрутизации, внедрения зависимостей и других распространенных задач.</p><p>Разница между ними заключается в философии и подходе к разработке. Express.js предоставляет минимальный набор инструментов, позволяя разработчикам выбирать и подключать необходимые компоненты по своему усмотрению. Koa.js сосредоточен на использовании промисов и асинхронных функций для обработки запросов. Nest.js предлагает более структурированный подход к разработке, используя модульность и инъекцию зависимостей.</p><p>Выбор фреймворка зависит от требований проекта и предпочтений разработчика.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите словами код эндпоинта, который должен сохранить из клиента файл размером 4 гигабайта и положить его на S3 или другой CDN.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Эндпоинт для сохранения файла размером 4 гигабайта на S3 или другую CDN может быть реализован следующим образом:</p><ol><li><p>Подготовка клиента: Клиент должен разбить файл на части или использовать потоковую передачу данных для эффективной передачи больших файлов.</p></li><li><p>Установка соединения с S3: Используя SDK для работы с S3, создайте подключение к сервису S3, предоставив необходимые учетные данные и конфигурацию.</p></li><li><p>Создание объекта файла: Используя функции SDK S3, создайте объект файла на S3 с указанным именем и метаданными, которые могут быть нужны для будущего использования.</p></li><li><p>Загрузка файла: Используя функции SDK S3, загрузите данные файла на S3, передавая их блоками или потоком. Обработайте возможные ошибки и контролируйте прогресс загрузки.</p></li><li><p>Обработка завершения загрузки: После успешной загрузки файла на S3 или другую CDN может потребоваться выполнить дополнительные операции, например, отправить уведомление клиенту об успешной загрузке или обновить базу данных с информацией о файле.</p></li></ol><p>Важно учесть, что для работы с такими большими файлами потребуется подходящая конфигурация сервера и оптимальное использование ресурсов, чтобы избежать перегрузки и обеспечить эффективность передачи.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое микросервисы, зачем их используют?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Микросервисы - это подход к разработке программного обеспечения, при котором приложение разбивается на небольшие, автономные и независимо развертываемые сервисы. Каждый микросервис отвечает за конкретную функциональность и взаимодействует с другими сервисами посредством сетевых вызовов (чаще всего через API).</p><p>Основная цель использования микросервисной архитектуры - облегчить масштабирование, гибкость и поддержку приложения. Преимущества микросервисов включают:</p><ol><li><p>Гибкость: Каждый сервис может быть разработан, развернут и масштабирован независимо. Это позволяет легко вносить изменения и внедрять новые функции без влияния на остальные компоненты системы.</p></li><li><p>Масштабируемость: Сервисы могут масштабироваться отдельно в зависимости от нагрузки. Это позволяет эффективно использовать ресурсы и обеспечивает лучшую производительность при росте объемов данных или пользователей.</p></li><li><p>Ускорение разработки: Микросервисы позволяют распределить разработку на небольшие и независимые команды. Это способствует ускорению процесса разработки и позволяет быстро внедрять новые функции.</p></li><li><p>Технологическое разнообразие: Каждый сервис может использовать различные технологии, языки программирования и базы данных в зависимости от своих потребностей.</p></li></ol><p>Однако, использование микросервисов также вносит дополнительную сложность в управлении системой, требует более тщательного мониторинга и тестирования, а также может потребовать дополнительных усилий для обеспечения надежности и безопасности межсервисного взаимодействия.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В каких случаях вы бы выбрали монолит, а в каких — микросервисы?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Выбор между монолитной архитектурой и микросервисами зависит от конкретных требований и контекста проекта.</p><p>Монолитная архитектура подходит, когда:</p><ul><li>Проект небольшой и простой, и нет необходимости в сложном масштабировании или гибкости.</li><li>Отсутствуют требования к независимой разработке, развертыванию и масштабированию компонентов.</li><li>Внутренние связи между компонентами проекта сильны и сложность разбиения на сервисы будет выше выгод.</li></ul><p>Микросервисная архитектура подходит, когда:</p><ul><li>Проект большой и сложный, и требуется масштабируемость, гибкость и возможность независимой разработки компонентов.</li><li>Разные части проекта имеют разные требования к технологиям и масштабированию.</li><li>Хочется избежать "единой точки отказа" и улучшить отказоустойчивость системы.</li><li>Возможна распределенная разработка и сотрудничество над разными сервисами.</li></ul><p>Решение зависит от уникальных требований проекта, командной структуры и ожидаемой сложности разработки и масштабирования. В некоторых случаях может быть целесообразным использовать комбинацию обоих подходов, создавая гибкую и масштабируемую архитектуру.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как понять, что приложение в определенный момент работает исправно?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для определения того, что приложение работает исправно, можно обратить внимание на следующие факторы:</p><ol><li><p>Функциональность: Убедитесь, что все основные функции приложения работают без ошибок и выполняют свою задачу верно.</p></li><li><p>Отзывчивость: Приложение должно реагировать на взаимодействие пользователя без задержек или замедлений.</p></li><li><p>Стабильность: Проверьте, что приложение не вылетает или не вызывает ошибок, и может обрабатывать различные сценарии использования без сбоев.</p></li><li><p>Внешний вид: Удостоверьтесь, что пользовательский интерфейс отображается корректно и выглядит согласно ожиданиям дизайна.</p></li><li><p>Журналирование и мониторинг: Используйте механизмы журналирования и мониторинга, чтобы отслеживать ошибки, производительность и доступность приложения.</p></li><li><p>Тестирование: Регулярно проводите тестирование, включая модульное, интеграционное и приемочное тестирование, чтобы обнаружить и исправить возможные проблемы.</p></li></ol><p>Важно иметь надежный процесс контроля качества и систему отслеживания ошибок, чтобы быстро реагировать на возможные проблемы и обеспечить непрерывную работу приложения.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как понять, что приложение последние три дня работало исправно?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для определения того, что приложение последние три дня работало исправно, можно выполнить следующие шаги:</p><ol><li><p>Мониторинг: Используйте инструменты мониторинга, чтобы отслеживать работу приложения и собирать метрики производительности, доступности и ошибок. Проверьте, что все метрики находятся в норме без значительных отклонений.</p></li><li><p>Журналирование: Анализируйте журналы приложения, чтобы выявить потенциальные ошибки, предупреждения или необычное поведение. Убедитесь, что не появилось новых или повторяющихся проблем.</p></li><li><p>Отзывы пользователей: Проконсультируйтесь с пользователями, чтобы узнать, были ли у них проблемы или недостатки в работе приложения. Обратите внимание на любые отрицательные отзывы или жалобы.</p></li><li><p>Регрессионное тестирование: Проведите регрессионное тестирование приложения, чтобы убедиться, что все основные функции работают исправно после внесенных изменений или обновлений.</p></li><li><p>Анализ производительности: Проверьте метрики производительности приложения, такие как время отклика, загрузка страницы, использование ресурсов и пропускная способность. Убедитесь, что производительность приложения остается стабильной и не ухудшается.</p></li><li><p>Резервное копирование: Убедитесь, что регулярно создаются резервные копии данных приложения, чтобы восстановить их в случае необходимости.</p></li></ol><p>Комбинируя эти методы, можно получить общую картину о работоспособности приложения за последние три дня и выявить любые потенциальные проблемы или несоответствия.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Как происходит проверка правильности пароля при использовании bcrypt?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При использовании bcrypt для проверки правильности пароля происходит следующий процесс:</p><ol><li><p>Получение хэша пароля: Изначально, при регистрации или создании учетной записи, пароль пользователя хэшируется с помощью bcrypt. Хэш представляет собой длинную строку, которая является результатом применения алгоритма bcrypt к паролю.</p></li><li><p>Хранение хэша в базе данных: Полученный хэш пароля сохраняется в базе данных вместо самого пароля. Это важно для безопасности, так как хэш нельзя обратно преобразовать в исходный пароль.</p></li><li><p>Проверка пароля: При попытке входа пользователя в систему, введенный им пароль сравнивается с хранящимся в базе данных хэшем пароля. Для этого используется функция bcrypt.compare(), которая сравнивает введенный пароль с хэшем и возвращает результат сравнения.</p></li><li><p>Сравнение хэшей: Внутри функции bcrypt.compare() происходит сравнение хэшей пароля и введенного пароля. Bcrypt сравнивает хэши и гарантирует, что хэш введенного пароля соответствует хэшу, сохраненному в базе данных.</p></li></ol><p>Если сравнение успешно, то пароль считается правильным, и пользователь получает доступ к системе. Если сравнение не проходит, то пароль считается неправильным, и доступ отказывается. Благодаря хэшированию и сравнению хэшей, пароли остаются безопасными, даже если база данных становится доступной злоумышленникам.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое JWT?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>JWT (JSON Web Token) - это открытый стандарт для создания токенов доступа, которые могут быть переданы и проверены между двумя сторонами. Он состоит из трех частей: заголовка, полезной нагрузки и подписи.</p><p>Заголовок содержит информацию о типе токена и используемом алгоритме подписи. Полезная нагрузка (payload) содержит данные, такие как идентификатор пользователя и срок действия токена. Подпись используется для проверки подлинности токена и обеспечения его целостности.</p><p>JWT широко используется для аутентификации и авторизации в веб-приложениях. После успешной аутентификации сервер генерирует JWT и включает в него необходимую информацию о пользователе. Клиент сохраняет токен и отправляет его с каждым запросом на сервер в заголовке авторизации.</p><p>Сервер может проверить подлинность токена, декодировать полезную нагрузку и принять решение о предоставлении доступа на основе информации в нем. JWT не требует хранения состояния на сервере, что делает его масштабируемым и подходящим для распределенных систем.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Джуниор прислал код на ревью. Что здесь не так? Как исправить?
    router.post ( '/ users', async (req, res, next) => {
      const user = await db.createUser (req);
    
      if (user) {
        return res.json (users);
      }
    
      res.json ({error: "can not create user"})
    })</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В представленном коде есть несколько проблем:</p><ol><li><p>Неправильное использование функции <code>createUser</code> из объекта <code>db</code>. Вместо передачи всего объекта <code>req</code>, нужно передать только необходимые данные для создания пользователя. Например, <code>req.body</code> содержит тело запроса с данными пользователя.</p></li><li><p>Необъявленная переменная <code>users</code> в методе <code>res.json(users)</code>. Вместо этого, нужно использовать переменную <code>user</code>, которая содержит созданного пользователя.</p></li></ol><p>Исправленный код:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/users'</span>, <span class="hljs-keyword">async</span> (req, res, next) =&gt; {
        <span class="hljs-keyword">const</span> userData = req.<span class="hljs-property">body</span>; <span class="hljs-comment">// Получение данных пользователя из тела запроса</span>
        <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">createUser</span>(userData);
      
        <span class="hljs-keyword">if</span> (user) {
          <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>(user); <span class="hljs-comment">// Отправка созданного пользователя в ответе</span>
        }
      
        res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">"Can not create user"</span> });
      });
      </code></div></div></pre><p>В исправленном коде мы передаем только необходимые данные для создания пользователя и возвращаем созданного пользователя в ответе.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое Redis и для чего его используют?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Redis (Remote Dictionary Server) - это высокопроизводительная ключ-значение база данных в оперативной памяти. Она используется для кэширования данных, управления сессиями, обработки очередей задач, реализации публикации-подписки и других сценариев.</p><p>Redis обладает следующими особенностями:</p><ol><li>Быстродействие: хранение данных в оперативной памяти позволяет достигать высоких скоростей обработки запросов.</li><li>Поддержка различных структур данных: Redis поддерживает строковые значения, списки, множества, хэши и сортированные множества, что делает его гибким для разных задач.</li><li>Поддержка операций атомарности: Redis обеспечивает атомарные операции, что полезно для работы с счетчиками, блокировками и другими задачами, требующими согласованности данных.</li><li>Репликация и высокая доступность: Redis позволяет создавать реплики для обеспечения отказоустойчивости и повышения доступности данных.</li><li>Возможность распределенного кэширования: Redis может использоваться в качестве распределенного кэша для улучшения производительности и снижения нагрузки на базу данных.</li></ol><p>Redis широко применяется в веб-приложениях для ускорения работы с базами данных, кэширования запросов, реализации сессий и временного хранения данных. Он также используется в системах очередей сообщений, аналитических системах и других сценариях, где требуется высокая производительность и гибкость работы с данными.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Какие базы данных использовались? Какая разница между SQL и NoSQL?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>В разработке программного обеспечения широко используются два типа баз данных: SQL (Structured Query Language) и NoSQL (Not Only SQL).</p><p>SQL базы данных, такие как MySQL, PostgreSQL, Oracle, используют структурированный подход к хранению данных. Они опираются на схему таблиц, связей и язык SQL для управления данными. SQL базы данных обеспечивают сильную согласованность данных и хорошо подходят для сложных и связанных данных, требующих точности и целостности.</p><p>NoSQL базы данных, такие как MongoDB, Redis, Cassandra, отличаются от SQL баз тем, что они предоставляют гибкую схему хранения данных и не требуют использования SQL для запросов. Они масштабируются горизонтально, обеспечивая высокую производительность при работе с большим объемом данных. NoSQL базы данных обычно используются для хранения неструктурированных или полуструктурированных данных, а также в случаях, когда требуется масштабируемость и гибкость.</p><p>Разница между SQL и NoSQL заключается в подходе к структурированию данных, способе работы с запросами и масштабируемости. SQL базы данных обеспечивают строгую структуру и согласованность данных, поддерживают ACID-транзакции, а NoSQL базы данных предлагают гибкую схему, высокую производительность и масштабируемость. Выбор между SQL и NoSQL зависит от требований проекта, типа данных и ожидаемой производительности.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Дай ёмкий  ответ не более 500 символов на вопрос Для двух таблиц - комментарии и пользователи - напишите запрос, который выбирает последние три комментария для каждого пользователя.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Для выбора последних трех комментариев для каждого пользователя, можно использовать следующий запрос:</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>sql</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-sql"><span class="hljs-keyword">SELECT</span> c.user_id, c.comment
    <span class="hljs-keyword">FROM</span> (
        <span class="hljs-keyword">SELECT</span> user_id, comment,
               <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> user_id <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> comment_date <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> rn
        <span class="hljs-keyword">FROM</span> comments
    ) <span class="hljs-keyword">AS</span> c
    <span class="hljs-keyword">WHERE</span> c.rn <span class="hljs-operator">&lt;=</span> <span class="hljs-number">3</span>
    </code></div></div></pre><p>В данном запросе мы используем внутренний подзапрос, который нумерует комментарии для каждого пользователя по убывающей дате комментария. Затем, во внешнем запросе, мы выбираем только комментарии с номером ряда не больше 3 для каждого пользователя. Это позволяет выбрать последние три комментария для каждого пользователя из таблицы комментариев.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Я в качестве заказчика прошу выбрать вас базу данных для нового проекта. Ваши действия?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>При выборе базы данных для нового проекта, я бы рассмотрел несколько факторов:</p><ol><li><p>Тип данных и модель хранения: Определите, какие типы данных вы будете хранить и какая модель хранения лучше всего подходит для вашего проекта. Реляционные базы данных, такие как MySQL или PostgreSQL, хорошо подходят для структурированных данных, а NoSQL базы данных, такие как MongoDB или Cassandra, предоставляют гибкость для хранения неструктурированных данных.</p></li><li><p>Масштабируемость: Если ваш проект требует горизонтального масштабирования и обработки больших объемов данных, то NoSQL базы данных или распределенные базы данных, такие как Apache Cassandra, могут быть предпочтительными.</p></li><li><p>Производительность: Рассмотрите требования к производительности вашего проекта. Некоторые базы данных, такие как Redis или Memcached, специализируются на быстром кэшировании данных, в то время как другие, такие как Elasticsearch, предоставляют мощные возможности поиска и аналитики.</p></li><li><p>Экосистема и поддержка: Учтите наличие активной сообщества, документации и инструментов, связанных с выбранной базой данных. Это поможет вам получить поддержку и решить возникающие проблемы.</p></li><li><p>Бюджет: Разберитесь в доступности и стоимости лицензирования выбранной базы данных. Некоторые базы данных имеют открытые лицензии или предлагают бесплатные версии, в то время как другие могут требовать платных лицензий или подписок.</p></li></ol><p>Исходя из этих факторов, я могу рекомендовать базу данных, которая лучше всего соответствует вашим потребностям и требованиям проекта.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем нужен package-lock.json?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Файл package-lock.json является частью экосистемы Node.js и используется для фиксации версий пакетов, установленных в проекте. Он гарантирует, что при повторной установке зависимостей будут использованы те же самые версии пакетов.</p><p>Основные причины использования package-lock.json:</p><ol><li><p>Воспроизводимость: Файл package-lock.json сохраняет точные версии пакетов, используемых в проекте. Это позволяет другим разработчикам и системам воспроизвести точно такую же среду разработки.</p></li><li><p>Быстрая установка: package-lock.json содержит ссылки на предварительно скачанные пакеты, что ускоряет процесс установки зависимостей, так как нет необходимости загружать пакеты повторно.</p></li><li><p>Разрешение зависимостей: package-lock.json содержит информацию о зависимостях пакетов, включая их версии и зависимости друг от друга. Это позволяет системе Node.js точно разрешать и устанавливать совместимые версии пакетов.</p></li><li><p>Безопасность: Файл package-lock.json также помогает обнаруживать потенциальные уязвимости пакетов, так как он фиксирует версии и обновления зависимостей, позволяя легче выполнять проверки безопасности.</p></li></ol><p>В целом, использование package-lock.json повышает стабильность, надежность и безопасность проекта, обеспечивая контроль над зависимостями и версиями пакетов.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между npm install и npm ci?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Основная разница между командами <code>npm install</code> и <code>npm ci</code> заключается в способе установки зависимостей проекта.</p><ul><li><p><code>npm install</code> используется для установки зависимостей, указанных в файле package.json. Он может использовать информацию из файла package-lock.json или создавать его при отсутствии. В случае использования package-lock.json, <code>npm install</code> устанавливает пакеты в соответствии с фиксированными версиями, указанными в файле.</p></li><li><p><code>npm ci</code> используется для установки зависимостей в строгом режиме. Он игнорирует файл package.json и всегда полагается на существующий файл package-lock.json. Команда <code>npm ci</code> гарантирует, что будут установлены точные версии пакетов, указанные в package-lock.json, и не производит никаких обновлений или изменений в этом файле.</p></li></ul><p>Основное применение <code>npm ci</code> состоит в автоматической установке зависимостей в средах Continuous Integration (CI) или во время развертывания приложения, где требуется строгое соответствие фиксированным версиям пакетов из package-lock.json. Она гарантирует повторяемость установки зависимостей и обеспечивает более надежный и предсказуемый процесс развертывания.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Зачем нужны бандлеры?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Бандлеры - это инструменты, используемые в веб-разработке для объединения и упаковки различных модулей и ресурсов приложения в один или несколько файлов, называемых бандлами. Они выполняют несколько важных задач:</p><ol><li><p>Объединение модулей: Бандлеры позволяют разработчикам разбивать код на модули и импортировать их в других модулях. Бандлеры автоматически определяют зависимости между модулями и создают итоговый бандл, включающий все необходимые модули.</p></li><li><p>Разрешение зависимостей: Бандлеры обеспечивают правильное разрешение зависимостей между модулями. Они анализируют импорты и экспорты модулей, чтобы убедиться, что каждая зависимость корректно подключена и доступна во время выполнения.</p></li><li><p>Управление ресурсами: Бандлеры также могут обрабатывать и объединять другие ресурсы, такие как стили CSS, изображения, шрифты и т. д. Это позволяет оптимизировать загрузку приложения, объединяя все необходимые ресурсы в один или несколько файлов.</p></li><li><p>Оптимизация и минимизация: Бандлеры могут выполнять различные оптимизации, такие как минификация кода, удаление неиспользуемых частей, сжатие и т. д. Это помогает уменьшить размер и улучшить производительность загружаемого приложения.</p></li></ol><p>Итак, бандлеры являются неотъемлемой частью современной веб-разработки, обеспечивая структурирование кода, управление зависимостями, оптимизацию и упаковку ресурсов для более эффективной разработки и более быстрой загрузки веб-приложений.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Расскажите о модульном подключении скриптов. Приведите пример использования загрузчиков/ бандлеров модулей.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Модульное подключение скриптов - это подход, который позволяет разбить код на отдельные модули и импортировать их по мере необходимости. Вместо одного большого скрипта, весь код разделяется на небольшие модули с четко определенным функционалом.</p><p>Пример использования загрузчиков/бандлеров модулей:</p><ol><li>Webpack: Один из наиболее популярных инструментов для сборки JavaScript-модулей. Он позволяет определить точку входа, а затем автоматически анализирует зависимости модулей и создает бандлы, которые содержат все необходимые модули. Пример конфигурации Webpack:</li></ol><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
      <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.js'</span>,
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
        <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
      },
    };
    </code></div></div></pre><ol start="2"><li>Rollup: Легковесный инструмент, который также используется для сборки модулей. Rollup фокусируется на создании оптимизированных бандлов с минимальным размером. Пример конфигурации Rollup:</li></ol><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
      <span class="hljs-attr">input</span>: <span class="hljs-string">'src/index.js'</span>,
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">file</span>: <span class="hljs-string">'dist/bundle.js'</span>,
        <span class="hljs-attr">format</span>: <span class="hljs-string">'umd'</span>,
      },
    };
    </code></div></div></pre><ol start="3"><li>Parcel: Простой и быстрый инструмент, который автоматически анализирует зависимости и создает бандлы без необходимости настройки сложной конфигурации. Просто укажите точку входа, и Parcel самостоятельно обработает модули. Пример использования Parcel:</li></ol><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>bash</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-bash">parcel build src/index.js --out-dir dist
    </code></div></div></pre><p>Все эти инструменты позволяют разрабатывать веб-приложения с использованием модульного подхода, автоматически обрабатывая зависимости и создавая бандлы, которые могут быть загружены в браузере. Это облегчает управление кодом, повышает производительность и упрощает разработку сложных приложений.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>В чем разница между git merge и git rebase?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Git merge и git rebase - это две разные стратегии объединения изменений веток в Git.</p><p>Git merge объединяет изменения из одной ветки в другую, создавая новый коммит с объединенными изменениями. При выполнении merge создается дополнительный коммит, который представляет собой результат объединения. Это сохраняет историю изменений каждой ветки и является предпочтительным подходом при работе с командами или фичами, которые могут продолжать развиваться независимо.</p><p>Git rebase, с другой стороны, переосновывает текущую ветку на основе другой ветки. Он переносит все коммиты текущей ветки поверх последнего коммита из целевой ветки. При выполнении rebase история изменений выглядит линейно, без дополнительных слияний. Это позволяет создавать более линейную и чистую историю изменений. Однако использование rebase может быть проблематичным, если изменения уже были опубликованы или с ними работают другие разработчики.</p><p>Вкратце, merge сохраняет историю изменений каждой ветки, создавая новый коммит с объединенными изменениями, а rebase переносит коммиты текущей ветки поверх другой ветки, создавая линейную историю. Выбор между ними зависит от конкретной ситуации и предпочтений разработчика.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Что такое staging area в git?</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Staging area, также известная как индекс, в Git - это промежуточный шаг между рабочей директорией и репозиторием. Она представляет собой область, где вы можете подготовить изменения перед фиксацией (commit).</p><p>Когда вы вносите изменения в рабочую директорию, Git отслеживает их, но они ещё не добавлены в историю репозитория. Чтобы включить изменения в следующий коммит, вы должны явно добавить их в стейджинг-область с помощью команды <code>git add</code>. Это позволяет вам контролировать, какие изменения будут включены в следующий коммит.</p><p>Staging area позволяет вам формировать логически связанные коммиты, разделять изменения на отдельные пакеты и вносить последовательные изменения, не фиксируя их сразу.</p><p>Когда вы считаете, что все нужные изменения находятся в стейджинг-области, вы можете выполнить команду <code>git commit</code>, чтобы создать новый коммит с зафиксированными изменениями из стейджинг-области. Это добавляет изменения в историю репозитория и делает их постоянными.</p><p>Staging area в Git предоставляет гибкость и контроль над коммитами, позволяя вам выбирать, какие изменения включать в следующий коммит.</p></div>`,
    group: "Middle",
  },
  {
    front: `<h1>Опишите процесс code review. Назовите основные правила, способы разрешения конфликтов и споров во время его проведения.</h1>`,
    back: `<div class="markdown prose w-full break-words dark:prose-invert light"><p>Code review - это процесс проверки кода, выполняемый другими разработчиками для обеспечения его качества, соответствия стандартам и выявления потенциальных проблем. Основные правила включают:</p><ol><li><p>Будьте конструктивными и уважительными: Фокусируйтесь на улучшении кода, а не на личностных аспектах. Предлагайте конструктивные рекомендации и объясняйте свои комментарии.</p></li><li><p>Соблюдайте стандарты кодирования: Проверяйте, соответствует ли код установленным правилам форматирования и стиля, чтобы обеспечить единообразие и читаемость.</p></li><li><p>Проводите подробные обзоры: Внимательно изучите весь код, обратите внимание на возможные ошибки, уязвимости, недостатки производительности и несоответствия требованиям.</p></li><li><p>Документируйте свои комментарии: Поясняйте свои предложения и замечания, чтобы авторы поняли причину их внесения.</p></li></ol><p>Конфликты и споры во время code review могут быть разрешены следующими способами:</p><ol><li><p>Обсуждение: Встречайтесь с автором кода и обсудите обнаруженные проблемы. Важно выслушать точку зрения других и найти компромиссное решение.</p></li><li><p>Комментарии с объяснениями: Подробно объясните свои комментарии и предложения, чтобы избежать недопонимания и уточнить свои ожидания.</p></li><li><p>Документирование решений: Если есть разногласия, записывайте принятые решения и причины, чтобы в дальнейшем избежать повторных споров и обеспечить согласованность.</p></li><li><p>Коллективное принятие решений: Включите других разработчиков или тимлида для принятия окончательного решения в случае сложных спорных вопросов.</p></li></ol><p>Цель code review - повышение качества кода, обмен знаниями и согласование стиля разработки. Важно поддерживать открытую коммуникацию и стремиться к общему согласию.</p></div>`,
    group: "Middle",
  },
];
